








Router02 | Uniswap





Skip to main contentUniswap DocsConceptsContractsSDKsAPIsGive FeedbackWhitepaperGitHubGrantsSearchV3 ProtocolOverviewGuidesSet Up Your Local EnvironmentImplement A SwapProviding LiquidityLiquidity MiningImplement Flash SwapsGovernance ProposalsTechnical ReferenceUniversal RouterPermit2V2 ProtocolOverviewConceptsProtocol OverviewCore ConceptsAdvanced TopicsGuidesInterface IntegrationSmart Contract IntegrationTechnical ReferenceAPIGovernanceSmart ContractsFactoryPairPair (ERC-20)LibraryRouter01Router02Common ErrorsV1 Protocolüè†V2 ProtocolTechnical ReferenceSmart ContractsRouter02Helpful?On this pageRouter02Because routers are stateless and do not hold token balances, they can be replaced safely and trustlessly, if necessary. This may happen if more efficient smart contract patterns are discovered, or if additional functionality is desired. For this reason, routers have release numbers, starting at 01. This is currently recommended release, 02.CodeUniswapV2Router02.solAddressUniswapV2Router02 is deployed at 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D on the Ethereum mainnet, and the Ropsten, Rinkeby, G√∂rli, and Kovan testnets. It was built from commit 6961711.Read-Only Functionsfactory‚Äãfunction factory() external pure returns (address);CopyReturns factory address.WETH‚Äãfunction WETH() external pure returns (address);CopyReturns the canonical WETH address on the Ethereum mainnet, or the Ropsten, Rinkeby, G√∂rli, or Kovan testnets.quote‚ÄãSee quote.getAmountOut‚ÄãSee getAmountOut.getAmountIn‚ÄãSee getAmountIn.getAmountsOut‚Äãfunction getAmountsOut(uint amountIn, address[] memory path) public view returns (uint[] memory amounts);CopySee getAmountsOut.getAmountsIn‚Äãfunction getAmountsIn(uint amountOut, address[] memory path) public view returns (uint[] memory amounts);CopySee getAmountsIn.State-Changing FunctionsaddLiquidity‚Äãfunction addLiquidity(  address tokenA,  address tokenB,  uint amountADesired,  uint amountBDesired,  uint amountAMin,  uint amountBMin,  address to,  uint deadline) external returns (uint amountA, uint amountB, uint liquidity);CopyAdds liquidity to an ERC-20‚áÑERC-20 pool.To cover all possible scenarios, msg.sender should have already given the router an allowance of at least amountADesired/amountBDesired on tokenA/tokenB.Always adds assets at the ideal ratio, according to the price when the transaction is executed.If a pool for the passed tokens does not exists, one is created automatically, and exactly amountADesired/amountBDesired tokens are added.NameTypetokenAaddressA pool token.tokenBaddressA pool token.amountADesireduintThe amount of tokenA to add as liquidity if the B/A price is <= amountBDesired/amountADesired (A depreciates).amountBDesireduintThe amount of tokenB to add as liquidity if the A/B price is <= amountADesired/amountBDesired (B depreciates).amountAMinuintBounds the extent to which the B/A price can go up before the transaction reverts. Must be <= amountADesired.amountBMinuintBounds the extent to which the A/B price can go up before the transaction reverts. Must be <= amountBDesired.toaddressRecipient of the liquidity tokens.deadlineuintUnix timestamp after which the transaction will revert.amountAuintThe amount of tokenA sent to the pool.amountBuintThe amount of tokenB sent to the pool.liquidityuintThe amount of liquidity tokens minted.addLiquidityETH‚Äãfunction addLiquidityETH(  address token,  uint amountTokenDesired,  uint amountTokenMin,  uint amountETHMin,  address to,  uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);CopyAdds liquidity to an ERC-20‚áÑWETH pool with ETH.To cover all possible scenarios, msg.sender should have already given the router an allowance of at least amountTokenDesired on token.Always adds assets at the ideal ratio, according to the price when the transaction is executed.msg.value is treated as a amountETHDesired.Leftover ETH, if any, is returned to msg.sender.If a pool for the passed token and WETH does not exists, one is created automatically, and exactly amountTokenDesired/msg.value tokens are added.NameTypetokenaddressA pool token.amountTokenDesireduintThe amount of token to add as liquidity if the WETH/token price is <= msg.value/amountTokenDesired (token depreciates).msg.value (amountETHDesired)uintThe amount of ETH to add as liquidity if the token/WETH price is <= amountTokenDesired/msg.value (WETH depreciates).amountTokenMinuintBounds the extent to which the WETH/token price can go up before the transaction reverts. Must be <= amountTokenDesired.amountETHMinuintBounds the extent to which the token/WETH price can go up before the transaction reverts. Must be <= msg.value.toaddressRecipient of the liquidity tokens.deadlineuintUnix timestamp after which the transaction will revert.amountTokenuintThe amount of token sent to the pool.amountETHuintThe amount of ETH converted to WETH and sent to the pool.liquidityuintThe amount of liquidity tokens minted.removeLiquidity‚Äãfunction removeLiquidity(  address tokenA,  address tokenB,  uint liquidity,  uint amountAMin,  uint amountBMin,  address to,  uint deadline) external returns (uint amountA, uint amountB);CopyRemoves liquidity from an ERC-20‚áÑERC-20 pool.msg.sender should have already given the router an allowance of at least liquidity on the pool.NameTypetokenAaddressA pool token.tokenBaddressA pool token.liquidityuintThe amount of liquidity tokens to remove.amountAMinuintThe minimum amount of tokenA that must be received for the transaction not to revert.amountBMinuintThe minimum amount of tokenB that must be received for the transaction not to revert.toaddressRecipient of the underlying assets.deadlineuintUnix timestamp after which the transaction will revert.amountAuintThe amount of tokenA received.amountBuintThe amount of tokenB received.removeLiquidityETH‚Äãfunction removeLiquidityETH(  address token,  uint liquidity,  uint amountTokenMin,  uint amountETHMin,  address to,  uint deadline) external returns (uint amountToken, uint amountETH);CopyRemoves liquidity from an ERC-20‚áÑWETH pool and receive ETH.msg.sender should have already given the router an allowance of at least liquidity on the pool.NameTypetokenaddressA pool token.liquidityuintThe amount of liquidity tokens to remove.amountTokenMinuintThe minimum amount of token that must be received for the transaction not to revert.amountETHMinuintThe minimum amount of ETH that must be received for the transaction not to revert.toaddressRecipient of the underlying assets.deadlineuintUnix timestamp after which the transaction will revert.amountTokenuintThe amount of token received.amountETHuintThe amount of ETH received.removeLiquidityWithPermit‚Äãfunction removeLiquidityWithPermit(  address tokenA,  address tokenB,  uint liquidity,  uint amountAMin,  uint amountBMin,  address to,  uint deadline,  bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountA, uint amountB);CopyRemoves liquidity from an ERC-20‚áÑERC-20 pool without pre-approval, thanks to permit.NameTypetokenAaddressA pool token.tokenBaddressA pool token.liquidityuintThe amount of liquidity tokens to remove.amountAMinuintThe minimum amount of tokenA that must be received for the transaction not to revert.amountBMinuintThe minimum amount of tokenB that must be received for the transaction not to revert.toaddressRecipient of the underlying assets.deadlineuintUnix timestamp after which the transaction will revert.approveMaxboolWhether or not the approval amount in the signature is for liquidity or uint(-1).vuint8The v component of the permit signature.rbytes32The r component of the permit signature.sbytes32The s component of the permit signature.amountAuintThe amount of tokenA received.amountBuintThe amount of tokenB received.removeLiquidityETHWithPermit‚Äãfunction removeLiquidityETHWithPermit(  address token,  uint liquidity,  uint amountTokenMin,  uint amountETHMin,  address to,  uint deadline,  bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountToken, uint amountETH);CopyRemoves liquidity from an ERC-20‚áÑWETTH pool and receive ETH without pre-approval, thanks to permit.NameTypetokenaddressA pool token.liquidityuintThe amount of liquidity tokens to remove.amountTokenMinuintThe minimum amount of token that must be received for the transaction not to revert.amountETHMinuintThe minimum amount of ETH that must be received for the transaction not to revert.toaddressRecipient of the underlying assets.deadlineuintUnix timestamp after which the transaction will revert.approveMaxboolWhether or not the approval amount in the signature is for liquidity or uint(-1).vuint8The v component of the permit signature.rbytes32The r component of the permit signature.sbytes32The s component of the permit signature.amountTokenuintThe amount of token received.amountETHuintThe amount of ETH received.removeLiquidityETHSupportingFeeOnTransferTokens‚Äãfunction removeLiquidityETHSupportingFeeOnTransferTokens(  address token,  uint liquidity,  uint amountTokenMin,  uint amountETHMin,  address to,  uint deadline) external returns (uint amountETH);CopyIdentical to removeLiquidityETH, but succeeds for tokens that take a fee on transfer.msg.sender should have already given the router an allowance of at least liquidity on the pool.NameTypetokenaddressA pool token.liquidityuintThe amount of liquidity tokens to remove.amountTokenMinuintThe minimum amount of token that must be received for the transaction not to revert.amountETHMinuintThe minimum amount of ETH that must be received for the transaction not to revert.toaddressRecipient of the underlying assets.deadlineuintUnix timestamp after which the transaction will revert.amountETHuintThe amount of ETH received.removeLiquidityETHWithPermitSupportingFeeOnTransferTokens‚Äãfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(  address token,  uint liquidity,  uint amountTokenMin,  uint amountETHMin,  address to,  uint deadline,  bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountETH);CopyIdentical to removeLiquidityETHWithPermit, but succeeds for tokens that take a fee on transfer.NameTypetokenaddressA pool token.liquidityuintThe amount of liquidity tokens to remove.amountTokenMinuintThe minimum amount of token that must be received for the transaction not to revert.amountETHMinuintThe minimum amount of ETH that must be received for the transaction not to revert.toaddressRecipient of the underlying assets.deadlineuintUnix timestamp after which the transaction will revert.approveMaxboolWhether or not the approval amount in the signature is for liquidity or uint(-1).vuint8The v component of the permit signature.rbytes32The r component of the permit signature.sbytes32The s component of the permit signature.amountETHuintThe amount of ETH received.swapExactTokensForTokens‚Äãfunction swapExactTokensForTokens(  uint amountIn,  uint amountOutMin,  address[] calldata path,  address to,  uint deadline) external returns (uint[] memory amounts);CopySwaps an exact amount of input tokens for as many output tokens as possible, along the route determined by the path. The first element of path is the input token, the last is the output token, and any intermediate elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).msg.sender should have already given the router an allowance of at least amountIn on the input token.NameTypeamountInuintThe amount of input tokens to send.amountOutMinuintThe minimum amount of output tokens that must be received for the transaction not to revert.pathaddress[] calldataAn array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.toaddressRecipient of the output tokens.deadlineuintUnix timestamp after which the transaction will revert.amountsuint[] memoryThe input token amount and all subsequent output token amounts.swapTokensForExactTokens‚Äãfunction swapTokensForExactTokens(  uint amountOut,  uint amountInMax,  address[] calldata path,  address to,  uint deadline) external returns (uint[] memory amounts);CopyReceive an exact amount of output tokens for as few input tokens as possible, along the route determined by the path. The first element of path is the input token, the last is the output token, and any intermediate elements represent intermediate tokens to trade through (if, for example, a direct pair does not exist).msg.sender should have already given the router an allowance of at least amountInMax on the input token.NameTypeamountOutuintThe amount of output tokens to receive.amountInMaxuintThe maximum amount of input tokens that can be required before the transaction reverts.pathaddress[] calldataAn array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.toaddressRecipient of the output tokens.deadlineuintUnix timestamp after which the transaction will revert.amountsuint[] memoryThe input token amount and all subsequent output token amounts.swapExactETHForTokens‚Äãfunction swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)  external  payable  returns (uint[] memory amounts);CopySwaps an exact amount of ETH for as many output tokens as possible, along the route determined by the path. The first element of path must be WETH, the last is the output token, and any intermediate elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).NameTypemsg.value (amountIn)uintThe amount of ETH to send.amountOutMinuintThe minimum amount of output tokens that must be received for the transaction not to revert.pathaddress[] calldataAn array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.toaddressRecipient of the output tokens.deadlineuintUnix timestamp after which the transaction will revert.amountsuint[] memoryThe input token amount and all subsequent output token amounts.swapTokensForExactETH‚Äãfunction swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)  external  returns (uint[] memory amounts);CopyReceive an exact amount of ETH for as few input tokens as possible, along the route determined by the path. The first element of path is the input token, the last must be WETH, and any intermediate elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).msg.sender should have already given the router an allowance of at least amountInMax on the input token.If the to address is a smart contract, it must have the ability to receive ETH.NameTypeamountOutuintThe amount of ETH to receive.amountInMaxuintThe maximum amount of input tokens that can be required before the transaction reverts.pathaddress[] calldataAn array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.toaddressRecipient of ETH.deadlineuintUnix timestamp after which the transaction will revert.amountsuint[] memoryThe input token amount and all subsequent output token amounts.swapExactTokensForETH‚Äãfunction swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)  external  returns (uint[] memory amounts);CopySwaps an exact amount of tokens for as much ETH as possible, along the route determined by the path. The first element of path is the input token, the last must be WETH, and any intermediate elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).If the to address is a smart contract, it must have the ability to receive ETH.NameTypeamountInuintThe amount of input tokens to send.amountOutMinuintThe minimum amount of output tokens that must be received for the transaction not to revert.pathaddress[] calldataAn array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.toaddressRecipient of the ETH.deadlineuintUnix timestamp after which the transaction will revert.amountsuint[] memoryThe input token amount and all subsequent output token amounts.swapETHForExactTokens‚Äãfunction swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)  external  payable  returns (uint[] memory amounts);CopyReceive an exact amount of tokens for as little ETH as possible, along the route determined by the path. The first element of path must be WETH, the last is the output token and any intermediate elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).Leftover ETH, if any, is returned to msg.sender.NameTypeamountOutuintThe amount of tokens to receive.msg.value (amountInMax)uintThe maximum amount of ETH that can be required before the transaction reverts.pathaddress[] calldataAn array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.toaddressRecipient of the output tokens.deadlineuintUnix timestamp after which the transaction will revert.amountsuint[] memoryThe input token amount and all subsequent output token amounts.swapExactTokensForTokensSupportingFeeOnTransferTokens‚Äãfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(  uint amountIn,  uint amountOutMin,  address[] calldata path,  address to,  uint deadline) external;CopyIdentical to swapExactTokensForTokens, but succeeds for tokens that take a fee on transfer.msg.sender should have already given the router an allowance of at least amountIn on the input token.NameTypeamountInuintThe amount of input tokens to send.amountOutMinuintThe minimum amount of output tokens that must be received for the transaction not to revert.pathaddress[] calldataAn array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.toaddressRecipient of the output tokens.deadlineuintUnix timestamp after which the transaction will revert.swapExactETHForTokensSupportingFeeOnTransferTokens‚Äãfunction swapExactETHForTokensSupportingFeeOnTransferTokens(  uint amountOutMin,  address[] calldata path,  address to,  uint deadline) external payable;CopyIdentical to swapExactETHForTokens, but succeeds for tokens that take a fee on transfer.NameTypemsg.value (amountIn)uintThe amount of ETH to send.amountOutMinuintThe minimum amount of output tokens that must be received for the transaction not to revert.pathaddress[] calldataAn array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.toaddressRecipient of the output tokens.deadlineuintUnix timestamp after which the transaction will revert.swapExactTokensForETHSupportingFeeOnTransferTokens‚Äãfunction swapExactTokensForETHSupportingFeeOnTransferTokens(  uint amountIn,  uint amountOutMin,  address[] calldata path,  address to,  uint deadline) external;CopyIdentical to swapExactTokensForETH, but succeeds for tokens that take a fee on transfer.If the to address is a smart contract, it must have the ability to receive ETH.NameTypeamountInuintThe amount of input tokens to send.amountOutMinuintThe minimum amount of output tokens that must be received for the transaction not to revert.pathaddress[] calldataAn array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.toaddressRecipient of the ETH.deadlineuintUnix timestamp after which the transaction will revert.Interfaceimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';Copypragma solidity >=0.6.2;interface IUniswapV2Router01 {    function factory() external pure returns (address);    function WETH() external pure returns (address);    function addLiquidity(        address tokenA,        address tokenB,        uint amountADesired,        uint amountBDesired,        uint amountAMin,        uint amountBMin,        address to,        uint deadline    ) external returns (uint amountA, uint amountB, uint liquidity);    function addLiquidityETH(        address token,        uint amountTokenDesired,        uint amountTokenMin,        uint amountETHMin,        address to,        uint deadline    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);    function removeLiquidity(        address tokenA,        address tokenB,        uint liquidity,        uint amountAMin,        uint amountBMin,        address to,        uint deadline    ) external returns (uint amountA, uint amountB);    function removeLiquidityETH(        address token,        uint liquidity,        uint amountTokenMin,        uint amountETHMin,        address to,        uint deadline    ) external returns (uint amountToken, uint amountETH);    function removeLiquidityWithPermit(        address tokenA,        address tokenB,        uint liquidity,        uint amountAMin,        uint amountBMin,        address to,        uint deadline,        bool approveMax, uint8 v, bytes32 r, bytes32 s    ) external returns (uint amountA, uint amountB);    function removeLiquidityETHWithPermit(        address token,        uint liquidity,        uint amountTokenMin,        uint amountETHMin,        address to,        uint deadline,        bool approveMax, uint8 v, bytes32 r, bytes32 s    ) external returns (uint amountToken, uint amountETH);    function swapExactTokensForTokens(        uint amountIn,        uint amountOutMin,        address[] calldata path,        address to,        uint deadline    ) external returns (uint[] memory amounts);    function swapTokensForExactTokens(        uint amountOut,        uint amountInMax,        address[] calldata path,        address to,        uint deadline    ) external returns (uint[] memory amounts);    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)        external        payable        returns (uint[] memory amounts);    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)        external        returns (uint[] memory amounts);    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)        external        returns (uint[] memory amounts);    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)        external        payable        returns (uint[] memory amounts);    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);}interface IUniswapV2Router02 is IUniswapV2Router01 {    function removeLiquidityETHSupportingFeeOnTransferTokens(        address token,        uint liquidity,        uint amountTokenMin,        uint amountETHMin,        address to,        uint deadline    ) external returns (uint amountETH);    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(        address token,        uint liquidity,        uint amountTokenMin,        uint amountETHMin,        address to,        uint deadline,        bool approveMax, uint8 v, bytes32 r, bytes32 s    ) external returns (uint amountETH);    function swapExactTokensForTokensSupportingFeeOnTransferTokens(        uint amountIn,        uint amountOutMin,        address[] calldata path,        address to,        uint deadline    ) external;    function swapExactETHForTokensSupportingFeeOnTransferTokens(        uint amountOutMin,        address[] calldata path,        address to,        uint deadline    ) external payable;    function swapExactTokensForETHSupportingFeeOnTransferTokens(        uint amountIn,        uint amountOutMin,        address[] calldata path,        address to,        uint deadline    ) external;}CopyABIimport IUniswapV2Router02 from '@uniswap/v2-periphery/build/IUniswapV2Router02.json'Copyhttps://unpkg.com/@uniswap/v2-periphery@1.1.0-beta.0/build/IUniswapV2Router02.jsonEdit this pageHelpful?PreviousRouter01NextCommon ErrorsfactoryWETHquotegetAmountOutgetAmountIngetAmountsOutgetAmountsInaddLiquidityaddLiquidityETHremoveLiquidityremoveLiquidityETHremoveLiquidityWithPermitremoveLiquidityETHWithPermitremoveLiquidityETHSupportingFeeOnTransferTokensremoveLiquidityETHWithPermitSupportingFeeOnTransferTokensswapExactTokensForTokensswapTokensForExactTokensswapExactETHForTokensswapTokensForExactETHswapExactTokensForETHswapETHForExactTokensswapExactTokensForTokensSupportingFeeOnTransferTokensswapExactETHForTokensSupportingFeeOnTransferTokensswapExactTokensForETHSupportingFeeOnTransferTokensDevelopersFeedbackBug Bounty#dev-chatWhitepaperGithubuniswap-v3-coreuniswap-v3-sdkuniswap-v3-peripheryDeployment addressesEcosystemHomeAppAnalyticsToken ListsBrand AssetsCommunityGovernanceDiscordTwitterBlog



