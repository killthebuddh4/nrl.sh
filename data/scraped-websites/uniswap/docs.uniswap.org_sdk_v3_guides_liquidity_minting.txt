








Minting a Position | Uniswap





Skip to main contentUniswap DocsConceptsContractsSDKsAPIsGive FeedbackWhitepaperGitHubGrantsSearchV3 SDKOverviewGuidesBackgroundGetting a QuoteExecuting a TradeRouting a SwapPooling LiquidityMinting a PositionAdding & Removing LiquidityCollecting FeesSwapping and Adding LiquidityTechnical ReferenceSwap Widgetweb3-reactCore SDKV2 SDKV1 SDKüè†V3 SDKGuidesPooling LiquidityMinting a PositionHelpful?On this pageMinting a PositionIntroduction‚ÄãThis guide will cover how to create (or mint) a liquidity position on the Uniswap V3 protocol.
It is based on the minting a position code example, found in the Uniswap code examples repository.
To run this example, check out the examples's README and follow the setup instructions.infoIf you need a briefer on the SDK and to learn more about how these guides connect to the examples repository, please visit our background page!In the Uniswap V3 protocol, liquidity positions are represented using non-fungible tokens. In this guide we will use the NonfungiblePositionManager class to help us mint a liquidity position for the  USDC - DAI pair. The inputs to our guide are the two tokens that we are pooling for, the amount of each token we are pooling for and the Pool fee.The guide will cover:Giving approval to transfer our tokensCreating an instance of a PoolCalculating our Position from our input tokensConfiguring and executing our minting transactionAt the end of the guide, given the inputs above, we should be able to mint a liquidity position with the press of a button and view the position on the UI of the web application.For this guide, the following Uniswap packages are used:@uniswap/v3-sdk@uniswap/sdk-core@uniswap/smart-order-routerThe core code of this guide can be found in mintPosition()Giving approval to transfer our tokens‚ÄãThe first step is to give approval to the protocol's NonfungiblePositionManager to transfer our tokens:Approving our tokens for transferringloading...CopyView on GithubThe logic to achieve that is wrapped in the getTokenTransferApprovals function. In short, since both USDC and DAI are ERC20 tokens, we setup a reference to their smart contracts and call the approve function:Setting up an ERC20 contract reference and approvingloading...CopyView on GithubCreating an instance of a Pool‚ÄãHaving approved the transfer of our tokens, we now need to get data about the pool for which we will provide liquidity, in order to instantiate a Pool class.To start, we compute our Pool's address by using a helper function and passing in the unique identifiers of a Pool - the two tokens and the Pool fee. The fee input parameter represents the swap fee that is distributed to all in range liquidity at the time of the swap:Computing the Pool's addressloading...CopyView on GithubThen, we get the Pool's data by creating a reference to the Pool's smart contract and accessing its methods:Setting up a Pool contract reference and fetching current state dataloading...CopyView on GithubHaving collected the required data, we can now create an instance of the Pool class:Fetching pool data and creating an instance of the Pool classloading...CopyView on GithubCalculating our Position from our input tokens‚ÄãHaving created the instance of the Pool class, we can now use that to create an instance of a Position class, which represents the price range for a specific pool that LPs choose to provide in:Create a Position representation instanceloading...CopyView on GithubWe use the fromAmounts static function of the Position class to create an instance of it, which uses the following parameters:The tickLower and tickUpper parameters specify the price range at which to provide liquidity. This example calls nearestUsableTick to get the current useable tick and adjust the lower parameter to be below it by two tickSpacing and the upper to be above it by two tickSpacing. This guarantees that the provided liquidity is "in range", meaning it will be earning fees upon minting this positionamount0 and amount1 define the maximum amount of currency the liquidity position can use. In this example, we supply these from our configuration parameters.Given those parameters, fromAmounts will attempt to calculate the maximum amount of liquidity we can supply.Configuring and executing our minting transaction‚ÄãThe Position instance is then passed as input to the NonfungiblePositionManager's addCallParameters function. The function also requires an AddLiquidityOptions object as its second parameter. This is either of type MintOptions for minting a new position or IncreaseOptions for adding liquidity to an existing position. For this example, we're using a MintOptions to create our position.Getting the transaction calldata and parametersloading...CopyView on GithubThe function returns the calldata as well as the value required to execute the transaction:Submitting the Position NFT minting transactionloading...CopyView on GithubThe effect of the transaction is to mint a new Position NFT. We should see a new position with liquidity in our list of positions.Next Steps‚ÄãOnce you have minted a position, our next guide (Adding and Removing Liquidity) will demonstrate how you can add and remove liquidity from that minted position!Helpful?PreviousRouting a SwapNextAdding & Removing LiquidityIntroductionGiving approval to transfer our tokensCreating an instance of a PoolCalculating our Position from our input tokensConfiguring and executing our minting transactionNext StepsDevelopersFeedbackBug Bounty#dev-chatWhitepaperGithubuniswap-v3-coreuniswap-v3-sdkuniswap-v3-peripheryDeployment addressesEcosystemHomeAppAnalyticsToken ListsBrand AssetsCommunityGovernanceDiscordTwitterBlog



