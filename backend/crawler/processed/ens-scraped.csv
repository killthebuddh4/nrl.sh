,fname,text
0,mains contract api reference publicresolver#set canonical name,"mains contract api reference publicresolver#set canonical name.   PublicResolver - ENS Documentation    ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookPublicResolverThe default public resolver.​Source​PublicResolver implements a general-purpose ENS resolver that is suitable for most standard ENS use-cases. The public resolver permits updates to ENS records by the owner of the corresponding name.The public resolver implements the following EIPs:​EIP 137 - Contract address interface (addr()).​EIP 165 - Interface Detection (supportsInterface()).​EIP 181 - Reverse resolution (name()).​EIP 205 - ABI support (ABI()).​EIP 619 - SECP256k1 public keys (pubkey()).​EIP 634 - Text records (text()).​EIP 1577 - Content hash support (contenthash()).​EIP 2304 - Multicoin support (addr()).While the PublicResolverprovides a convenient default implementation, many resolver implementations and versions exist. Callers must not assume that a domain uses the current version of the public resolver, or that all of the methods described here are present. To check if a resolver supports a feature, see Check Interface Support.Check Interface Supportfunction supportsInterface(bytes4 interfaceID) external pure returns (bool)ENS uses ERC 165 for interface detection. ERC 165 requires that supporting contracts implement a function, supportsInterface, which takes an interface ID and returns a boolean value indicating if this interface is supported or not.Interface IDs are calculated as the exclusive-or of the four-byte function identifiers of each function included in the interface. For example, addr(bytes32) has the function ID 0x3b3b57de. Because it is the only function in the Ethereum Address interface, its interface ID is also 0x3b3b57de, and so calling supportsInterface(0x3b3b57de) will return true for any resolver that supports addr().ERC 165 has an interface ID of 0x01ffc9a7, so supportsInterface(0x01ffc9a7) will always return true for any ERC 165 supporting contract (and hence for any resolver).Note that the public resolver does not expose explicit interfaces for setter functions, so there are no automated means to check for support for a given setter function.Get Ethereum Addressfunction addr(bytes32 node) external view returns (address)Returns the Ethereum address associated with the provided node, or 0 if none.This function has interface ID 0x3b3b57de.This function is specified in EIP 137.Set Ethereum Addressfunction setAddr(bytes32 node, address addr) external;Sets the Ethereum address associated with the provided node to addr.Only callable by the owner of node.Emits the following event:event AddrChanged(bytes32 indexed node, address a);Get Blockchain Addressfunction addr(bytes32 node, uint coinType) external view returns(bytes memory);Returns the Blockchain address associated with the provided node and coinType, or 0 if none.This function has interface ID 0xf1cb7e06.This function is specified in EIP 2304.The return value is the cryptocurrency address in its native binary format and each blockchain address has a different encoding and decoding method.For example, the Bitcoin address 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa base58check decodes to the 21 bytes 0062e907b15cbf27d5425399ebf6f0fb50ebb88f18 then scriptPubkey encodes to 25 bytes 76a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1888ac whereas the BNB address bnb1grpf0955h0ykzq3ar5nmum7y6gdfl6lxfn46h2 Bech32 decodes to the binary representation 40c2979694bbc961023d1d27be6fc4d21a9febe6.To convert the binary representation into the address, use formatsByCoinType[SYMBOL].encoder(binary) of address-encoder.A zero-length string will be returned if the specified coin ID does not exist on the specified node.Set Blockchain Addressfunction setAddr(bytes32 node, uint coinType, bytes calldata a) external;Sets the blockchain address associated with the provided node and coinType to addr.coinType is the cryptocurrency coin type index from SLIP44.To convert the address into the binary representation, use formatsByName[SYMBOL].decoder(text) of address-encoder​Only callable by the owner of node.Emits the following event:event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);Get Canonical Namefunction name(bytes32 node) external view returns (string memory);Returns the canonical ENS name associated with the provided node. Used exclusively for reverse resolution.This function has interface ID 0x691f3431.This function is specified in EIP 181.Set Canonical Namefunction setName(bytes32 node, string calldata name) external;Sets the canonical ENS name for the provided node to name.Only callable by the owner of node.Emits the following event:event NameChanged(bytes32 indexed node, string name);Get Content Hashfunction contenthash(bytes32 node) external view returns (bytes memory);Returns the content hash for node, if one exists. Values are formatted as machine-readable multicodecs, as specified in EIP 1577.contenthash is used to store IPFS and Swarm content hashes, which permit resolving ENS addresses to distributed content (eg, websites) hosted on these distributed networks.This function has interface ID 0xbc1c58d1.This function is specified in EIP 1577.Set Content Hashfunction setContenthash(bytes32 node, bytes calldata hash) external;Sets the content hash for the provided node to hash.Only callable by the owner of node.Values are formatted as machine-readable multicodecs, as specified in EIP 1577.Emits the following event:event ContenthashChanged(bytes32 indexed node, bytes hash);Get Contract ABIABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory);Returns a matching ABI definition for the provided node, if one exists. contentTypes is the bitwise-OR of the encodings that the caller can accept. If multiple content types are specified, the resolver will select one to return. Currently supported content types are:Content Type IDDescription1JSON2zlib-compressed JSON4​CBOR​8URIABI returns a two-tuple of the content type ID and the ABI data. If no data of the appropriate content type ID was found, 0 is returned for the content type ID, and the ABI data will be the empty string.This function has interface ID 0x2203ab56.This function is specified in EIP 205.Set Contract ABIfunction setABI(bytes32 node, uint256 contentType, bytes calldata data) externalSets or updates ABI data for node. contentType specifies the content type ID (see Get Contract ABI for valid values); exactly one type ID must be specified. data contains the encoded ABI data. To clear ABI data for a name, specify the empty string for data.Only callable by the owner of node.Emits the following event:event ABIChanged(bytes32 indexed node, uint256 indexed contentType);Get Public Keyfunction pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y)Returns the ECDSA SECP256k1 public key for node, as a 2-tuple (x, y). If no public key is set, (0, 0) is returned.This function has interface ID 0xc8690233.This function is specified in EIP 619.Set Public Keyfunction setPubkey(bytes32 node, bytes32 x, bytes32 y) externalSets the ECDSA SECP256k1 public key for node to (x, y).Only callable by the owner of node.Emits the following event:event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);Get Text Datafunction text(bytes32 node, string calldata key) external view returns (string memory)Retrieves text metadata for node. Each name may have multiple pieces of metadata, identified by a unique string key. If no text data exists for node with the key key, the empty string is returned.Standard values for key are:keyMeaningemailAn email addressurlA URLavatarA URL to an image used as an avatar or logodescriptionA description of the namenoticeA notice regarding this namekeywordsA list of comma-separated keywords, ordered by most significant first; clients that interpresent this field may choose a threshold beyond which to ignoreIn addition, anyone may specify vendor-specific keys, which must be prefixed with vnd.. The following vendor-specific keys are currently known:keyMeaningcom.twitterTwitter handlecom.githubGithub usernameThis function has interface ID 0x59d1d43c.This function is specified in EIP 634.Set Text Datafunction setText(bytes32 node, string calldata key, string calldata value) externalSets text metadata for node with the unique key key to value, overwriting anything previously stored for node and key. To clear a text field, set it to the empty string.Only callable by the owner of node.Emits the following event:event TextChanged(bytes32 indexed node, string indexedKey, string key);Multicallfunction multicall(bytes[] calldata data) external returns(bytes[] memory results)Permits users to set multiple records in a single operation.Use encodeABI function to encode your contract calls and pass it to data.The frontend usage will be as follows:var addrSet = resolver.contract.methods['setAddr(bytes32,address)'](node, accounts[1]).encodeABI();var textSet = resolver.contract.methods.setText(node, ""url"", ""https://ethereum.org/"").encodeABI();var tx = await resolver.multicall([addrSet, textSet], {from: accounts[0]});Contract API Reference - PreviousTestRegistrarNext - Contract API Reference.eth Permanent RegistrarLast modified 1yr agoCopy linkEdit on GitHubOn this pageCheck Interface SupportGet Ethereum AddressSet Ethereum AddressGet Blockchain AddressSet Blockchain AddressGet Canonical NameSet Canonical NameGet Content HashSet Content HashGet Contract ABISet Contract ABIGet Public KeySet Public KeyGet Text DataSet Text DataMulticall "
1,mains terminology,"mains terminology.   Terminology - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookTerminologyController: The account that may edit the records of a name. The Controller may be changed by the Registrant or Controller.Label: An individual component of a name, such as 'alice'.Labelhash: The keccak256 hash of an individual label.Name: An ENS identifier such as 'alice.eth'. Names may consist of multiple parts, called labels, separated by dots.Namehash: The algorithm used to process an ENS name and return a cryptographic hash uniquely identifying that name. Namehash takes a name as input and produces a node.Node: A cryptographic hash uniquely identifying a name.Owner: The owner of a name is the entity referenced in the ENS registry's owner field. An owner may transfer ownership, set a resolver or TTL, and create or reassign subdomains.Registrar: A registrar is a contract responsible for allocating subdomains. Registrars can be configured at any level of ENS, and are pointed to by the owner field of the registry.Registration: A registration is a registrar's record of a user's ownership of a name. This is distinct from the owner field in the Registry; registrations are maintained in the registrar contract and additionally store information on expiry date, fees paid, etc.Registrant: The owner of a registration. The registrant may transfer the registration, set the Controller, and reclaim ownership of the name in the registry if required.Registry: The core contract of ENS, the registry maintains a mapping from domain name (at any level - x, y.x, z.y.x etc) to owner, resolver, and time-to-live.Resolver: A resolver is a contract that maps from name to the resource (e.g., cryptocurrency addresses, content hash, etc). Resolvers are pointed to by the resolver field of the registry.PreviousIntroductionNextFrequently Asked QuestionsLast modified 1yr agoCopy linkEdit on GitHub "
2,mains contract api reference subgraphdata entities#newresolver,"mains contract api reference subgraphdata entities#newresolver.   Entities - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookEntitiesEntities​Domain​​DomainEvent​​Transfer​​NewOwner​​NewResolver​​NewTTL​​Account​​Registration​​RegistrationEvent​​NameRegistered​​NameRenewed​​NameTransferred​​Resolver​​ResolverEvent​​AddrChanged​​MulticoinAddrChanged​​NameChanged​​AbiChanged​​PubKeyChanged​​TextChanged​​ContentHashChanged​​InterfaceChanged​​AuthorisationChanged​DomainDescription:FieldTypeDescriptionidID!The namehash of the namenameStringThe human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)labelNameStringThe human readable label name (imported from CSV), if knownlabelhashByteskeccak256(labelName)parentDomainThe namehash (id) of the parent namesubdomains​Domain!​Can count domains from length of arraysubdomainCountInt!The number of subdomainsresolvedAddressaccountAddress logged from current resolver, if anyownerAccount!​resolverResolver​ttlBigInt​isMigratedBoolean!​createdAtBigInt!​events​DomainEvent!​​TransferDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​NewOwnerDescription:FieldTypeDescriptionidID!​parentDomainDomain!​domainDomain!​TransactionIDBytes!​ownerAccount!​NewResolverDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​resolverResolver!​NewTTLDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​transactionIDBytes!​ttlBigInt!​AccountDescription:FieldTypeDescriptionidID!​domain​Domain!​​registration​Registration!​​RegistrationDescription:FieldTypeDescriptionidID!​domainDomain​registrationDateBigInt!​expiryDateBigInt!​costBigInt!​registrantAccount!​labelNameString​events​RegistrationEven!​​RegistrationEventDescription:FieldTypeDescriptionidID!​registrationRegistrationEvent​blockNumberInt!​transactionIDBytes!​NameRegisteredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​registrantAccount!​expiryDateBigInt!​NameRenewedDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​expiryDateBigInt!​NameTransferredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​newOwnerAccount!​ResolverDescription:FieldTypeDescriptionidID!Concatenation of resolver address and namehashdomainDomain​addressBytes!Address of resolver contractaddrAccountCurrent value of addr record (per events)contenHashBytesContent hash, in binary formattexts[String!]Set of observed text record keyscointTypes[BigInt!]Set of observed SLIP-44 coin typesevents​ResolverEvent!​​ResolverEventDescription:FieldTypeDescriptionidID!Concatenation of block number and log IDresolverResolver!Used to derive relationships to ResolversblockNumberInt!​transactionIDBytes!​AddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​addrAccount!​MulticoinAddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​coinTypeBigInt!​addrBytes!​NameChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​nameString!​AbiChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​contentTypeBigInt!​PubkeyChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​xBytes!​yBytes!​TextChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​keyString!​valueString​ContenthashChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​hashBytes!​InterfaceChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​interfacedIDBytes!​implementerBytes!​AuthorisationChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​ownerBytes!​targetBytes!​isAuthorizedBoolean!​Contract API Reference - PreviousSubgraphNextQuery ExamplesLast modified 6mo agoCopy linkEdit on GitHubOn this pageEntitiesDomainTransferNewOwnerNewResolverNewTTLAccountRegistrationRegistrationEventNameRegisteredNameRenewedNameTransferredResolverResolverEventAddrChangedMulticoinAddrChangedNameChangedAbiChangedPubkeyChangedTextChangedContenthashChangedInterfaceChangedAuthorisationChanged "
3,mains v governance process#types of proposal,"mains v governance process#types of proposal.   Governance Process - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessModerator ChecklistsENS DAO ConstitutionThe ENS FoundationGovernance ProposalsPowered By GitBookGovernance ProcessAn overview of the ENS DAO's governance processes, and how you can get involved.This document is a suggested process for developing and advancing ENS Governance Proposals. It is a living document intended to be owned, modified and enforced by the ENS community.Venues​discuss.ens.domains is a Discourse forum for governance-related discussion. Community members must register for an account before sharing or liking posts. Registering for the forum allows community members to post in the general forum; for access to the working groups, fill out the participant request form.There are four workstream categories: Meta-Governance, Community, ENS Ecosystem, and Public Goods. Each category has subcategories for each of the steps of the governance process described below.Snapshot​Snapshot is a simple voting interface that allows users to signal sentiment off-chain. Votes on snapshot are weighted by the number of ENS delegated to the address used to vote.Governance portals​Tally is a governance portal that allows token holders to delegate their votes, and allows delegates to create and vote on binding proposals.There are also other governance interfaces that users can use to cast their votes:​Sybil​*Note: this is not a complete list, and should be updated by the community frequently.Getting Work DoneYou are probably here because you want the DAO to do something. The primary mechanism by which the DAO gets things done is via ""Requests for Proposal"" (RFPs). An RFP is a request from the DAO for contributors to offer to do work on its behalf, and receive compensation in return.Anyone who identifies a need can write an RFP, and if the RFP is passed, anyone can write a proposal in response and be awarded the work. Even if you believe you can do the work yourself, you will still need to pass an RFP in order to be awarded the work (and corresponding compensation) by the DAO.RFPs vary in detail and complexity. An RFP for improving the DAO's documentation may only be a paragraph or two long, and proposals for it will be equally short. At the other extreme, an RFP for managing the DAO's funds may be lengthy, and a successful proposal could be multiple pages justifying the proposer's ability to take on the job.The RFP ProcessRFPs all follow this process:1.Write a draft RFP (template here) and post it as a discussion thread in the appropriate working group on the DAO forum. At a minimum, RFPs must:a. Explain the need for the RFP and describe the work to be done - the scope of work and deliverables.b. Specify the requirements for a winning bid - criteria for selection.c. Provide a timeline for submissions and completion of the work.d. Nominate a party who will select a winning bid and approve & disburse compensation (the RFP manager). Normally this will be the working group who adopts the RFP.e. Specify a maximum budget for the RFP.2.Incorporate feedback from DAO participants into your draft. When you believe it is ready, tag the stewards of the working group and request they consider adopting it.3.If the stewards agree to adopt your RFP, they will decide if it can be paid out of WG funds, or if it needs a DAO wide vote.a. If the RFP can be paid out of WG funds, they will set a submission period and post it as an active RFP.b. Otherwise, the stewards will create an executable proposal (or, they may ask you to do this) asking the DAO as a whole to approve the RFP. The proposal should contain the RFP. The executable component should specify approvals from the DAO funds to the RFP manager in the amount of the maximum budget for the proposal.4.Once the RFP is approved - either by the WG or by a DAO-wide vote - the submission period begins. You or a WG steward should create a post on the DAO forum for proposals, and anyone can submit a proposal to this thread.5.Once the submission period is concluded, the RFP manager selects a winning bid. Normally the manager will be the stewards of the working group who has adopted your RFP.6.The author of the winning proposal commences the work. As they meet milestones specified in the RFP and their proposal, they can request compensation from the RFP manager, who disburses it from the allocated funds.Passing a ProposalTypes of ProposalThere are three main types of governance proposals you can make:1.​Executable Proposal: This is a proposal for a series of smart contract operations to be executed by accounts the DAO controls. These can include transfers of tokens as well as arbitrary smart contract calls. Examples of this include allocating funding to a workstream multisig wallet, or upgrading an ENS core contract. Executable proposals have a quorum requirement of 1% and require a minimum approval of 50% to pass.2.​Social Proposal: This is a proposal that asks for the agreement of the DAO on something that cannot be enforced onchain. Examples of this include a proposal to change the royalty percentage for the ENS secondary market on OpenSea, or a petition to the root keyholders. Social proposals have a quorum requirement of 1% and require a minimum approval of 50% to pass.3.​Constitutional Amendment: This is a social proposal that asks the DAO to amend the constitution. Your draft proposal should include a diff showing the exact changes you propose to make to the constitution. Rules for amending the constitution are set in the constitution itself, and currently require a quorum of 1% and a minimum approval of two thirds to pass.Phase 1: Temperature Check — DiscourseThe purpose of the Temperature Check is to determine if there is sufficient will to make changes to the status quo.To create a Temperature Check, ask a general, non-biased question to the community on discuss.ens.domains about a potential change (example: “Should ENS decrease registration costs for 3-letter domains?”). Forum posts should be in the ""DAO-wide -> Temperature Check"" category.Temperature checks are informal and optional; it's up to you to use the feedback to decide if you want to proceed further with your proposal.Phase 2: Draft Proposal — GitHubThe purpose of the Draft Proposal is to establish formal discussion around a potential proposal.To create a Draft Proposal, create a new governance proposal in the governance-docs repository on GitHub. Start by copying the template for an executable proposal, social proposal, or constitutional amendment, as appropriate. Once you have written your proposal, create a Draft Pull Request for it. Start a new post in the DAO-wide -> Draft Proposals"" category with a link to the PR for discussion.Reach out to your network to build support for the proposal. Discuss the proposal and solicit delegates to provide feedback on it. Be willing to respond to questions on the Draft Proposal topic and in comments on the pull request. Share your viewpoint, although try to remain as impartial as possible.If your proposal is an executable proposal, you will need to specify the actions your proposal will take while it is in draft stage. You may wish to wait until the proposal is stable before doing this. The executable proposal template explains how to do this.If your proposal is a constitutional amendment, you will need to produce a diff showing the exact changes you are proposing to make. The easiest way to do this is to go to the constitution, click ""Edit on GitHub"", then click the pencil icon to edit the document in a fork. You can then create a pull request via the GitHub UI and include this in your proposal. You should do this in a separate branch to your draft proposal; while the proposal will be merged as soon as it goes to a vote, the amendment will only be merged if the proposal passes.Once you are confident the proposal is in a stable state, you can proceed to phase 3.Phase 3: Active Proposal — Snapshot / Governance PortalUse GitHub to flag your PR as Ready for Review. A contributor will:1.Merge your PR if it meets the requirements.2.Assign your proposal a proposal number in the form EP###.3.Schedule the proposal for a snapshot vote.If your proposal is a Social Proposal or a Constitutional Amendment, that's it! If the snapshot vote passes, the proposal is passed and you are done.If your proposal is an Executable Proposal, you will now need to submit it to the governor contract for voting onchain.To enact an Executable Proposal:1.Ensure at least 100k ENS is delegated to your address in order to submit a proposal, or find a delegate who has enough delegated ENS to meet the proposal threshold to propose on your behalf.2.Call the propose() function of the ENS governor (at governor.ensdao.eth) to deploy your proposal.Once the propose() function has been called, a seven day voting period is started. Ongoing discussion can take place on your proposal post. If the proposal passes successfully, a two day timelock will follow before the proposed code is executed.Governance GlossaryENS: An ERC-20 token that designates the weight of a user’s voting rights. The more ENS a user has in their wallet, the more weight their delegation or vote on a proposal holds.Delegation: ENS holders cannot vote or create proposals until they delegate their voting rights to an address. Delegation can be given to one address at a time, including the holder’s own address. Note that delegation does not lock tokens; it simply adds votes to the chosen delegation address.Executable Proposal: An executable proposal is a type of proposal that is executed by the governance contract through timelock. It can replace the governance contract, transfer tokens from the community treasury, or perform an almost infinite range of other on-chain actions. In order to create a proposal, an address must have at least 0.1% (100k ENS) of all ENS delegated to their address. Proposals are stored in the “proposals” mapping of the Governor smart contract. All proposals are subject to a 7-day voting period.Quorum: In order for a vote to pass, a certain percentage of ENS tokens must vote in the affirmative. The current quorum requirements are:Executable Proposals: 1%Social Proposals: 1%Constitutional Amendments: 1%The purpose of this quorum is to ensure that the only measures that pass have adequate voter participation.Voting on Executable Proposals: Users can vote for or against single proposals once they have voting rights delegated to their address. Votes can be cast while a proposal is in the “Active” state. Votes can be submitted immediately using “castVote” or submitted later with “castVoteBySig” (For more info on castVoteBySig and offline signatures, see EIP-712). If the majority of votes (and a 1% quorum of ENS) vote for a proposal, the proposal may be queued in the Timelock.Voting Period: Proposals on Snapshot have a 5 day voting period. Once an executable proposal has been put forward, ENS community members will have a seven day period (the Voting Period) to cast their votes.Timelock: All governance actions are delayed for a minimum of 2 days by the timelock contract before they can be executed.PreviousWelcome to ENS DAONextModerator ChecklistsLast modified 10mo agoCopy linkEdit on GitHubOn this pageVenuesSnapshotGovernance portalsGetting Work DoneThe RFP ProcessPassing a ProposalTypes of ProposalPhase 1: Temperature Check — DiscoursePhase 2: Draft Proposal — GitHubPhase 3: Active Proposal — Snapshot / Governance PortalGovernance Glossary "
4,mains v governance governance proposals term 1 ep11 executable end airdrop,"mains v governance governance proposals term 1 ep11 executable end airdrop.   [EP1.7] [Executable] End the $ENS and EP2 airdrops - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1[EP1.1] [Executable] Set the temporary premium start price to $100,000[EP1.2.1] [Social] Removal of Brantly Millegan as Director of the ENS Foundation[EP1.2.2] [Social] Election of a new Director of The ENS Foundation[EP1.3.1] [Executable] Q1 & Q2 2022 Meta-Governance WG Budget[EP1.3.2] [Executable] Q1 & Q2 2022 ENS Ecosystem WG Budget[EP1.3.3] [Executable] Q1 & Q2 2022 Community WG Budget[EP1.3.4] [Executable] Q1 & Q2 2022 Public Goods WG Budget[EP1.4] [Executable] Reimburse True Names for expenses and tax obligations incurred for the DAO[EP1.5][Executable] Change to Exponential Premium Price Oracle[EP1.6] [Executable] A DAO-Governed Identity Server[EP1.7] [Executable] End the $ENS and EP2 airdrops[EP1.8] [Social] Working Group Rules[EP1.9] [Executable] Fund the Protocol Guild pilot with 200,000 $ENSTerm 2Term 3Powered By GitBook[EP1.7] [Executable] End the $ENS and EP2 airdropsEns the $ENS airdrop and EP2 airdrop by transferring tokens and revoking approvals.StatusExecutedDiscussion Thread​Discuss​Votes​Snapshot, passed​Onchain, passed Note: This was previously numbered EP11.AbstractThe $ENS airdrop can be terminated at any time on or after May 4, 2022 by a call from the DAO, transferring remaining tokens to an address it specifies. The EP2 airdrop can be terminated at any time by revoking the token approval given to it by the DAO. This EP proposes to execute both of these actions on or shortly after May 4, 2022.SpecificationCall 'sweep' on the ENS token contract, specifying the DAO wallet as target address.Call 'approve' on the ENS token contract, specifying the EP2 airdrop contract and an allowance of 0.TransactionsAddressValueFunctionArgumentValue0xC18360217D8F7Ab5e7c516566761Ea12Ce7F9D720sweepdest0xFe89cc7aBB2C4183683ab71653C4cdc9B02D44b70xC18360217D8F7Ab5e7c516566761Ea12Ce7F9D720approvespender0x4A1241C2Cf2fD4a39918BCd738f90Bd7094eC2DCamount0​​​Previous[EP1.6] [Executable] A DAO-Governed Identity ServerNext[EP1.8] [Social] Working Group RulesLast modified 1mo agoCopy linkEdit on GitHubOn this pageAbstractSpecificationTransactions "
5,mains v governance governance proposals term 1 ep7.3 executable q1 and q2 2022 community wg budget,"mains v governance governance proposals term 1 ep7.3 executable q1 and q2 2022 community wg budget.   [EP1.3.3] [Executable] Q1 & Q2 2022 Community WG Budget - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1[EP1.1] [Executable] Set the temporary premium start price to $100,000[EP1.2.1] [Social] Removal of Brantly Millegan as Director of the ENS Foundation[EP1.2.2] [Social] Election of a new Director of The ENS Foundation[EP1.3.1] [Executable] Q1 & Q2 2022 Meta-Governance WG Budget[EP1.3.2] [Executable] Q1 & Q2 2022 ENS Ecosystem WG Budget[EP1.3.3] [Executable] Q1 & Q2 2022 Community WG Budget[EP1.3.4] [Executable] Q1 & Q2 2022 Public Goods WG Budget[EP1.4] [Executable] Reimburse True Names for expenses and tax obligations incurred for the DAO[EP1.5][Executable] Change to Exponential Premium Price Oracle[EP1.6] [Executable] A DAO-Governed Identity Server[EP1.7] [Executable] End the $ENS and EP2 airdrops[EP1.8] [Social] Working Group Rules[EP1.9] [Executable] Fund the Protocol Guild pilot with 200,000 $ENSTerm 2Term 3Powered By GitBook[EP1.3.3] [Executable] Q1 & Q2 2022 Community WG BudgetStatusExecutedDiscussion Thread​Discourse​Votes​Snapshot, passed March 6th 2022 Onchain, passed March 29 2022Note: This was previously numbered EP7.3.Summary1.Community WG Operational Budget: 115,000 USDC/DAI, 1 ETH, and 650 ENS.2.Elected Steward Compensation: 27,500 in USDC/DAI.Total USD Value: ~$155,050.Community WG Budget: Q1 & Q2 Steward Term1. Operational BudgetThis funding is requested to fulfill the needs of the entire Q1/Q2 term.Subgroup NameDescriptionUSDC/DAIETH$ENSLearn DocsContent related to user documentation, tutorials, and case studies.11,00000CommunicationsProvide communications services for the DAO to include a bi-weekly digest, weekly twitter spaces, and other outreach services to drive education and engagement.10,0000100OnboardingFacilitate and coordinate weekly onboarding calls about ENS and the DAO. Also, focus on refining the DAO onboarding process.10,00000Discord Support ModerationProvides 24-hr support coverage in the ENS Discord.66,00000TranslationAdminister translation services for the ENS DAO official documents and website details.6,00000Communidad Para HispanohablantesIncrease onboarding for the native Spanish-speaking community.2,00000IRL OutreachCommunity engagement focused on in-person events.10,00000WG Discretionary FundsDiscretionary funding to be allocated to the above subgroups or facilitate the funding of new subgroups as the council of stewards deem necessary.01550Total115,0001650​Note: This includes subgroups and supports moderation of the ENS Discord. The Discord moderation is a necessary DAO expense carried by the community working group.2. Elected Steward CompensationProvide compensation for the three elected Community Stewards @limes , @spencecoin and @coltron.eth for the entire Q1/Q2 steward term.DescriptionCompensationMonths #Stewards #Total USDCBase Compensation$1,000/month5.5316,500Supplemental Compensation$2,000/month5.5-11,000Total​27,500​​Note: Supplemental compensation shall be distributed to stewards and contributors involved in running operations for the WG. The supplemental compensation will be used in situations where contributors or stewards perform duties beyond what is normally expected. The steward council determines how the supplemental compensation will be split between the stewards based on the contributions of each steward.ConsiderationsMultiple parties will approve all funding disbursements using a multi-sig. This budget does not guarantee disbursement, specifically if services rendered to the DAO are incomplete or deemed unsatisfactory. If these situations arise, the working group will review them publicly at the weekly Community Steward Call.Any funding not used will be re-allocated back to the treasury.Previous[EP1.3.2] [Executable] Q1 & Q2 2022 ENS Ecosystem WG BudgetNext[EP1.3.4] [Executable] Q1 & Q2 2022 Public Goods WG BudgetLast modified 6mo agoCopy linkEdit on GitHubOn this pageSummaryCommunity WG Budget: Q1 & Q2 Steward Term "
6,mains contract api reference .eth permanent registrar controller,"mains contract api reference .eth permanent registrar controller.   Controller - ENS Documentation    ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarRegistrarControllerDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookController​Source​This section documents the parts of the ETHRegistrarController relevant to implementers of tools that interact with it. Functionality exclusive to the registrar owner is omitted for brevity.The controller works exclusively with plaintext labels (eg, 'alice' for 'alice.eth').To prevent frontrunning, the ETHRegistrarController requires a commit/reveal process for new name registrations (but not for renewals). To register a name, the user must:1.Generate a commitment hash from the name they want to register and a secret value.2.Submit the commitment hash from #1 to the controller.3.Wait for at least 1 minute, but no longer than 24 hours.4.Submit a registration request for the name, along with the secret value from #1.This process ensures that registrations cannot be frontrun unless the attacker is able to censor the user's transactions for at least 1 minute.ExamplesName RegistrationThe below example demonstrates the steps required to register a name.web3.jsconst controller = web3.eth.contract(controller_abi).at(controller_address);async function register(name, owner, duration) { // Generate a random value to mask our commitment const random = new Uint8Array(32); crypto.getRandomValues(random); const salt = ""0x"" + Array.from(random).map(b => b.toString(16).padStart(2, ""0"")).join(""""); // Submit our commitment to the smart contract const commitment = await controller.makeCommitment(name, owner, salt); const tx = await controller.commit(commitment); // Add 10% to account for price fluctuation; the difference is refunded. const price = (await controller.rentPrice(name, duration)) * 1.1; // Wait 60 seconds before registering setTimeout(async () => { // Submit our registration request await controller.register(name, owner, duration, salt, {value: price}); }, 60000);}For clarity, this example is written using async rather than callbacks. As a result, this example works in web3 1.0.x; note that it will not work in the web3 injected by MetaMask, as this presently is an older version lacking async support.Read OperationsGet Minimum Commitment Ageuint constant public MIN_COMMITMENT_AGE;This public constant provides the minimum commitment age, in seconds. A commitment can only be revealed after at least this many seconds have passed since it was mined.DApps should fetch this constant rather than hardcoding the current value, as it's possible it will change with future releases.Get Maximum Commitment Ageuint constant public MAX_COMMITMENT_AGE;This public constant provides the maximum commitment age, in seconds. A commitment that was mined more than this number of seconds ago is no longer valid, and cannot be used to register a name.DApps should fetch this constant rather than hardcoding the current value, as it's possible it will change with future releases.Get Minimum Registration Durationuint constant public MIN_REGISTRATION_DURATION;This public constant provides the minimum registration duration, in seconds. Registrations for less than this duration will be rejected.DApps should fetch this constant rather than hardcoding the current value, as it's possible it will change with future releases.Get Commitment Timestampmapping(bytes32=>uint) public commitments;commitments stores a mapping from each submitted to commitment to the timestamp at which it was made. Callers wishing to validate that a commitment is valid before submitting a registration transaction should check this map first.Get Rent Pricefunction rentPrice(string name, uint duration) view public returns(uint);rentPrice returns the cost, in wei, to register or renew the provided name for the provided duration, in seconds. Callers should note that this price may vary over time, particularly if the pricing oracle is relying on a fiat price conversion.Callers should use this function to obtain registration costs to display to the user rather than calculating them internally, as future changes to the pricing oracle may result in different pricing schemes, with registration cost-per-year depending on name length, registration duration, or other variables.Check Name Validityfunction valid(string name) public view returns(bool);valid returns true iff name is valid for registration with this controller (eg, it meets length requirements).Check Name Availabilityfunction available(string name) public view returns(bool);available returns true iff the name is both valid and available for registration by this controller. Under the hood, this call uses the valid function (above) and the available function on the registrar contract, which checks for availability in both the legacy ENS registrar and current ENS registrar.Callers should use this function to check if a name is available for registration, rather than the available function on the registrar contract, which does not check name length.Calculate Commitment Hashfunction makeCommitment(string name, address owner, bytes32 secret) pure public returns(bytes32);makeCommitment generates and returns a commitment hash from a name label (eg, 'myname', not 'myname.eth') owner, and secret value.Write OperationsSubmit Commitmentfunction commit(bytes32 commitment) public;commit submits a precommitment generated by calling makeCommitment.Register Namefunction register(string name, address owner, uint duration, bytes32 secret) public payable;register registers a name. A valid registration request must meet the following criteria:1.available(name) == true.2.duration >= MIN_REGISTRATION_DURATION.3.secret identifies a valid commitment (eg, commitments[makeCommitment(name, secret)] exists and is between 1 minute and 24 hours old.4.msg.value >= rentPrice(name, duration).Because the rent price may vary over time, callers are recommended to send slightly more than the value returned by rentPrice - a premium of 5-10% will likely be sufficient. Any excess funds are returned to the caller.Emits the following event on a successful call:event NameRegistered(string name, bytes32 indexed label, address indexed owner, uint cost, uint expires);A successful call also results in the Registrar emitting a Name Registered Event, and the ENS registry emitting a New Owner Event.Extend Name Registrationfunction renew(string name, uint duration) external payable;renew renews a name, extending the name's expiration by duration seconds. This function can be called by anyone, as long as sufficient funds are provided. Because the rent price may vary over time, callers are recommended to send slightly more than the value returned by rentPrice - a premium of 5-10% will likely be sufficient. Any excess funds are returned to the caller.Emits the following event on a successful call:event NameRenewed(string name, bytes32 indexed label, uint cost, uint expires);A successful call also results in the Registrar emitting a Name Renewed Event.PreviousRegistrarNext - Contract API ReferenceDNS RegistrarLast modified 1yr agoCopy linkEdit on GitHubOn this pageExamplesName RegistrationRead OperationsGet Minimum Commitment AgeGet Maximum Commitment AgeGet Minimum Registration DurationGet Commitment TimestampGet Rent PriceCheck Name ValidityCheck Name AvailabilityCalculate Commitment HashWrite OperationsSubmit CommitmentRegister NameExtend Name Registration "
7,mains contract api reference subgraphdata entities#domainevent,"mains contract api reference subgraphdata entities#domainevent.   Entities - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookEntitiesEntities​Domain​​DomainEvent​​Transfer​​NewOwner​​NewResolver​​NewTTL​​Account​​Registration​​RegistrationEvent​​NameRegistered​​NameRenewed​​NameTransferred​​Resolver​​ResolverEvent​​AddrChanged​​MulticoinAddrChanged​​NameChanged​​AbiChanged​​PubKeyChanged​​TextChanged​​ContentHashChanged​​InterfaceChanged​​AuthorisationChanged​DomainDescription:FieldTypeDescriptionidID!The namehash of the namenameStringThe human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)labelNameStringThe human readable label name (imported from CSV), if knownlabelhashByteskeccak256(labelName)parentDomainThe namehash (id) of the parent namesubdomains​Domain!​Can count domains from length of arraysubdomainCountInt!The number of subdomainsresolvedAddressaccountAddress logged from current resolver, if anyownerAccount!​resolverResolver​ttlBigInt​isMigratedBoolean!​createdAtBigInt!​events​DomainEvent!​​TransferDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​NewOwnerDescription:FieldTypeDescriptionidID!​parentDomainDomain!​domainDomain!​TransactionIDBytes!​ownerAccount!​NewResolverDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​resolverResolver!​NewTTLDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​transactionIDBytes!​ttlBigInt!​AccountDescription:FieldTypeDescriptionidID!​domain​Domain!​​registration​Registration!​​RegistrationDescription:FieldTypeDescriptionidID!​domainDomain​registrationDateBigInt!​expiryDateBigInt!​costBigInt!​registrantAccount!​labelNameString​events​RegistrationEven!​​RegistrationEventDescription:FieldTypeDescriptionidID!​registrationRegistrationEvent​blockNumberInt!​transactionIDBytes!​NameRegisteredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​registrantAccount!​expiryDateBigInt!​NameRenewedDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​expiryDateBigInt!​NameTransferredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​newOwnerAccount!​ResolverDescription:FieldTypeDescriptionidID!Concatenation of resolver address and namehashdomainDomain​addressBytes!Address of resolver contractaddrAccountCurrent value of addr record (per events)contenHashBytesContent hash, in binary formattexts[String!]Set of observed text record keyscointTypes[BigInt!]Set of observed SLIP-44 coin typesevents​ResolverEvent!​​ResolverEventDescription:FieldTypeDescriptionidID!Concatenation of block number and log IDresolverResolver!Used to derive relationships to ResolversblockNumberInt!​transactionIDBytes!​AddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​addrAccount!​MulticoinAddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​coinTypeBigInt!​addrBytes!​NameChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​nameString!​AbiChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​contentTypeBigInt!​PubkeyChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​xBytes!​yBytes!​TextChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​keyString!​valueString​ContenthashChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​hashBytes!​InterfaceChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​interfacedIDBytes!​implementerBytes!​AuthorisationChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​ownerBytes!​targetBytes!​isAuthorizedBoolean!​Contract API Reference - PreviousSubgraphNextQuery ExamplesLast modified 6mo agoCopy linkEdit on GitHubOn this pageEntitiesDomainTransferNewOwnerNewResolverNewTTLAccountRegistrationRegistrationEventNameRegisteredNameRenewedNameTransferredResolverResolverEventAddrChangedMulticoinAddrChangedNameChangedAbiChangedPubkeyChangedTextChangedContenthashChangedInterfaceChangedAuthorisationChanged "
8,mains cdn cgi l email protection#d4babdb7bf94b1baa7fab0bbb9b5bdbaa7,"mains cdn cgi l email protection#d4babdb7bf94b1baa7fab0bbb9b5bdbaa7.   Email Protection | Cloudflare    Please enable cookies. Email Protection You are unable to access this email address docs.ens.domains  The website from which you got to this page is protected by Cloudflare. Email addresses on that page have been hidden in order to keep them from being accessed by malicious bots. You must enable Javascript in your browser in order to decode the e-mail address. If you have a website and are interested in protecting it in a similar way, you can sign up for Cloudflare.  How does Cloudflare protect email addresses on website from spammers? Can I sign up for Cloudflare?   Cloudflare Ray ID: 7a4541c95a7c2a8b •  Your IP:  Click to reveal 72.197.148.96 • Performance & security by Cloudflare   "
9,mains contract api reference testregistrar,"mains contract api reference testregistrar.   TestRegistrar - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookTestRegistrar​Source​The Test registrar facilitates easy testing of ENS on the Ethereum test networks. Typically deployed on the .test TLD, it provides functionality to instantly claim a domain for test purposes, which expires 28 days after it was claimed.Register a Domainfunction register(bytes32 label, address owner) public;Registers the subdomain whose keccak256 hash is provided in label, and assigns ownership to owner. For example, to register myname.test, call register with keccak256('myname') as the first argument.Registrations after 28 days.Get expiration timemapping (bytes32 => uint) public expiryTimes;Returns the unix timestamp at which the specified subdomain will expire. For example, to check the expiration time of myname.test, call expiryTimes(keccak256('myname')).Contract API Reference - PreviousReverseRegistrarNext - Contract API ReferencePublicResolverLast modified 1yr agoCopy linkEdit on GitHubOn this pageRegister a DomainGet expiration time "
10,mains v governance governance proposals term 2 ep16.2 executable q3 and q4 2022 ens ecosystem wg budget,"mains v governance governance proposals term 2 ep16.2 executable q3 and q4 2022 ens ecosystem wg budget.   [EP2.2.2] [Executable] Q3 & Q4 2022 Ecosystem WG Budget - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1Term 2[EP2.1] [Executable] Funding True Names Ltd[EP2.2.1] [Executable] Q3 & Q4 2022 Meta-Governance WG Budget[EP2.2.2] [Executable] Q3 & Q4 2022 Ecosystem WG Budget[EP2.2.3] [Executable] Q3 & Q4 2022 Public Goods WG Budget[EP2.2.4] [Social] ENS Endaoment RFP[EP2.2.5] [Social] Selection of an ENS endowment fund managerTerm 3Powered By GitBook[EP2.2.2] [Executable] Q3 & Q4 2022 Ecosystem WG BudgetStatusExecutedDiscussion Thread​Discourse​Votes​Snapshot - Passed​Onchain - ExecutedNote: This was previously numbered EP16.2.SummaryThe Ecosystem Working Group is requesting funding of 2.3 million USD equivalent for the second term. The budget has four categories. All figures are presented in USD equivalent.request summary|562x428, 50%Multisigs / Subgroups: $1.5mFunding in this category is associated with a multisig wallet that has a clearly defined mandate. These multisigs been approved by current stewards of the ENS Ecosystem working group.Examples of subgroups receiving funding include bug bounty, support mods, dot-eth websites, .limo infrastructure, hackathons, and ENS ecosystem rounds during gitcoin grants rounds.Budget ​Description ​RFP Related: $435kFunding in this category relates to current and future proposals. Potential examples include on-chain normalization, ENS avatar, and future RFPs. Details on the RFP process can be found in this thread.image|690x55Grants: $262kFunding in this category supports retro-active grants not covered by predefined multi-sigs in the subgroups category. The majority of this funding is expected to be allocated to the prop-house.image|690x70Unallocated: $109kThe funds in this category are reserved for unexpected needs of the working group over the term. ​Previous[EP2.2.1] [Executable] Q3 & Q4 2022 Meta-Governance WG BudgetNext[EP2.2.3] [Executable] Q3 & Q4 2022 Public Goods WG BudgetLast modified 6mo agoCopy linkEdit on GitHubOn this pageSummaryMultisigs / Subgroups: $1.5mRFP Related: $435kGrants: $262kUnallocated: $109k "
11,mains contract api reference name processing#how do i find the labelhash namehash of a name,"mains contract api reference name processing#how do i find the labelhash namehash of a name.   Name Processing - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookName ProcessingDescribes how to normalize and hash ENS names.In place of human-readable names, ENS works purely with fixed length 256-bit cryptographic hashes. In order to derive the hash from a name while still preserving its hierarchal properties, a process called Namehash is used. For example, the namehash of 'alice.eth' is 0x787192fc5378cc32aa956ddfdedbf26b24e8d78e40109add0eea2c1a012c3dec; this is the representation of names that is used exclusively inside ENS.Before being hashed with namehash, names are first normalized, using a process called UTS-46 normalization. This ensures that upper- and lower-case names are treated equivalently, and that invalid characters are prohibited. Anything that hashes and resolves a name must first normalize it, to ensure that all users get a consistent view of ENS.Normalising NamesBefore a name can be converted to a node hash using Namehash, the name must first be normalized and checked for validity - for instance, converting fOO.eth into foo.eth, and prohibiting names containing forbidden characters such as underscores. It is crucial that all applications follow the same set of rules for normalization and validation, as otherwise two users entering the same name on different systems may resolve the same human-readable name into two different ENS names.Applications using ENS and processing human-readable names must follow UTS46 for normalization and validation. Processing should be done with non-transitional rules, and with UseSTD3ASCIIRules=true.The eth-ens-namehash Javascript library performs both normalization and hashing as described here. All of the ENS libraries covered in the DApp Developer Guide also perform normalization and hashing.Hashing NamesNamehash is a recursive process that can generate a unique hash for any valid domain name. Starting with the namehash of any domain - for example, 'alice.eth' - it's possible to derive the namehash of any subdomain - for example 'iam.alice.eth' - without having to know or handle the original human-readable name. It is this property that makes it possible for ENS to provide a hierarchal system, without having to deal with human-readable text strings internally.Terminologydomain - The complete, human-readable form of a name; eg, iam.alice.eth.label - A single component of a domain - eg, iam, alice, or eth.label hash - the output of the keccak-256 function applied to a label; eg, keccak256(‘eth’) = 0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0node - The output of the namehash function, used to uniquely identify a name in ENS.AlgorithmFirst, a domain is divided into labels by splitting on periods (‘.’). So, ‘vitalik.wallet.eth’ becomes the list [‘vitalik’, ‘wallet’, ‘eth’].The namehash function is then defined recursively as follows:namehash([]) = 0x0000000000000000000000000000000000000000000000000000000000000000namehash([label, …]) = keccak256(namehash(…), keccak256(label))A sample implementation in Python is provided below.def namehash(name): if name == '': return '\0' * 32 else: label, _, remainder = name.partition('.') return sha3(namehash(remainder) + sha3(label))Namehash is specified in EIP 137.How do I find the labelhash/namehash of a name?In some cases, you may need to know the hash of the name stored in ENS. labelhash means hash of the label of the domain (eg: makoto for makoto.eth) and namehash is the hash which combines labelhashes. We are currently working to include this information in our Manager app. In the meantime, you can query the information via https://thegraph.com/explorer/subgraph/ensdomains/ens with the following query.{ domains(where: {name:""vitalik.eth""}) { id name labelName labelhash }}Handling of Ambiguous NamesBecause of the large number of characters in unicode, and the wide variety of scripts represented, inevitably there are different Unicode characters that are similar or even identical when shown in common fonts. This can be abused to trick users into thinking they are visiting one site or resource, when in fact they are visiting another. This is known as a homoglyph attack.User agents and other software that display names to users should take countermeasures against these attacks, such as by highlighting problematic characters, or showing warnings to users about mixed scripts. Chromium’s IDNA strategy may serve as a useful reference for user-agent behaviour around rendering IDNA names.Dapp Developer Guide - PreviousENS Data guideNext - Contract API ReferenceRegistryLast modified 1yr agoCopy linkEdit on GitHubOn this pageNormalising NamesHashing NamesTerminologyAlgorithmHow do I find the labelhash/namehash of a name?Handling of Ambiguous Names "
12,mains v governance process moderator checklists,"mains v governance process moderator checklists.   Moderator Checklists - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessModerator ChecklistsENS DAO ConstitutionThe ENS FoundationGovernance ProposalsPowered By GitBookModerator ChecklistsProcess documentation and checklists for DAO moderators handling proposalsAdvancing a proposal to a voteWhen the author of a Draft Proposal asks for it to be advanced to a vote, and you agree, follow the below steps:Modify the title to include the next sequential EP number (eg [EP4] ...).Move from Draft Proposals to Active Proposals category.Delete Discourse poll (if any).​Create a Snapshot vote:5 day duration.Simple voting unless otherwise called for in the proposal.Copy and paste the title and contents of the proposal to the vote.Add a link to the forum thread at the bottom.Replicate the proposal in the governance docs:Create the header table with a link to the forum thread and snapshot vote.Copy and paste the title and contents of the proposal.Set the status to 'Active'.Submit as a PR for the docs.Edit the forum thread to link to the Snapshot vote at the top.Send a forum DM to the 'delegates' group announcing that the proposal is up for voting.Send a tweet announcing that the proposal is up for voting.Proposal pass/rejectionWhen a proposal's voting period concludes, follow the below steps:Update the proposal in the governance docs:For an Executable Proposal that just passed its Snapshot vote, set the status to 'Awaiting Execution'.Otherwise, set the status to 'Passed' if it passed and 'Rejected' if it did not.Update the forum thread:Remove the Snapshot/Tally link at the top.List the current status (as above) at the top of the proposal.If the proposal is Passed or Rejected, lock the thread.If the proposal is an Executable Proposal and passed its snapshot vote:Do the ""Executing a proposal"" checklist below if it is ready to be executed.Otherwise, add a note to the forum thread about when it will be scheduled for execution.If the proposal is a Constitutional Amendment:Merge the PR to the constitution if it passed.Close the PR otherwise.If the proposal requires any other action, alert those responsible of the need to enact it.Send a tweet announcing the result of the proposal.Executing a proposalWhen an Executable Proposal is ready to be executed, follow the below steps. If you do not have sufficient voting power to submit an executable proposal, ask someone else to do this for you.Construct the executable proposal on the interface of your choice, such as Tally or OZ Defender, following the instructions in the proposal.Have someone else double-check the proposal is structured correctly for you.Optionally, use Tenderly to simulate the effects of submitting the proposal directly to the timelock contract to check it has the expected effect.Submit the proposal to the chain.Add a link to the vote on Tally to the top of the proposal on the forum thread.Update the status of the proposal in the governance docs to 'Active'.Send a forum DM to the 'delegates' group announcing the proposal is up for execution, with a link to the Tally proposal page.Send a tweet announcing that the proposal is up for voting.PreviousGovernance ProcessNextENS DAO ConstitutionLast modified 1yr agoCopy linkEdit on GitHubOn this pageAdvancing a proposal to a voteProposal pass/rejectionExecuting a proposal "
13,mains v governance governance proposals term 1 ep7.4 executable q1 and q2 2022 public goods wg budget,"mains v governance governance proposals term 1 ep7.4 executable q1 and q2 2022 public goods wg budget.   [EP1.3.4] [Executable] Q1 & Q2 2022 Public Goods WG Budget - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1[EP1.1] [Executable] Set the temporary premium start price to $100,000[EP1.2.1] [Social] Removal of Brantly Millegan as Director of the ENS Foundation[EP1.2.2] [Social] Election of a new Director of The ENS Foundation[EP1.3.1] [Executable] Q1 & Q2 2022 Meta-Governance WG Budget[EP1.3.2] [Executable] Q1 & Q2 2022 ENS Ecosystem WG Budget[EP1.3.3] [Executable] Q1 & Q2 2022 Community WG Budget[EP1.3.4] [Executable] Q1 & Q2 2022 Public Goods WG Budget[EP1.4] [Executable] Reimburse True Names for expenses and tax obligations incurred for the DAO[EP1.5][Executable] Change to Exponential Premium Price Oracle[EP1.6] [Executable] A DAO-Governed Identity Server[EP1.7] [Executable] End the $ENS and EP2 airdrops[EP1.8] [Social] Working Group Rules[EP1.9] [Executable] Fund the Protocol Guild pilot with 200,000 $ENSTerm 2Term 3Powered By GitBook[EP1.3.4] [Executable] Q1 & Q2 2022 Public Goods WG BudgetStatusExecutedDiscussion Thread​Discourse​Votes​Snapshot, passed March 6th 2022 Onchain, passed March 29 2022Note: This was previously numbered EP7.4.SummaryThe Ecosystem WG is requesting funding to start the Q1/Q2 2022 term. The initial request is made up of three components:1.Elected steward compensation: $12,000 in cDAI2.Bounties for ENS Public Goods Request for Proposals program: $50,000 in cDAI3.Operational Budget $38,000 in cDAITotal for Q1 & Q2: $150,000.00 in cDAIThe group will be using the price of cDAI in uniswap to calculate the exact amounts requested. We are using cDAI as a accounting unit as a manner to provide a stable value that will still accrue value while not in utilization and resist dollar depreciation. The group can convert them in DAI when sending out payments and grants. The current price of cDAI orbits around 0.021-0.022 per dai and the total budget would be, in today’s value, about 6.85M cDAI.Elected steward compensationThe group has 5 elected stewards: Alex (avsa.eth), makoto.eth, sumedha.eth, Scott and Richard Moore (Ricmoo.eth). Two of these steward are appointed by True Names and will not be receiving compensation, and one of the other stewards has elected to forego compensation and therefore we will asking only for a total of 12k USD for the total Steward Compensation. Pay for past months will be sent immediately and the remaining will be streamed until june 30th.Bounties for ENS Public Goods Request for Proposals program:The bounties will be distributed in prizes of $1,000, $5,000, and $10,000 for projects that execute on basic implementation of goals elected by the stewards. These are set to be given directly to projects and not spent on operations. Any funds remaining at the end of the term will be either given back to the DAO or rolled in the Public Goods stewards budget for the next term.Operational BudgetThese will encompass tasks like reimbursements for expenses executed by stewards, payment for projects like a website, social media, or compensation for work done in partner integrations. All payments must be approved by at least 3 other stewards and will be executed in the most transparent manner the stewards can find.Previous[EP1.3.3] [Executable] Q1 & Q2 2022 Community WG BudgetNext[EP1.4] [Executable] Reimburse True Names for expenses and tax obligations incurred for the DAOLast modified 6mo agoCopy linkEdit on GitHub "
14,mains cdn cgi l email protection#fb95929890bb9e8f939e899e8e96d594899c,"mains cdn cgi l email protection#fb95929890bb9e8f939e899e8e96d594899c.   Email Protection | Cloudflare    Please enable cookies. Email Protection You are unable to access this email address docs.ens.domains  The website from which you got to this page is protected by Cloudflare. Email addresses on that page have been hidden in order to keep them from being accessed by malicious bots. You must enable Javascript in your browser in order to decode the e-mail address. If you have a website and are interested in protecting it in a similar way, you can sign up for Cloudflare.  How does Cloudflare protect email addresses on website from spammers? Can I sign up for Cloudflare?   Cloudflare Ray ID: 7a4541ff9dd42b5c •  Your IP:  Click to reveal 72.197.148.96 • Performance & security by Cloudflare   "
15,mains contract api reference subgraphdata entities#authorisationchanged,"mains contract api reference subgraphdata entities#authorisationchanged.   Entities - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookEntitiesEntities​Domain​​DomainEvent​​Transfer​​NewOwner​​NewResolver​​NewTTL​​Account​​Registration​​RegistrationEvent​​NameRegistered​​NameRenewed​​NameTransferred​​Resolver​​ResolverEvent​​AddrChanged​​MulticoinAddrChanged​​NameChanged​​AbiChanged​​PubKeyChanged​​TextChanged​​ContentHashChanged​​InterfaceChanged​​AuthorisationChanged​DomainDescription:FieldTypeDescriptionidID!The namehash of the namenameStringThe human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)labelNameStringThe human readable label name (imported from CSV), if knownlabelhashByteskeccak256(labelName)parentDomainThe namehash (id) of the parent namesubdomains​Domain!​Can count domains from length of arraysubdomainCountInt!The number of subdomainsresolvedAddressaccountAddress logged from current resolver, if anyownerAccount!​resolverResolver​ttlBigInt​isMigratedBoolean!​createdAtBigInt!​events​DomainEvent!​​TransferDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​NewOwnerDescription:FieldTypeDescriptionidID!​parentDomainDomain!​domainDomain!​TransactionIDBytes!​ownerAccount!​NewResolverDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​resolverResolver!​NewTTLDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​transactionIDBytes!​ttlBigInt!​AccountDescription:FieldTypeDescriptionidID!​domain​Domain!​​registration​Registration!​​RegistrationDescription:FieldTypeDescriptionidID!​domainDomain​registrationDateBigInt!​expiryDateBigInt!​costBigInt!​registrantAccount!​labelNameString​events​RegistrationEven!​​RegistrationEventDescription:FieldTypeDescriptionidID!​registrationRegistrationEvent​blockNumberInt!​transactionIDBytes!​NameRegisteredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​registrantAccount!​expiryDateBigInt!​NameRenewedDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​expiryDateBigInt!​NameTransferredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​newOwnerAccount!​ResolverDescription:FieldTypeDescriptionidID!Concatenation of resolver address and namehashdomainDomain​addressBytes!Address of resolver contractaddrAccountCurrent value of addr record (per events)contenHashBytesContent hash, in binary formattexts[String!]Set of observed text record keyscointTypes[BigInt!]Set of observed SLIP-44 coin typesevents​ResolverEvent!​​ResolverEventDescription:FieldTypeDescriptionidID!Concatenation of block number and log IDresolverResolver!Used to derive relationships to ResolversblockNumberInt!​transactionIDBytes!​AddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​addrAccount!​MulticoinAddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​coinTypeBigInt!​addrBytes!​NameChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​nameString!​AbiChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​contentTypeBigInt!​PubkeyChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​xBytes!​yBytes!​TextChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​keyString!​valueString​ContenthashChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​hashBytes!​InterfaceChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​interfacedIDBytes!​implementerBytes!​AuthorisationChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​ownerBytes!​targetBytes!​isAuthorizedBoolean!​Contract API Reference - PreviousSubgraphNextQuery ExamplesLast modified 6mo agoCopy linkEdit on GitHubOn this pageEntitiesDomainTransferNewOwnerNewResolverNewTTLAccountRegistrationRegistrationEventNameRegisteredNameRenewedNameTransferredResolverResolverEventAddrChangedMulticoinAddrChangedNameChangedAbiChangedPubkeyChangedTextChangedContenthashChangedInterfaceChangedAuthorisationChanged "
16,mains dapp developer guide ens enabling your dapp,"mains dapp developer guide ens enabling your dapp.   ENS Enabling your DApp - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookENS Enabling your DAppENS integration in an application encompasses several critical features, each of which can be implemented independently. While comprehensive ENS integration is ideal, even basic support can be a huge benefit to users. Below, we outline three levels of ENS integration. Level 1 is easily achieved and provides high impact for users, while levels 2 and 3 provide more functionality to your users, improving your dApp's usability and your users' experience interacting with your DApp.1. Resolving ENS namesThe first step to supporting ENS in your application is making your application understand ENS names, and accepting them anywhere an address is accepted. To understand how to do this, see Resolving Names.If possible, when a user enters an ENS name instead of an address, remember the ENS name, not the address it currently resolves to. This makes it possible for users to update their ENS names and have applications they used the name in automatically resolve to the new address, in the same way that you would expect your browser to automatically direct you to the new IP address if a site you use changes servers.If your application deals with user funds or other critical resources, you may want to keep track of the address a name resolves to and warn them when it changes, to ensure they are aware of the change.By accepting ENS names in your application, you remove the need for users to copy and paste - or worse, type out - long and opaque Ethereum addresses, which leads to errors and lost funds.2. Support Reverse ResolutionThe second level of ENS integration involves displaying ENS names wherever your app currently displays addresses.If a user entered an ENS in your DApp, you should retain this name and show it to them whenever you would normally show the address.If a user entered an address, or the address was obtained from elsewhere, you may still be able to show an ENS name, by doing Reverse Resolution. This permits you to find the canonical name for an address and display that when possible. If no canonical name is provided, your application can fall back to displaying the address as it did previously.By supporting reverse resolution, you make it easier for your users to identify accounts they interact with, associating them with a short human-readable name instead of a long opaque Ethereum address.3. Let Users Name ThingsThe final step for comprehensive ENS integration is to facilitate associating ENS names with resources created by or managed with your application. This can take two forms:Name RegistrationBy obtaining an ENS name for your product and allowing users to easily register subdomains, you can provide users with an easy way to name resources created in your DApp. For example, if your DApp is a cryptocurrency wallet, you can make it easy for users to obtain an ENS domain of the form theirname.yourwallet.eth, allowing them to give their name out to others more easily.To learn how to do this, see Writing a Registrar in the Smart Contract Developer Guide.Name UpdatesBy providing users with an easy way to update a name they own to point at your application’s resources, users can assign names they already own to your DApp's resources. See Managing Names to learn how to do this.Tell Us About Your IntegrationIf you've ENS Enabled your app, let us know by emailing [email protected]; we'll add your app to our homepage.PreviousENSIP-14: On-chain Source ParameterNext - Dapp Developer GuideENS LibrariesLast modified 1yr agoCopy linkEdit on GitHubOn this page1. Resolving ENS names2. Support Reverse Resolution3. Let Users Name ThingsName RegistrationName UpdatesTell Us About Your Integration "
17,mains contract api reference subgraphdata entities#newttl,"mains contract api reference subgraphdata entities#newttl.   Entities - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookEntitiesEntities​Domain​​DomainEvent​​Transfer​​NewOwner​​NewResolver​​NewTTL​​Account​​Registration​​RegistrationEvent​​NameRegistered​​NameRenewed​​NameTransferred​​Resolver​​ResolverEvent​​AddrChanged​​MulticoinAddrChanged​​NameChanged​​AbiChanged​​PubKeyChanged​​TextChanged​​ContentHashChanged​​InterfaceChanged​​AuthorisationChanged​DomainDescription:FieldTypeDescriptionidID!The namehash of the namenameStringThe human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)labelNameStringThe human readable label name (imported from CSV), if knownlabelhashByteskeccak256(labelName)parentDomainThe namehash (id) of the parent namesubdomains​Domain!​Can count domains from length of arraysubdomainCountInt!The number of subdomainsresolvedAddressaccountAddress logged from current resolver, if anyownerAccount!​resolverResolver​ttlBigInt​isMigratedBoolean!​createdAtBigInt!​events​DomainEvent!​​TransferDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​NewOwnerDescription:FieldTypeDescriptionidID!​parentDomainDomain!​domainDomain!​TransactionIDBytes!​ownerAccount!​NewResolverDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​resolverResolver!​NewTTLDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​transactionIDBytes!​ttlBigInt!​AccountDescription:FieldTypeDescriptionidID!​domain​Domain!​​registration​Registration!​​RegistrationDescription:FieldTypeDescriptionidID!​domainDomain​registrationDateBigInt!​expiryDateBigInt!​costBigInt!​registrantAccount!​labelNameString​events​RegistrationEven!​​RegistrationEventDescription:FieldTypeDescriptionidID!​registrationRegistrationEvent​blockNumberInt!​transactionIDBytes!​NameRegisteredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​registrantAccount!​expiryDateBigInt!​NameRenewedDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​expiryDateBigInt!​NameTransferredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​newOwnerAccount!​ResolverDescription:FieldTypeDescriptionidID!Concatenation of resolver address and namehashdomainDomain​addressBytes!Address of resolver contractaddrAccountCurrent value of addr record (per events)contenHashBytesContent hash, in binary formattexts[String!]Set of observed text record keyscointTypes[BigInt!]Set of observed SLIP-44 coin typesevents​ResolverEvent!​​ResolverEventDescription:FieldTypeDescriptionidID!Concatenation of block number and log IDresolverResolver!Used to derive relationships to ResolversblockNumberInt!​transactionIDBytes!​AddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​addrAccount!​MulticoinAddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​coinTypeBigInt!​addrBytes!​NameChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​nameString!​AbiChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​contentTypeBigInt!​PubkeyChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​xBytes!​yBytes!​TextChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​keyString!​valueString​ContenthashChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​hashBytes!​InterfaceChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​interfacedIDBytes!​implementerBytes!​AuthorisationChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​ownerBytes!​targetBytes!​isAuthorizedBoolean!​Contract API Reference - PreviousSubgraphNextQuery ExamplesLast modified 6mo agoCopy linkEdit on GitHubOn this pageEntitiesDomainTransferNewOwnerNewResolverNewTTLAccountRegistrationRegistrationEventNameRegisteredNameRenewedNameTransferredResolverResolverEventAddrChangedMulticoinAddrChangedNameChangedAbiChangedPubkeyChangedTextChangedContenthashChangedInterfaceChangedAuthorisationChanged "
18,mains dns registrar guide,"mains dns registrar guide.   DNS Registrar guide - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookDNS Registrar guideIntroductionDNSSEC (The Domain Name System Security Extensions) establishes a chain of trust from the root key which is signed by ICANN (.) and down through each key. Given DNSSEC is enabled and an ETH address is put into the subdomain of the domain you own (eg: _ens.yourdomain.tld), ENS manager allows anyone to submit the hash of the chain to DNSSEC Oracle smart contractStepsStep 1 Setting up DNSSEC signingWhen you first land on ENS manager, you will see something like below.step1: dnnsec not enabledIf your DNS provider already supports DNSSEC-signed domains, all you do is enable the option on the DNS manager.If they don’t, you’ll need to migrate to someone who does. We recommend either EasyDNS or Google Cloud DNS. EasyDNS’s setup guide for DNSSEC is here, while Google’s is here.Whatever provider you need, make sure you select RSA signatures and SHA256 hashing.sha|690x468Step 2: Adding a TXT recordThe DNS Registrar on ENS looks for a TXT record with a specific name and format in order to verify what Ethereum address should be given ownership of the domain. To claim ownership of mydomain.xyz, create a TXT record in your DNS zone, _ens.mydomain.xyz, with text data of the form a=0x1234..., where 0x1234... is the Ethereum address you want to give control of the ENS record to.step2: add textStep 3: Registering the name into ENSOnce you get to this stage, you can complete the rest from ENS manager. Simply press ""Register"" and send the transaction.step3: owner submit proofStep 4: Go to the managerstep4: ownerFAQCan I register any DNS domains through ENS app?Technically speaking, over 90% of domains can be supported. Some TLDs (.ceo, .art, .club, .luxe and .kred) are operated by each DNS registry.If I own myname.xyz DNS name, can I claim for myname.eth ?You may be confused with short name reservation process. Under DNSSEC integration, you can only claim for the correspondent ENS name with the same top level domain (TLD). .eth is managed completely separately.Once I register the domain, how can I transfer or delete ownership?Unlike .eth permanent registrar, there is no notion of registrant which can transfer the ownership of the controller. If you want to transfer the ownership to any address other than the currently registered address, please update the corresponding DNS record from your DNS manager and click ""Transfer"" from our ENS manager.We currently haven't enabled the ability to delete the ownership. Having said that, you can achieve the same effect if you set the owner record to a= 0x0000000000000000000000000000000000000000 then click ""Transfer"" from the ENS manager.Can I register my DNS subdomain?No. DNSSEC registration is only enabled for the second level domain (eg: yourname.xyz). If you want to create subdomain.yourname.xyz, then click ""Subdomains"" tab of our manager and create it from ENS manager just like other subdomains under .eth.PreviousDeploying ENS on a Private ChainNextBug Bounty ProgramLast modified 10mo agoCopy linkEdit on GitHubOn this pageIntroductionStepsStep 1 Setting up DNSSEC signingStep 2: Adding a TXT recordStep 3: Registering the name into ENSStep 4: Go to the managerFAQCan I register any DNS domains through ENS app?If I own myname.xyz DNS name, can I claim for myname.eth ?Once I register the domain, how can I transfer or delete ownership?Can I register my DNS subdomain? "
19,mains contract api reference publicresolver#multicall,"mains contract api reference publicresolver#multicall.   PublicResolver - ENS Documentation    ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookPublicResolverThe default public resolver.​Source​PublicResolver implements a general-purpose ENS resolver that is suitable for most standard ENS use-cases. The public resolver permits updates to ENS records by the owner of the corresponding name.The public resolver implements the following EIPs:​EIP 137 - Contract address interface (addr()).​EIP 165 - Interface Detection (supportsInterface()).​EIP 181 - Reverse resolution (name()).​EIP 205 - ABI support (ABI()).​EIP 619 - SECP256k1 public keys (pubkey()).​EIP 634 - Text records (text()).​EIP 1577 - Content hash support (contenthash()).​EIP 2304 - Multicoin support (addr()).While the PublicResolverprovides a convenient default implementation, many resolver implementations and versions exist. Callers must not assume that a domain uses the current version of the public resolver, or that all of the methods described here are present. To check if a resolver supports a feature, see Check Interface Support.Check Interface Supportfunction supportsInterface(bytes4 interfaceID) external pure returns (bool)ENS uses ERC 165 for interface detection. ERC 165 requires that supporting contracts implement a function, supportsInterface, which takes an interface ID and returns a boolean value indicating if this interface is supported or not.Interface IDs are calculated as the exclusive-or of the four-byte function identifiers of each function included in the interface. For example, addr(bytes32) has the function ID 0x3b3b57de. Because it is the only function in the Ethereum Address interface, its interface ID is also 0x3b3b57de, and so calling supportsInterface(0x3b3b57de) will return true for any resolver that supports addr().ERC 165 has an interface ID of 0x01ffc9a7, so supportsInterface(0x01ffc9a7) will always return true for any ERC 165 supporting contract (and hence for any resolver).Note that the public resolver does not expose explicit interfaces for setter functions, so there are no automated means to check for support for a given setter function.Get Ethereum Addressfunction addr(bytes32 node) external view returns (address)Returns the Ethereum address associated with the provided node, or 0 if none.This function has interface ID 0x3b3b57de.This function is specified in EIP 137.Set Ethereum Addressfunction setAddr(bytes32 node, address addr) external;Sets the Ethereum address associated with the provided node to addr.Only callable by the owner of node.Emits the following event:event AddrChanged(bytes32 indexed node, address a);Get Blockchain Addressfunction addr(bytes32 node, uint coinType) external view returns(bytes memory);Returns the Blockchain address associated with the provided node and coinType, or 0 if none.This function has interface ID 0xf1cb7e06.This function is specified in EIP 2304.The return value is the cryptocurrency address in its native binary format and each blockchain address has a different encoding and decoding method.For example, the Bitcoin address 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa base58check decodes to the 21 bytes 0062e907b15cbf27d5425399ebf6f0fb50ebb88f18 then scriptPubkey encodes to 25 bytes 76a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1888ac whereas the BNB address bnb1grpf0955h0ykzq3ar5nmum7y6gdfl6lxfn46h2 Bech32 decodes to the binary representation 40c2979694bbc961023d1d27be6fc4d21a9febe6.To convert the binary representation into the address, use formatsByCoinType[SYMBOL].encoder(binary) of address-encoder.A zero-length string will be returned if the specified coin ID does not exist on the specified node.Set Blockchain Addressfunction setAddr(bytes32 node, uint coinType, bytes calldata a) external;Sets the blockchain address associated with the provided node and coinType to addr.coinType is the cryptocurrency coin type index from SLIP44.To convert the address into the binary representation, use formatsByName[SYMBOL].decoder(text) of address-encoder​Only callable by the owner of node.Emits the following event:event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);Get Canonical Namefunction name(bytes32 node) external view returns (string memory);Returns the canonical ENS name associated with the provided node. Used exclusively for reverse resolution.This function has interface ID 0x691f3431.This function is specified in EIP 181.Set Canonical Namefunction setName(bytes32 node, string calldata name) external;Sets the canonical ENS name for the provided node to name.Only callable by the owner of node.Emits the following event:event NameChanged(bytes32 indexed node, string name);Get Content Hashfunction contenthash(bytes32 node) external view returns (bytes memory);Returns the content hash for node, if one exists. Values are formatted as machine-readable multicodecs, as specified in EIP 1577.contenthash is used to store IPFS and Swarm content hashes, which permit resolving ENS addresses to distributed content (eg, websites) hosted on these distributed networks.This function has interface ID 0xbc1c58d1.This function is specified in EIP 1577.Set Content Hashfunction setContenthash(bytes32 node, bytes calldata hash) external;Sets the content hash for the provided node to hash.Only callable by the owner of node.Values are formatted as machine-readable multicodecs, as specified in EIP 1577.Emits the following event:event ContenthashChanged(bytes32 indexed node, bytes hash);Get Contract ABIABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory);Returns a matching ABI definition for the provided node, if one exists. contentTypes is the bitwise-OR of the encodings that the caller can accept. If multiple content types are specified, the resolver will select one to return. Currently supported content types are:Content Type IDDescription1JSON2zlib-compressed JSON4​CBOR​8URIABI returns a two-tuple of the content type ID and the ABI data. If no data of the appropriate content type ID was found, 0 is returned for the content type ID, and the ABI data will be the empty string.This function has interface ID 0x2203ab56.This function is specified in EIP 205.Set Contract ABIfunction setABI(bytes32 node, uint256 contentType, bytes calldata data) externalSets or updates ABI data for node. contentType specifies the content type ID (see Get Contract ABI for valid values); exactly one type ID must be specified. data contains the encoded ABI data. To clear ABI data for a name, specify the empty string for data.Only callable by the owner of node.Emits the following event:event ABIChanged(bytes32 indexed node, uint256 indexed contentType);Get Public Keyfunction pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y)Returns the ECDSA SECP256k1 public key for node, as a 2-tuple (x, y). If no public key is set, (0, 0) is returned.This function has interface ID 0xc8690233.This function is specified in EIP 619.Set Public Keyfunction setPubkey(bytes32 node, bytes32 x, bytes32 y) externalSets the ECDSA SECP256k1 public key for node to (x, y).Only callable by the owner of node.Emits the following event:event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);Get Text Datafunction text(bytes32 node, string calldata key) external view returns (string memory)Retrieves text metadata for node. Each name may have multiple pieces of metadata, identified by a unique string key. If no text data exists for node with the key key, the empty string is returned.Standard values for key are:keyMeaningemailAn email addressurlA URLavatarA URL to an image used as an avatar or logodescriptionA description of the namenoticeA notice regarding this namekeywordsA list of comma-separated keywords, ordered by most significant first; clients that interpresent this field may choose a threshold beyond which to ignoreIn addition, anyone may specify vendor-specific keys, which must be prefixed with vnd.. The following vendor-specific keys are currently known:keyMeaningcom.twitterTwitter handlecom.githubGithub usernameThis function has interface ID 0x59d1d43c.This function is specified in EIP 634.Set Text Datafunction setText(bytes32 node, string calldata key, string calldata value) externalSets text metadata for node with the unique key key to value, overwriting anything previously stored for node and key. To clear a text field, set it to the empty string.Only callable by the owner of node.Emits the following event:event TextChanged(bytes32 indexed node, string indexedKey, string key);Multicallfunction multicall(bytes[] calldata data) external returns(bytes[] memory results)Permits users to set multiple records in a single operation.Use encodeABI function to encode your contract calls and pass it to data.The frontend usage will be as follows:var addrSet = resolver.contract.methods['setAddr(bytes32,address)'](node, accounts[1]).encodeABI();var textSet = resolver.contract.methods.setText(node, ""url"", ""https://ethereum.org/"").encodeABI();var tx = await resolver.multicall([addrSet, textSet], {from: accounts[0]});Contract API Reference - PreviousTestRegistrarNext - Contract API Reference.eth Permanent RegistrarLast modified 1yr agoCopy linkEdit on GitHubOn this pageCheck Interface SupportGet Ethereum AddressSet Ethereum AddressGet Blockchain AddressSet Blockchain AddressGet Canonical NameSet Canonical NameGet Content HashSet Content HashGet Contract ABISet Contract ABIGet Public KeySet Public KeyGet Text DataSet Text DataMulticall "
20,mains dapp developer guide front end design guidelines,"mains dapp developer guide front end design guidelines.   ENS Front-End Design Guidelines - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookENS Front-End Design GuidelinesENS is a tool to simplify the experience for your users. Here are a series of guidelines and tools that will help you make design choices and implement the best ENS user experience.When to show ENS namesIn every instance a user might otherwise see an Ethereum address or content hash, you can instead display an ENS name. There are two primary use cases for allowing users to display ENS names in your dapp:1.Replacing Ethereum addresses with ENS names: When users are exploring the front-end of your dapp, wherever you would display an Ethereum address, you can instead display an ENS name.2.Resolving input fields: You can allow the user to write an ENS name in an input field that expects an Ethereum address, rather than entering the Ethereum address.Beyond these use cases, remember that the ENS Public Resolver allows you to link different kinds of resources, such as content stored on IPFS or Swarm, or any arbitrary data like text fields, to ENS names. This means there are other situations in which you might want to use ENS in your dapp. For example, if you are using complicated IPFS or Swarm hashes it is possible to convert the hashes to human readable names using ENS. Learn more about the different use cases in the chapter about Enabling ENS in your DApp.1. Replacing Ethereum Addresses with ENS NamesAn ENS name (as a substitute for an Ethereum Address) should only be shown if the user has set a Reverse Record for their address, and if the reverse record (address > name) matches the forward resolution (name > address).As a dApp developer you should therefore first check if the Reverse Record for a given address has been set by the user, and, because users can set the reverse record to be anything they want, even a name they don't own or a random string, you should immediately after check that the resolved name also resolves to the same address by performing the forward resolution. Read more here and in the 'other guidelines' section further down.1.1 - Displaying ENS names instead of Ethereum addressesexample of showing just the name and the visual checksumWhen replacing Ethereum addresses with ENS names you should consider these facts and best practices:Consider adding a visual checksum: it is important to indicate to the user that a name is an ENS name that relates to an Ethereum address or other hash, rather than an http link. To do this, it is advisable to associate the ENS name with some form of visual checksum: identicons, Blockies or other custom algorithmic representation of the address.Visual checksums like identicons can be spoofed or imitated. Therefore they are not meant as a security mechanism. They are only meant as an indicator, to let the user understand that the name is just a different representation of an Ethereum Address.Design a truncated version of the ENS name: ENS names can be very long; besides not being character-limited, users can create an infinite number of subdomains and subdomains of subdomains. If you do show a truncated version of the name, you should provide a way to view the full name, such as expanding it on hover.Not all ENS names end with .eth: ENS names normally end with .eth. However other top-level domains (TLD) are currently supported (.xyz, .luxe, .kred, .art, .club) and more will be in the future. Consider this if you are thinking about displaying the TLD part in the truncated view of long names.1.2 - Always provide an option to see the Ethereum address associated with the ENS nameby clicking the name, this expanded pop-up appears showing the name with the full addressIf you are showing the ENS name in its entirety or a truncated version, you should:Always provide the user a way to display the full Ethereum address: The above example illustrates a pop-up option. Another option would be to use a tooltip. However, consider that floating / pop-ups may be more appropriate than tooltips because the former also supports the other features described here.Provide a view where you display both the ENS name and the Ethereum address together: If the pop-up hides the name and only shows the address it's less friendly than showing both at the same time.Allow the user to copy the full Ethereum address: Allow the user to copy the full address either through a copy button or by selecting it. Tooltips displaying the ENS name in this case should stay visible and not automatically disappear.Optionally give the user a way to automatically open the Ethereum address in a block explorer such as Etherscan (the external link icon in the above example).Optionally show the balance amount, but only to the current signed-in user. User research shows that users tend to recognise their own Ethereum address through their balance, as well as the address itself. This is meant only for the currently ""signed in"" user: only show their own balance and avoid showing the balance of other users.1.3 - Displaying ENS names and Ethereum addresses togetherexample of names with the address visible at the same timeIn some situations you might want to display both the ENS name and the Ethereum address to which it resolves. These layouts can be useful when:Displaying the currently connected user: For the user badge, for example, it could be appropriate to display both the ENS name and a short version of the Ethereum address.The user inputs an ENS name into an input field: This will be described in greater detail in the next chapter that discusses input field resolution.In other high-risk situations: These are situations where the user wants to confirm who a given user/address is, or if you notice that your users keep clicking ENS names because they want to see the Ethereum address in the pop-up, then you could substitute the simple version (only the ENS name) with one that displays both the name and the address.2. Resolving Input Fieldswhen resolving an input show both the ENS name and the Address togetherInput fields where a user is supposed to insert Ethereum addresses should also accept and resolve ENS names. These inputs indicate that the user wants to interact with another user's Ethereum address or contract.Follow these guidelines to create the best experience:Wait before resolving the ENS name: Wait until the user has typed the last TLD, e.g. .eth, .xyz, .luxe or .kred before resolving the name. Alternatively wait until 0.2 - 1.0 seconds after the user has stopped typing in the input field (avoid the eager resolution problem).Don't overwrite the input field with the Ethereum address: Show the resolved ENS name near the input field instead.Always display both the ENS name and the Ethereum address together : Do this after it has successfully been resolved and possibly add also a visual checksum following the suggestions in guideline 1.1.Other guidelines and tipsWhat to do if the Reverse Record doesn't correspond to the Forward Resolution?As mentioned before, user can set the Reverse Record to be anything they want, even a name owned by another user or a completely random string. This is why, after retrieving the name written in the Reverse Record, a dApp developer should also check that it matches the forward resolution, which means the address that ENS name points to. If the two don't match, you MUST NOT show the human readable name and simply leave the plain Ethereum Address. If you don't, users may be able to impersonate other users in your dApp. The chapter on Reverse Resolution has code for you to do this check.Options for displaying usernamesThe obvious choice is to use the user's ENS name as a username. You can do this by providing a mechanism for your users to register a name under your own subdomain, or by looking up the user's ENS name using reverse resolution.Caching and Updating ENS NamesIf your dApp needs to display many Ethereum Addresses or ENS Names in the UI, you can also consider caching the ENS Name after it has been resolved (and verified) or after the user has added the name in an input field.Your optimistic UI can safely display the names from cache in all non-risky situations, in which your user for example is simply browsing, but doesn't need to act or make decisions, especially risky ones, based on the information displayed. However, in all risky situations (eg transferring ETH, tokens or other value), or when the user is interacting with another ENS Name / Ethereum Address, you should perform a direct live resolution and get the most up to date information from the ENS Registry.Also consider that users can change their information in the ENS registry at any time so you should periodically validate the information you cached. For this you can also subscribe to certain Events made available by the contracts (especially AddrChanged, and NameChanged).****Notes on displaying Ethereum Addresses (with or without ENS names)Even when ENS names are not available, research shows that there are some good practices to follow when displaying Ethereum addresses in dApps.Always show the initial ' 0x ' to indicate it's an address.When displaying the name in shorthand versions, show the first 4 and last 4 characters of the address. This is not a security requirement as vanity addresses can be spoofed relatively simply; this is a good practice because some users check the beginning of the name and others check the end of the name. Also, four is the highest number of elements that our mind can easily chunk, parse and remember well.Always provide a way to display the full Ethereum address. Use the same pop-up component that you would use to display ENS names or a tooltip style.decentralandUI Tooltip showing the full AddressOther guidelines previously mentioned also apply for simple Ethereum addresses:Allow the user to copy the full Ethereum address (which mean that tooltips might not be good practice).(Optionally) allow the user to automatically open the address in a block explorer.Front-End toolsAragon-UI - Address Badge component (Design Files / code)Decentraland-UI - address Tooltip (not ENS specific)Dapp Developer Guide - PreviousRegistering & Renewing NamesNext - Dapp Developer GuideENS as NFTLast modified 1yr agoCopy linkEdit on GitHubOn this pageWhen to show ENS names1. Replacing Ethereum Addresses with ENS Names1.1 - Displaying ENS names instead of Ethereum addresses1.2 - Always provide an option to see the Ethereum address associated with the ENS name1.3 - Displaying ENS names and Ethereum addresses together2. Resolving Input FieldsOther guidelines and tipsWhat to do if the Reverse Record doesn't correspond to the Forward Resolution?Options for displaying usernamesCaching and Updating ENS NamesNotes on displaying Ethereum Addresses (with or without ENS names)Front-End tools "
21,mains bug bounty program,"mains bug bounty program.   Bug Bounty Program - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookBug Bounty ProgramThe ENS bug bounty program rewards anyone who finds a bug in covered ENS smart contracts.Rules and RewardsIssues that have already been submitted by another user or are already known to the ENS team are not eligible for bounty rewards.Public disclosure of a vulnerability makes it ineligible for a bounty. This includes exploiting the bug on mainnet or any public test network.The ENS team, employees and all other people paid by ENS project, directly or indirectly, are not eligible for rewards.Only the smart contracts listed below are eligible for rewards. Websites and other infrastructure are not covered by the bounty program.The ENS bounty program considers a number of variables in determining rewards. Determinations of eligibility, score and all terms related to an award are at the sole and final discretion of the ENS team.The value of rewards paid out will vary depending on Severity. The severity is calculated according to the OWASP risk rating model based on Impact and Likelihood :Reward sizes are guided by the rules below, but are in the end, determined at the sole discretion of the ENS teamCritical: up to $250,000 USDHigh: up to $150,000 USDMedium: up to $100,000 USDLow: up to $20,000 USDNote: up to $5,000 USDThe ENS team reserves the right to adjust bounty amounts at any time in the future.Where the contract in our GitHub repository differs from the one deployed on Ethereum, due to changes having been made since the last deployment, the following rules apply:1.If the bug exists in the contract deployed on Ethereum, the full bounty amount is payable.2.If the bug is only in the version on GitHub, the ENS team will decide at is discretion an appropriate proportion of the bounty to award based on the state of the code (from 0% for code that was never intended to be deployed, to 100% for code that is considered final).In addition to Severity, other variables are also considered when the ENS team decides the score, including (but not limited to):Quality of description. Higher rewards are paid for clear, well-written submissions.Quality of reproducibility. Please include test code, scripts and detailed instructions. The easier it is for us to reproduce and verify the vulnerability, the higher the reward.Quality of fix, if included. Higher rewards are paid for submissions with clear description of how to fix the issue.Covered ContractsThe following smart contracts are covered by the bounty:All non-test contracts in ensdomains/ens-contracts.​ensdomains/name-wrapper.Important Legal InformationThe bug bounty program is a discretionary rewards program for the ENS community to encourage and reward those who are helping to improve the platform. It is not a competition. You should know that we can cancel the program at any time, and awards are at the sole discretion of the ENS team. In addition, we are not able to issue awards to individuals who are on sanctions lists or who are in countries on sanctions lists (e.g. North Korea, Iran, etc). You are responsible for all taxes. All awards are subject to applicable law. Any patches must be offered under the same license as the repository they affect. Finally, your testing must not violate any law or compromise any data that is not yours.Submitting a BugBugs should be submitted via email to [email protected], or on Keybase to @arachnid.PreviousDNS Registrar guideNextENS Improvement ProposalsLast modified 1yr agoCopy linkEdit on GitHubOn this pageRules and RewardsCovered ContractsImportant Legal InformationSubmitting a Bug "
22,mains contract api reference subgraphdata,mains contract api reference subgraphdata.   Subgraph - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookSubgraphENS has a GraphQL API Endpoint hosted by The Graph called a subgraph for indexing and organizing data from the ENS smart contracts.This subgraph can be used to query ENS data.Subgraph information is serviced by a decentralized group of server operators called Indexers.GraphQL SchemaThe schema of GraphQL elements available is defined in /schema.graphql​Ethereum Mainnet​Creating an API Key Video Tutorial​​Explorer Page​Graphql Endpoint: https://gateway.thegraph.com/api/[api-key]/subgraphs/id/QmcqvocMfm9LDSEDYmeexzeGt1QTY7T7AVitX9mG2qkvjR​Code Repo​Helpful Links​Querying from an Application​​Managing your API Key & Setting your indexer preferences​Contract API Reference - PreviousDNS RegistrarNextEntitiesLast modified 6mo agoCopy linkEdit on GitHubOn this pageGraphQL SchemaEthereum MainnetHelpful Links 
23,mains ens improvement proposals,mains ens improvement proposals.   ENS Improvement Proposals - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsENSIP-1: ENSENSIP-2: Initial Hash RegistrarENSIP-3: Reverse ResolutionENSIP-4: Support for contract ABIsENSIP-5: Text RecordsENSIP-6: DNS-in-ENSENSIP-7: Contenthash fieldENSIP-8: Interface DiscoveryENSIP-9: Multichain Address ResolutionENSIP-10: Wildcard ResolutionENSIP-11: EVM compatible Chain Address ResolutionENSIP-12: Avatar Text RecordsENSIP-13: SAFE Authentication for ENSENSIP-14: On-chain Source ParameterDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookENS Improvement ProposalsStandards documentation describing the ENS protocolHere are the articles in this section:ENSIP-1: ENSENSIP-2: Initial Hash RegistrarENSIP-3: Reverse ResolutionENSIP-4: Support for contract ABIsENSIP-5: Text RecordsENSIP-6: DNS-in-ENSENSIP-7: Contenthash fieldENSIP-8: Interface DiscoveryENSIP-9: Multichain Address ResolutionENSIP-10: Wildcard ResolutionENSIP-11: EVM compatible Chain Address ResolutionENSIP-12: Avatar Text RecordsENSIP-13: SAFE Authentication for ENSENSIP-14: On-chain Source ParameterPreviousBug Bounty ProgramNextENSIP-1: ENSLast modified 1yr agoCopy linkEdit on GitHub 
24,mains v governance governance proposals,mains v governance governance proposals.   Governance Proposals - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1Term 2Term 3Powered By GitBookGovernance ProposalsThis page contains all governance proposals that have been voted on by the DAO.Here are the articles in this section:Term 0Term 1Term 2Term 3PreviousThe ENS FoundationNextTerm 0Last modified 6mo agoCopy linkEdit on GitHub 
25,mains ens improvement proposals ensip 5 text records,"mains ens improvement proposals ensip 5 text records.   ENSIP-5: Text Records - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsENSIP-1: ENSENSIP-2: Initial Hash RegistrarENSIP-3: Reverse ResolutionENSIP-4: Support for contract ABIsENSIP-5: Text RecordsENSIP-6: DNS-in-ENSENSIP-7: Contenthash fieldENSIP-8: Interface DiscoveryENSIP-9: Multichain Address ResolutionENSIP-10: Wildcard ResolutionENSIP-11: EVM compatible Chain Address ResolutionENSIP-12: Avatar Text RecordsENSIP-13: SAFE Authentication for ENSENSIP-14: On-chain Source ParameterDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookENSIP-5: Text RecordsA standard for storage of text records in ENS (formerly EIP-634).AuthorRichard Moore (@ricmoo)StatusFinalSubmitted2017-05-17AbstractThis ENSIP defines a resolver profile for ENS that permits the lookup of arbitrary key-value text data. This allows ENS name holders to associate e-mail addresses, URLs and other informational data with a ENS name.MotivationThere is often a desire for human-readable metadata to be associated with otherwise machine-driven data; used for debugging, maintenance, reporting and general information.In this ENSIP we define a simple resolver profile for ENS that permits ENS names to associate arbitrary key-value text.SpecificationResolver ProfileA new resolver interface is defined, consisting of the following method:interface IERC634 { /// @notice Returns the text data associated with a key for an ENS name /// @param node A nodehash for an ENS name /// @param key A key to lookup text data for /// @return The text data function text(bytes32 node, string key) view returns (string text);}The EIP-165 interface ID of this interface is 0x59d1d43c.The text data may be any arbitrary UTF-8 string. If the key is not present, the empty string must be returned.Global KeysGlobal Keys must be made up of lowercase letters, numbers and the hyphen (-).avatar - a URL to an image used as an avatar or logodescription - A description of the namedisplay - a canonical display name for the ENS name; this MUST match the ENS name when its case is folded, and clients should ignore this value if it does not (e.g. ""ricmoo.eth"" could set this to ""RicMoo.eth"")email - an e-mail addresskeywords - A list of comma-separated keywords, ordered by most significant first; clients that interpresent this field may choose a threshold beyond which to ignoremail - A physical mailing addressnotice - A notice regarding this namelocation - A generic location (e.g. ""Toronto, Canada"")phone - A phone number as an E.164 stringurl - a website URLService KeysService Keys must be made up of a reverse dot notation for a namespace which the service owns, for example, DNS names (e.g. .com, .io, etc) or ENS name (i.e. .eth). Service Keys must contain at least one dot.This allows new services to start using their own keys without worrying about colliding with existing services and also means new services do not need to update this document.The following services are common, which is why recommendations are provided here, but ideally a service would declare its own key.com.github - a GitHub usernamecom.peepeth - a Peepeth usernamecom.linkedin - a LinkedIn usernamecom.twitter - a Twitter usernameio.keybase - a Keybase usernameorg.telegram - a Telegram usernameThis technique also allows for a service owner to specify a hierarchy for their keys, such as:com.example.userscom.example.groupscom.example.groups.publiccom.example.groups.privateLegacy KeysThe following keys were specified in earlier versions of this ENSIP.Their use is not likely very wide, but applications attempting maximal compatibility may wish to query these keys as a fallback if the above replacement keys fail.vnd.github - a GitHub username (renamed to com.github)vnd.peepeth - a peepeth username (renamed to com.peepeth)vnd.twitter - a Twitter username (renamed to com.twitter)RationaleApplication-specific vs general-purpose record typesRather than define a large number of specific record types (each for generally human-readable data) such as url and email, we follow an adapted model of DNS's TXT records, which allow for a general keys and values, allowing future extension without adjusting the resolver, while allowing applications to use custom keys for their own purposes.Backwards CompatibilityNot applicable.Security ConsiderationsNone.CopyrightCopyright and related rights waived via CC0.PreviousENSIP-4: Support for contract ABIsNextENSIP-6: DNS-in-ENSLast modified 1yr agoCopy linkEdit on GitHubOn this pageAbstractMotivationSpecificationRationaleBackwards CompatibilitySecurity ConsiderationsCopyright "
26,mains contract api reference subgraphdata entities#resolver,"mains contract api reference subgraphdata entities#resolver.   Entities - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookEntitiesEntities​Domain​​DomainEvent​​Transfer​​NewOwner​​NewResolver​​NewTTL​​Account​​Registration​​RegistrationEvent​​NameRegistered​​NameRenewed​​NameTransferred​​Resolver​​ResolverEvent​​AddrChanged​​MulticoinAddrChanged​​NameChanged​​AbiChanged​​PubKeyChanged​​TextChanged​​ContentHashChanged​​InterfaceChanged​​AuthorisationChanged​DomainDescription:FieldTypeDescriptionidID!The namehash of the namenameStringThe human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)labelNameStringThe human readable label name (imported from CSV), if knownlabelhashByteskeccak256(labelName)parentDomainThe namehash (id) of the parent namesubdomains​Domain!​Can count domains from length of arraysubdomainCountInt!The number of subdomainsresolvedAddressaccountAddress logged from current resolver, if anyownerAccount!​resolverResolver​ttlBigInt​isMigratedBoolean!​createdAtBigInt!​events​DomainEvent!​​TransferDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​NewOwnerDescription:FieldTypeDescriptionidID!​parentDomainDomain!​domainDomain!​TransactionIDBytes!​ownerAccount!​NewResolverDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​resolverResolver!​NewTTLDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​transactionIDBytes!​ttlBigInt!​AccountDescription:FieldTypeDescriptionidID!​domain​Domain!​​registration​Registration!​​RegistrationDescription:FieldTypeDescriptionidID!​domainDomain​registrationDateBigInt!​expiryDateBigInt!​costBigInt!​registrantAccount!​labelNameString​events​RegistrationEven!​​RegistrationEventDescription:FieldTypeDescriptionidID!​registrationRegistrationEvent​blockNumberInt!​transactionIDBytes!​NameRegisteredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​registrantAccount!​expiryDateBigInt!​NameRenewedDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​expiryDateBigInt!​NameTransferredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​newOwnerAccount!​ResolverDescription:FieldTypeDescriptionidID!Concatenation of resolver address and namehashdomainDomain​addressBytes!Address of resolver contractaddrAccountCurrent value of addr record (per events)contenHashBytesContent hash, in binary formattexts[String!]Set of observed text record keyscointTypes[BigInt!]Set of observed SLIP-44 coin typesevents​ResolverEvent!​​ResolverEventDescription:FieldTypeDescriptionidID!Concatenation of block number and log IDresolverResolver!Used to derive relationships to ResolversblockNumberInt!​transactionIDBytes!​AddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​addrAccount!​MulticoinAddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​coinTypeBigInt!​addrBytes!​NameChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​nameString!​AbiChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​contentTypeBigInt!​PubkeyChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​xBytes!​yBytes!​TextChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​keyString!​valueString​ContenthashChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​hashBytes!​InterfaceChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​interfacedIDBytes!​implementerBytes!​AuthorisationChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​ownerBytes!​targetBytes!​isAuthorizedBoolean!​Contract API Reference - PreviousSubgraphNextQuery ExamplesLast modified 6mo agoCopy linkEdit on GitHubOn this pageEntitiesDomainTransferNewOwnerNewResolverNewTTLAccountRegistrationRegistrationEventNameRegisteredNameRenewedNameTransferredResolverResolverEventAddrChangedMulticoinAddrChangedNameChangedAbiChangedPubkeyChangedTextChangedContenthashChangedInterfaceChangedAuthorisationChanged "
27,mains v governance governance proposals term 1 ep6.1 social removal of brantly millegan as director of the ens foundation,"mains v governance governance proposals term 1 ep6.1 social removal of brantly millegan as director of the ens foundation.   [EP1.2.1] [Social] Removal of Brantly Millegan as Director of the ENS Foundation - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1[EP1.1] [Executable] Set the temporary premium start price to $100,000[EP1.2.1] [Social] Removal of Brantly Millegan as Director of the ENS Foundation[EP1.2.2] [Social] Election of a new Director of The ENS Foundation[EP1.3.1] [Executable] Q1 & Q2 2022 Meta-Governance WG Budget[EP1.3.2] [Executable] Q1 & Q2 2022 ENS Ecosystem WG Budget[EP1.3.3] [Executable] Q1 & Q2 2022 Community WG Budget[EP1.3.4] [Executable] Q1 & Q2 2022 Public Goods WG Budget[EP1.4] [Executable] Reimburse True Names for expenses and tax obligations incurred for the DAO[EP1.5][Executable] Change to Exponential Premium Price Oracle[EP1.6] [Executable] A DAO-Governed Identity Server[EP1.7] [Executable] End the $ENS and EP2 airdrops[EP1.8] [Social] Working Group Rules[EP1.9] [Executable] Fund the Protocol Guild pilot with 200,000 $ENSTerm 2Term 3Powered By GitBook[EP1.2.1] [Social] Removal of Brantly Millegan as Director of the ENS FoundationThe removal of Brantly Millegan as Director of The ENS Foundation (the ""Foundation Company."").StatusFailedDiscussion Thread​Discourse​Votes​Snapshot, opened March 1st 2022Note: This was previously numbered EP6.1.AbstractThis social proposal puts forth a vote to enact the possible removal of Brantly Millegan as the Director of the Foundation Company.This action is justifiable under Clause 15 of the Articles of Association of The ENS Foundation paragraph titled 'Directors' which states that:The Council has the power, exercisable by notice to the Foundation Company, to appoint or remove one or more directors of the Foundation Company.MotivationA timeline of events that led to this proposal has been posted by Community WG Stewards in another post here and quoted below:In May 2016, Brantly Millegan tweeted, “Homosexual acts are evil. Transgenderism doesn’t exist. Abortion is murder. Contraception is a perversion. So is masturbation and porn.”On February 5th, 2022, brantly.eth, well-known as a prominent representative of the ENS protocol, defended these views in a publicly held Twitter space.Irrespective of one’s personal beliefs, we, as ENS DAO Community Stewards, must set the example for inclusivity and must divide our community.Propagating rhetoric that is viewed as hateful and discriminatory is not conduct conducive to the role as a Community Steward. This conduct will not be tolerated despite one’s contributions to the protocol.Through this Social Proposal, the DAO shall decide whether Brantly Millegan is deemed capable, or otherwise, of continuing his role as the Director of the Foundation Company, and to appoint a suitable replacement if he is deemed incapable.SpecificationThe removal of Brantly Millegan's directorship of the Foundation Company will be defined by a simple ""Yes"" or ""No"" vote with the option to abstain.Draft Snapshot VoteShould Brantly Millegan be removed from directorship of the Foundation Company? Choice 1: Yes Choice 2: No Choice 3: AbstainIf Majority ""Yes:"" Brantly Millegan is voted to be removed and the results of [EP6.2] [Social] Election of a new Director of the ENS Foundation regarding Brantly Millegan's successor shall be effective immediately.If Majority ""No:"" Brantly Millegan is voted to remain in a directorship position over the Foundation Company, the results of [EP6.2] [Social] Election of a new Director of the ENS Foundation shall be null and void.Notice to The ENS FoundationIn line with this proposal, a formal notice is served to the ENS Foundation as follows:""Pursuant to Article 15 of the Articles of Association, the council, hereby, gives notice to the Foundation Company of a vote to remove Brantly Millegan as a director of the Foundation Company.Whereas, the council undertook a vote, via Snapshot, to remove Brantly Millegan, as a director of the Foundation Company;Whereas, by a majority of the votes cast is to remove Brantly Millegan, as a director of the Foundation Company;Wherefore, Brantly Millegan is hereby removed as a director of The ENS Foundation and shall cease and desist all duties thereto.The result to be formally noted in the council records and shall be promptly communicated to the Foundation Company without further process.This Notice shall have no force or effect, if the vote to remove Brantly Millegan fails to obtain a majority of the votes cast.""Previous[EP1.1] [Executable] Set the temporary premium start price to $100,000Next[EP1.2.2] [Social] Election of a new Director of The ENS FoundationLast modified 6mo agoCopy linkEdit on GitHubOn this pageAbstractMotivationSpecificationNotice to The ENS Foundation "
28,mains dapp developer guide ens as nft,"mains dapp developer guide ens as nft.   ENS as NFT - ENS Documentation    ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookENS as NFTWhen ENS .eth registrar migrated in May 2019, the .eth registrar became an ERC721 compliant non-fungible token contract, meaning that .eth registrations can be transferred in the same fashion as other NFTs.Deriving tokenId from ENS nameThe tokenId of ENS name is simply the uint256 representation of the hash of the label (vitalik for vitalik.eth).const ethers = require('ethers')const BigNumber = ethers.BigNumberconst utils = ethers.utilsconst name = 'vitalik'const labelHash = utils.keccak256(utils.toUtf8Bytes(name))const tokenId = BigNumber.from(labelHash).toString()In the example above,79233663829379634837589865448569342784712482819484549289560981379859480642508 is the tokenId of vitalik.ethDeriving ENS name from tokenIdUnlike deriving tokenId, deriving ENS name from tokenId is not as easy. This is because all ENS names are stored as fixed-length hash to allow registering infinite length of names. The downside of this architecture is that you cannot directly query ENS smart contracts to return ENS name using tokenId.Our recommended way is to query via https://thegraph.com ENS subgraph. The graph decodes the hash to name as it indexes. The example code to query is as follows.const ethers = require('ethers')const BigNumber = ethers.BigNumberconst gr = require('graphql-request')const { request, gql } = grconst tokenId = '79233663829379634837589865448569342784712482819484549289560981379859480642508'// Should return 0xaf2caa1c2ca1d027f1ac823b529d0a67cd144264b2789fa2ea4d63a67c7103ccconst labelHash = BigNumber.from(tokenId).toHexString()​const url = 'https://api.thegraph.com/subgraphs/name/ensdomains/ens'const GET_LABEL_NAME = gql`query{ domains(first:1, where:{labelhash:""${labelHash}""}){ labelName }}`​request(url, GET_LABEL_NAME).then((data) => console.log(data))// { domains: [ { labelName: 'vitalik' } ] }If you prefer not to rely on a third party like TheGraph, the team open-sourced ens-rainbow containing a link to the original dataset (6GB with 133 million entities) so that you can host your own ENS name decoding service.Turning subdomain into NFTCurrently, all the subdomains nor non .eth domains are not NFT, unless the domain registrar itself supports NFT such as (dcl.eth, and .kred). If you want to turn all subdomains which you own, you have to create a registrar1.Create a registrar contract as ERC721 compliant2.Set ENS registry address (mostly when you deploy the registrar)3.Create register function which calls registry.setSubnodeOwner then mint the token making the subdomain label hash as tokenIdcontract DCLRegistrar is ERC721Full, Ownable { constructor(  IENSRegistry _registry, ) public ERC721Full(""DCL Registrar"", ""DCLENS"") {  // ENS registry  updateRegistry(_registry); }​ function register(  string memory _subdomain,  bytes32 subdomainLabelHash,  address _beneficiary,  uint256 _createdDate ) internal {  // Create new subdomain and assign the _beneficiary as the owner  registry.setSubnodeOwner(domainNameHash, subdomainLabelHash, _beneficiary);  // Mint an ERC721 token with the subdomain label hash as its id  _mint(_beneficiary, uint256(subdomainLabelHash)); }}Once deployed, then you have to transfer the controller address to the contract.For non-technical users, we are currently working on upgrading our SubdomainRegistrar which allows you to turn your subdomain into NFT without any coding.Metadata.eth does not have .tokenURI . However, we created a separate metadata service which NFT marketplaces like OpenSea can fetch metadata for ENS such as registration data, expiration date, name length, etc. For more detail, please refer to the metadata documentation site.ENS Metadata ServiceDapp Developer Guide - PreviousENS Front-End Design GuidelinesNext - Dapp Developer GuideENS Layer2 and offchain data supportLast modified 6mo agoCopy linkEdit on GitHubOn this pageDeriving tokenId from ENS nameDeriving ENS name from tokenIdTurning subdomain into NFTMetadata "
29,mains contract api reference subgraphdata entities#addrchanged,"mains contract api reference subgraphdata entities#addrchanged.   Entities - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookEntitiesEntities​Domain​​DomainEvent​​Transfer​​NewOwner​​NewResolver​​NewTTL​​Account​​Registration​​RegistrationEvent​​NameRegistered​​NameRenewed​​NameTransferred​​Resolver​​ResolverEvent​​AddrChanged​​MulticoinAddrChanged​​NameChanged​​AbiChanged​​PubKeyChanged​​TextChanged​​ContentHashChanged​​InterfaceChanged​​AuthorisationChanged​DomainDescription:FieldTypeDescriptionidID!The namehash of the namenameStringThe human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)labelNameStringThe human readable label name (imported from CSV), if knownlabelhashByteskeccak256(labelName)parentDomainThe namehash (id) of the parent namesubdomains​Domain!​Can count domains from length of arraysubdomainCountInt!The number of subdomainsresolvedAddressaccountAddress logged from current resolver, if anyownerAccount!​resolverResolver​ttlBigInt​isMigratedBoolean!​createdAtBigInt!​events​DomainEvent!​​TransferDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​NewOwnerDescription:FieldTypeDescriptionidID!​parentDomainDomain!​domainDomain!​TransactionIDBytes!​ownerAccount!​NewResolverDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​resolverResolver!​NewTTLDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​transactionIDBytes!​ttlBigInt!​AccountDescription:FieldTypeDescriptionidID!​domain​Domain!​​registration​Registration!​​RegistrationDescription:FieldTypeDescriptionidID!​domainDomain​registrationDateBigInt!​expiryDateBigInt!​costBigInt!​registrantAccount!​labelNameString​events​RegistrationEven!​​RegistrationEventDescription:FieldTypeDescriptionidID!​registrationRegistrationEvent​blockNumberInt!​transactionIDBytes!​NameRegisteredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​registrantAccount!​expiryDateBigInt!​NameRenewedDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​expiryDateBigInt!​NameTransferredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​newOwnerAccount!​ResolverDescription:FieldTypeDescriptionidID!Concatenation of resolver address and namehashdomainDomain​addressBytes!Address of resolver contractaddrAccountCurrent value of addr record (per events)contenHashBytesContent hash, in binary formattexts[String!]Set of observed text record keyscointTypes[BigInt!]Set of observed SLIP-44 coin typesevents​ResolverEvent!​​ResolverEventDescription:FieldTypeDescriptionidID!Concatenation of block number and log IDresolverResolver!Used to derive relationships to ResolversblockNumberInt!​transactionIDBytes!​AddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​addrAccount!​MulticoinAddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​coinTypeBigInt!​addrBytes!​NameChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​nameString!​AbiChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​contentTypeBigInt!​PubkeyChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​xBytes!​yBytes!​TextChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​keyString!​valueString​ContenthashChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​hashBytes!​InterfaceChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​interfacedIDBytes!​implementerBytes!​AuthorisationChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​ownerBytes!​targetBytes!​isAuthorizedBoolean!​Contract API Reference - PreviousSubgraphNextQuery ExamplesLast modified 6mo agoCopy linkEdit on GitHubOn this pageEntitiesDomainTransferNewOwnerNewResolverNewTTLAccountRegistrationRegistrationEventNameRegisteredNameRenewedNameTransferredResolverResolverEventAddrChangedMulticoinAddrChangedNameChangedAbiChangedPubkeyChangedTextChangedContenthashChangedInterfaceChangedAuthorisationChanged "
30,mains ens improvement proposals ensip 9 multichain address resolution,"mains ens improvement proposals ensip 9 multichain address resolution.   ENSIP-9: Multichain Address Resolution - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsENSIP-1: ENSENSIP-2: Initial Hash RegistrarENSIP-3: Reverse ResolutionENSIP-4: Support for contract ABIsENSIP-5: Text RecordsENSIP-6: DNS-in-ENSENSIP-7: Contenthash fieldENSIP-8: Interface DiscoveryENSIP-9: Multichain Address ResolutionENSIP-10: Wildcard ResolutionENSIP-11: EVM compatible Chain Address ResolutionENSIP-12: Avatar Text RecordsENSIP-13: SAFE Authentication for ENSENSIP-14: On-chain Source ParameterDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookENSIP-9: Multichain Address ResolutionIntroduces new overloads for the `addr` field for ENS resolvers, which permit resolution of addresses for other blockchains via ENS (formerly EIP-2304).AuthorNick Johnson <[email protected]>StatusFinalSubmitted2019-09-09MotivationWith the increasing uptake of ENS by multi-coin wallets, wallet authors have requested the ability to resolve addresses for non-Ethereum chains inside ENS. This specification standardises a way to enter and retrieve these addresses in a cross-client fashion.SpecificationA new accessor function for resolvers is specified:function addr(bytes32 node, uint coinType) external view returns(bytes memory);The EIP165 interface ID for this function is 0xf1cb7e06.When called on a resolver, this function must return the cryptocurrency address for the specified namehash and coin type. A zero-length string must be returned if the specified coin ID does not exist on the specified node.coinType is the cryptocurrency coin type index from SLIP44.The return value is the cryptocurrency address in its native binary format. Detailed descriptions of the binary encodings for several popular chains are provided in the Address Encoding section below.A new event for resolvers is defined:event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);Resolvers MUST emit this event on each change to the address for a name and coin type.Recommended accessor functionsThe following function provides the recommended interface for changing the addresses stored for a node. Resolvers SHOULD implement this interface for setting addresses unless their needs dictate a different interface.function setAddr(bytes32 node, uint coinType, bytes calldata addr);setAddr adds or replaces the address for the given node and coin type. The parameters for this function are as per those described in addr() above.This function emits an AddressChanged event with the new address; see also the backwards compatibility section below for resolvers that also support addr(bytes32).Address EncodingIn general, the native binary representation of the address should be used, without any checksum commonly used in the text representation.A table of encodings for common blockchains is provided, followed by a more detailed description of each format. In the table, 'encodings' lists the address encodings supported by that chain, along with any relevant parameters. Details of those address encodings are described in the following sections.CryptocurrencyCoin TypeEncodingBitcoin0P2PKH(0x00), P2SH(0x05), SegWit('bc')Litecoin2P2PKH(0x30), P2SH(0x32), P2SH(0x05), SegWit('ltc')Dogecoin3P2PKH(0x1e), P2SH(0x16)Monacoin22P2PKH(0x32), P2SH(0x05)Ethereum60ChecksummedHexEthereum Classic61ChecksummedHexRootstock137ChecksummedHex(30)Ripple144RippleBitcoin Cash145P2PKH(0x00), P2SH(0x05), CashAddrBinance714Bech32('bnb')P2PKH(version)Pay to Public Key Hash addresses are base58check encoded. After decoding, the first byte is a version byte. For example, the Bitcoin address 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa base58check decodes to the 21 bytes 0062e907b15cbf27d5425399ebf6f0fb50ebb88f18.P2PKH addresses have a version byte, followed by a 20 byte pubkey hash. Their canonical encoding is their scriptPubkey encoding (specified here) is OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG.The above example address is thus encoded as the 25 bytes 76a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1888ac.P2SH(version)P2SH addresses are base58check encoded in the same manner as P2PKH addresses. P2SH addresses have a version, followed by a 20 byte script hash. Their scriptPubkey encoding (specified here) is OP_HASH160 <scriptHash> OP_EQUAL. A Bitcoin address of 3Ai1JZ8pdJb2ksieUV8FsxSNVJCpoPi8W6 decodes to the 21 bytes 0562e907b15cbf27d5425399ebf6f0fb50ebb88f18 and is encoded as the 23 bytes a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1887.SegWit(hrp)SegWit addresses are encoded with bech32. Bech32 addresses consist of a human-readable part - 'bc' for Bitcoin mainnet - and a machine readable part. For SegWit addresses, this decodes to a 'witness version', between 0 and 15, and a 'witness program', as defined in BIP141.The scriptPubkey encoding for a bech32 address, as defined in BIP141, is OP_n, where n is the witness version, followed by a push of the witness program. Note this warning from BIP173:Implementations should take special care when converting the address to a scriptPubkey, where witness version n is stored as OP_n. OP_0 is encoded as 0x00, but OP_1 through OP_16 are encoded as 0x51 though 0x60 (81 to 96 in decimal). If a bech32 address is converted to an incorrect scriptPubKey the result will likely be either unspendable or insecure.For example, the Bitcoin SegWit address BC1QW508D6QEJXTDG4Y5R3ZARVARY0C5XW7KV8F3T4 decodes to a version of 0 and a witness script of 751e76e8199196d454941c45d1b3a323f1433bd6, and then encodes to a scriptPubkey of 0014751e76e8199196d454941c45d1b3a323f1433bd6.ChecksummedHex(chainId?)To translate a text format checksummed hex address into binary format, simply remove the '0x' prefix and hex decode it. 0x314159265dD8dbb310642f98f50C066173C1259b is hex-decoded and stored as the 20 bytes 314159265dd8dbb310642f98f50c066173c1259b.A checksum format is specified by EIP-55, and extended by RSKIP60, which specifies a means of including the chain ID in the checksum. The checksum on a text format address must be checked. Addresses with invalid checksums that are not all uppercase or all lowercase MUST be rejected with an error. Implementations may choose whether to accept non-checksummed addresses, but the authors recommend at least providing a warning to users in this situation.When encoding an address from binary to text, an EIP55/RSKIP60 checksum MUST be used - so the correct encoding of the above address for Ethereum is 0x314159265dD8dbb310642f98f50C066173C1259b.RippleRipple addresses are encoded using a version of base58check with an alternative alphabet, described here. Two types of ripple addresses are supported, 'r-addresses', and 'X-addresss'. r-addresses consist of a version byte followed by a 20 byte hash, while X-addresses consist of a version byte, a 20 byte hash, and a tag, specified here.Both address types should be stored in ENS by performing ripple's version of base58check decoding and storing them directly (including version byte). For example, the ripple address rf1BiGeXwwQoi8Z2ueFYTEXSwuJYfV2Jpn decodes to and is stored as 004b4e9c06f24296074f7bc48f92a97916c6dc5ea9, while the address X7qvLs7gSnNoKvZzNWUT2e8st17QPY64PPe7zriLNuJszeg decodes to and is stored as 05444b4e9c06f24296074f7bc48f92a97916c6dc5ea9000000000000000000.CashAddrBitcoin Cash defines a new address format called 'CashAddr', specified here. This uses a variant of bech32 encoding to encode and decode (non-segwit) Bitcoin Cash addresses, using a prefix of 'bitcoincash:'. A CashAddr should be decoded using this bech32 variant, then converted and stored based on its type (P2PKH or P2SH) as described in the relevant sections above.Bech32​Bech32 addresses consist of a human-readable part - for example, 'bnb' for Binance - and a machine readable part. The encoded data is simply the address, which can be converted to binary and stored directly.For example, the BNB address bnb1grpf0955h0ykzq3ar5nmum7y6gdfl6lxfn46h2 decodes to the binary representation 40c2979694bbc961023d1d27be6fc4d21a9febe6, which is stored directly in ENS.ExampleAn example implementation of a resolver that supports this ENSIP is provided here:pragma solidity ^0.5.8;​contract AddrResolver is ResolverBase { bytes4 constant private ADDR_INTERFACE_ID = 0x3b3b57de; bytes4 constant private ADDRESS_INTERFACE_ID = 0xf1cb7e06; uint constant private COIN_TYPE_ETH = 60;​ event AddrChanged(bytes32 indexed node, address a); event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);​ mapping(bytes32=>mapping(uint=>bytes)) _addresses;​ /**  * Sets the address associated with an ENS node.  * May only be called by the owner of that node in the ENS registry.  * @param node The node to update.  * @param a The address to set.  */ function setAddr(bytes32 node, address a) external authorised(node) { setAddr(node, COIN_TYPE_ETH, addressToBytes(a)); }​ /**  * Returns the address associated with an ENS node.  * @param node The ENS node to query.  * @return The associated address.  */ function addr(bytes32 node) public view returns (address) { bytes memory a = addr(node, COIN_TYPE_ETH); if(a.length == 0) { return address(0); } return bytesToAddress(a); }​ function setAddr(bytes32 node, uint coinType, bytes memory a) public authorised(node) { emit AddressChanged(node, coinType, a); if(coinType == COIN_TYPE_ETH) { emit AddrChanged(node, bytesToAddress(a)); }  _addresses[node][coinType] = a; }​ function addr(bytes32 node, uint coinType) public view returns(bytes memory) { return _addresses[node][coinType]; }​ function supportsInterface(bytes4 interfaceID) public pure returns(bool) { return interfaceID == ADDR_INTERFACE_ID || interfaceID == ADDRESS_INTERFACE_ID || super.supportsInterface(interfaceID); }}ImplementationAn implementation of this interface is provided in the ensdomains/resolvers repository.Backwards CompatibilityIf the resolver supports the addr(bytes32) interface defined in ENSIP-1, the resolver MUST treat this as a special case of this new specification in the following ways:1.The value returned by addr(node) from ENSIP-1 should always match the value returned by addr(node, 60) (60 is the coin type ID for Ethereum).2.Anything that causes the AddrChanged event from ENSIP-1 to be emitted must also emit an AddressChanged event from this ENSIP, with the coinType specified as 60, and vice-versa.TestsThe table below specifies test vectors for valid address encodings for each cryptocurrency described above.CryptocurrencyCoin TypeTextOnchain (hex)Bitcoin01A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa76a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1888ac​​3Ai1JZ8pdJb2ksieUV8FsxSNVJCpoPi8W6a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1887​​BC1QW508D6QEJXTDG4Y5R3ZARVARY0C5XW7KV8F3T40014751e76e8199196d454941c45d1b3a323f1433bd6Litecoin2LaMT348PWRnrqeeWArpwQPbuanpXDZGEUz76a914a5f4d12ce3685781b227c1f39548ddef429e978388ac​​MQMcJhpWHYVeQArcZR3sBgyPZxxRtnH441a914b48297bff5dadecc5f36145cec6a5f20d57c8f9b87​​ltc1qdp7p2rpx4a2f80h7a4crvppczgg4egmv5c78w80014687c150c26af5493befeed7036043812115ca36cDogecoin3DBXu2kgc3xtvCUWFcxFE3r9hEYgmuaaCyD76a9144620b70031f0e9437e374a2100934fba4911046088ac​​AF8ekvSf6eiSBRspJjnfzK6d1EM6pnPq3Ga914f8f5d99a9fc21aa676e74d15e7b8134557615bda87Monacoin22MHxgS2XMXjeJ4if2PRRbWYcdwZPWfdwaDT76a9146e5bb7226a337fe8307b4192ae5c3fab9fa9edf588acEthereum600x314159265dD8dbb310642f98f50C066173C1259b314159265dd8dbb310642f98f50c066173c1259bRootstock1370x5aaEB6053f3e94c9b9a09f33669435E7ef1bEAeD5aaeb6053f3e94c9b9a09f33669435e7ef1beaedRipple144rf1BiGeXwwQoi8Z2ueFYTEXSwuJYfV2Jpn004b4e9c06f24296074f7bc48f92a97916c6dc5ea9​​X7qvLs7gSnNoKvZzNWUT2e8st17QPY64PPe7zriLNuJszeg05444b4e9c06f24296074f7bc48f92a97916c6dc5ea9000000000000000000Bitcoin Cash1451BpEi6DfDAUFd7GtittLSdBeYJvcoaVggu76a91476a04053bda0a88bda5177b86a15c3b29f55987388ac​​bitcoincash:qpm2qsznhks23z7629mms6s4cwef74vcwvy22gdx6a76a91476a04053bda0a88bda5177b86a15c3b29f55987388ac​​3CWFddi6m4ndiGyKqzYvsFYagqDLPVMTzCa91476a04053bda0a88bda5177b86a15c3b29f55987387​​bitcoincash:ppm2qsznhks23z7629mms6s4cwef74vcwvn0h829pqa91476a04053bda0a88bda5177b86a15c3b29f55987387Binance714bnb1grpf0955h0ykzq3ar5nmum7y6gdfl6lxfn46h240c2979694bbc961023d1d27be6fc4d21a9febe6CopyrightCopyright and related rights waived via CC0.PreviousENSIP-8: Interface DiscoveryNextENSIP-10: Wildcard ResolutionLast modified 1yr agoCopy linkEdit on GitHubOn this pageMotivationSpecificationBackwards CompatibilityTestsCopyright "
31,mains contract api reference subgraphdata entities#domain,"mains contract api reference subgraphdata entities#domain.   Entities - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookEntitiesEntities​Domain​​DomainEvent​​Transfer​​NewOwner​​NewResolver​​NewTTL​​Account​​Registration​​RegistrationEvent​​NameRegistered​​NameRenewed​​NameTransferred​​Resolver​​ResolverEvent​​AddrChanged​​MulticoinAddrChanged​​NameChanged​​AbiChanged​​PubKeyChanged​​TextChanged​​ContentHashChanged​​InterfaceChanged​​AuthorisationChanged​DomainDescription:FieldTypeDescriptionidID!The namehash of the namenameStringThe human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)labelNameStringThe human readable label name (imported from CSV), if knownlabelhashByteskeccak256(labelName)parentDomainThe namehash (id) of the parent namesubdomains​Domain!​Can count domains from length of arraysubdomainCountInt!The number of subdomainsresolvedAddressaccountAddress logged from current resolver, if anyownerAccount!​resolverResolver​ttlBigInt​isMigratedBoolean!​createdAtBigInt!​events​DomainEvent!​​TransferDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​NewOwnerDescription:FieldTypeDescriptionidID!​parentDomainDomain!​domainDomain!​TransactionIDBytes!​ownerAccount!​NewResolverDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​resolverResolver!​NewTTLDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​transactionIDBytes!​ttlBigInt!​AccountDescription:FieldTypeDescriptionidID!​domain​Domain!​​registration​Registration!​​RegistrationDescription:FieldTypeDescriptionidID!​domainDomain​registrationDateBigInt!​expiryDateBigInt!​costBigInt!​registrantAccount!​labelNameString​events​RegistrationEven!​​RegistrationEventDescription:FieldTypeDescriptionidID!​registrationRegistrationEvent​blockNumberInt!​transactionIDBytes!​NameRegisteredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​registrantAccount!​expiryDateBigInt!​NameRenewedDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​expiryDateBigInt!​NameTransferredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​newOwnerAccount!​ResolverDescription:FieldTypeDescriptionidID!Concatenation of resolver address and namehashdomainDomain​addressBytes!Address of resolver contractaddrAccountCurrent value of addr record (per events)contenHashBytesContent hash, in binary formattexts[String!]Set of observed text record keyscointTypes[BigInt!]Set of observed SLIP-44 coin typesevents​ResolverEvent!​​ResolverEventDescription:FieldTypeDescriptionidID!Concatenation of block number and log IDresolverResolver!Used to derive relationships to ResolversblockNumberInt!​transactionIDBytes!​AddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​addrAccount!​MulticoinAddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​coinTypeBigInt!​addrBytes!​NameChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​nameString!​AbiChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​contentTypeBigInt!​PubkeyChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​xBytes!​yBytes!​TextChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​keyString!​valueString​ContenthashChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​hashBytes!​InterfaceChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​interfacedIDBytes!​implementerBytes!​AuthorisationChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​ownerBytes!​targetBytes!​isAuthorizedBoolean!​Contract API Reference - PreviousSubgraphNextQuery ExamplesLast modified 6mo agoCopy linkEdit on GitHubOn this pageEntitiesDomainTransferNewOwnerNewResolverNewTTLAccountRegistrationRegistrationEventNameRegisteredNameRenewedNameTransferredResolverResolverEventAddrChangedMulticoinAddrChangedNameChangedAbiChangedPubkeyChangedTextChangedContenthashChangedInterfaceChangedAuthorisationChanged "
32,mains contract api reference .eth permanent registrar registrar,"mains contract api reference .eth permanent registrar registrar.   Registrar - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarRegistrarControllerDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookRegistrar​Source​This contract implements the core functionality of the permanent registrar, with the following features:The owner of the registrar may add and remove 'controllers'.Controllers may register new domains and extend the expiry of (renew) existing domains. They can not change the ownership or reduce the expiration time of existing domains.Name owners may transfer ownership to another address.Name owners may reclaim ownership in the ENS registry if they have lost it.Owners of names in the legacy registrar may transfer them to the new registrar, during the 1 year transition period. When they do so, their deposit is returned to them in its entirety.This section documents the parts of the registrar interface relevant to implementers of tools that interact with it. Functionality exclusive to the registrar owner or to controllers is omitted for brevity.The registrar works exclusively with label hashes - the keccak256 of the first component of the label (eg, keccak256('ens') for ens.eth). For compatibility with ERC721, these are expressed as uint256 values rather than bytes32, but can be cast backwards and forwards transparently. The namehash of a name can be derived by computing keccak256(baseNode, labelHash), where basenode is the namehash of the TLD the registrar manages - eg, namehash('eth').Registrations and renewals are handled via the controller.Names and RegistrationsAll names inside ENS have an owner. The owner of a name can transfer the name to a new owner, set a resolver, and create and reassign subdomains. This functionality is all contained in the ENS registry.Allocation of names directly under .eth (eg, second-level domains ending with .eth, such as alice.eth) is governed by the .eth Permanent Registrar, described here. While buying a name from the registrar grants ownership of it in ENS, the registrar itself keeps independent track of who owns the registration. The concept of a registrant - the owner of a registration - is unique to the .eth permanent registrar.The registrant of a name can transfer the registration to another account, and they can recover ownership of the name by calling reclaim, which resets ownership of the ENS name to the registrant's account.Separating the concept of owning a name from owning a registration makes it possible to more easily build systems that make automated updates to ENS. The registrant can transfer ownership of the name to another account or to a smart contract that manages records, subdomains, etc, while still retaining the ability to recover ownership for upgrades, or in the case of a compromise.When thinking about ownership, it's important to be clear whether you're considering ownership of the name or the registration.Read OperationsGet Name Expiryfunction nameExpires(uint256 label) external view returns(uint);Returns the unix timestamp at which a registration currently expires. Names that do not exist or are not yet migrated from the legacy registrar will return 0.Check Name Availabilityfunction available(uint256 label) public view returns(bool);Returns true if a name is available for registration. Takes into account not-yet-migrated registrations from the legacy registrar. Registrar controllers may impose more restrictions on registrations than this contract (for example, a minimum name length), so this function should not be used to check if a name can be registered by a user. To check if a name can be registered by a user, check name availability via the controller.Get Transfer Period Enduint public transferPeriodEnds;transferPeriodEnds documents the unix timestamp at which it is no longer possible to migrate over registrations from the legacy registrar, and any non-migrated registrations become available for registration by anyone.Get Controller Statusmapping(address=>bool) public controllers;controllers allows callers to check if the supplied address is authorized as a registrar controller.Check Token Approvalfunction getApproved(uint256 tokenId) public view returns (address operator);Returns the address of the approved operator for this name.This function is part of ERC721.Check All Tokens Approvalfunction isApprovedForAll(address owner, address operator) public view returns (bool);Returns true if operator is authorized to transfer all tokens for owner.This function is part of ERC721.Get Name Ownerfunction ownerOf(uint256 label) external view returns(address);ownerOf returns the address that owns the registration identified by the label hash, or reverts if the registration does not exist. Registrations that have not yet been migrated from the legacy registrar are treated the same as registrations that do not exist.This function is part of ERC721.Write OperationsTransfer a Namefunction transferFrom(address from, address to, uint256 tokenId) public;function safeTransferFrom(address from, address to, uint256 tokenId) public;function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;These functions transfer the registration.They behave as specified in ERC721.Emits the following event on a successful transfer:event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);Approve Operatorfunction approve(address to, uint256 tokenId) public;function setApprovalForAll(address operator, bool _approved) public;These functions manage approvals as documented in ERC721.Reclaim ENS Recordfunction reclaim(uint256 label) external;Sets the owner record of the name in the ENS registry to match the owner of the registration in this registry. May only be called by the owner of the registration.EventsName Migratedevent NameMigrated(uint256 indexed hash, address indexed owner, uint expires);This event is emitted when a name is migrated from the legacy registrar.Name Registeredevent NameRegistered(uint256 indexed hash, address indexed owner, uint expires);This event is emitted when a controller registers a new name.Name Renewedevent NameRenewed(uint256 indexed hash, uint expires);This event is emitted when a controller renews (extends the registration of) a name.Transferevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);This event is emitted when registration is transferred to a new owner. This is distinct from the ENS Registry's Transfer event, which records transfers of ownership of the ENS record.Contract API Reference - Previous.eth Permanent RegistrarNextControllerLast modified 1yr agoCopy linkEdit on GitHubOn this pageNames and RegistrationsRead OperationsGet Name ExpiryCheck Name AvailabilityGet Transfer Period EndGet Controller StatusCheck Token ApprovalCheck All Tokens ApprovalGet Name OwnerWrite OperationsTransfer a NameApprove OperatorReclaim ENS RecordEventsName MigratedName RegisteredName RenewedTransfer "
33,mains ens improvement proposals ensip 7 contenthash field,"mains ens improvement proposals ensip 7 contenthash field.   ENSIP-7: Contenthash field - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsENSIP-1: ENSENSIP-2: Initial Hash RegistrarENSIP-3: Reverse ResolutionENSIP-4: Support for contract ABIsENSIP-5: Text RecordsENSIP-6: DNS-in-ENSENSIP-7: Contenthash fieldENSIP-8: Interface DiscoveryENSIP-9: Multichain Address ResolutionENSIP-10: Wildcard ResolutionENSIP-11: EVM compatible Chain Address ResolutionENSIP-12: Avatar Text RecordsENSIP-13: SAFE Authentication for ENSENSIP-14: On-chain Source ParameterDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookENSIP-7: Contenthash fieldIntroduces a field for storing content addresses and hashes in ENS (formerly EIP-1577).AuthorDean Eigenmann <[email protected]>, Nick Johnson <[email protected]>StatusFinalCreated2018-11-13AbstractThis ENSIP introduces the new contenthash field for ENS resolvers, allowing for a better defined system of mapping names to network and content addresses. Additionally the content and multihash fields are deprecated.MotivationMultiple applications including Metamask and mobile clients such as Status have begun resolving ENS names to content hosted on distributed systems such as IPFS and Swarm. Due to the various ways content can be stored and addressed, a standard is required so these applications know how to resolve names and that domain owners know how their content will be resolved.The contenthash field allows for easy specification of network and content addresses in ENS.SpecificationThe field contenthash is introduced, which permits a wide range of protocols to be supported by ENS names. Resolvers supporting this field MUST return true when the supportsInterface function is called with argument 0xbc1c58d1.The fields content and multihash are deprecated.The value returned by contenthash MUST be represented as a machine-readable multicodec. The format is specified as follows:<protoCode uvarint><value []byte>protoCodes and their meanings are specified in the multiformats/multicodec repository.The encoding of the value depends on the content type specified by the protoCode. Values with protocodes of 0xe3 and 0xe4 represent IPFS and Swarm content; these values are encoded as v1 CIDs without a base prefix, meaning their value is formatted as follows:<protoCode uvarint><cid-version><multicodec-content-type><multihash-content-address>When resolving a contenthash, applications MUST use the protocol code to determine what type of address is encoded, and resolve the address appropriately for that protocol, if supported.ExampleIPFSInput data:storage system: IPFS (0xe3)CID version: 1 (0x01)content type: dag-pb (0x70)hash function: sha2-256 (0x12)hash length: 32 bytes (0x20)hash: 29f2d17be6139079dc48696d1f582a8530eb9805b561eda517e22a892c7e3f1fBinary format:0xe3010170122029f2d17be6139079dc48696d1f582a8530eb9805b561eda517e22a892c7e3f1fText format:ipfs://QmRAQB6YaCyidP37UdDnjFY5vQuiBrcqdyoW1CuDgwxkD4SwarmInput data:storage system: Swarm (0xe4)CID version: 1 (0x01)content type: swarm-manifest (0xfa)hash function: keccak256 (0x1b)hash length: 32 bytes (0x20)hash: d1de9994b4d039f6548d191eb26786769f580809256b4685ef316805265ea162Binary format:0xe40101fa011b20d1de9994b4d039f6548d191eb26786769f580809256b4685ef316805265ea162Text format:bzz://d1de9994b4d039f6548d191eb26786769f580809256b4685ef316805265ea162Example usage with swarm hash:$ swarm hash ens contenthash d1de9994b4d039f6548d191eb26786769f580809256b4685ef316805265ea162         > e40101fa011b20d1de9994b4d039f6548d191eb26786769f580809256b4685ef316805265ea162FallbackIn order to support names that have an IPFS or Swarm hash in their content field, a grace period MUST be implemented offering those name holders time to update their names. If a resolver does not support the multihash interface, it MUST be checked whether they support the content interface. If they do, the value of that field SHOULD be treated in a context dependent fashion and resolved. This condition MUST be enforced until at least March 31st, 2019.ImplementationTo support contenthash, a new resolver has been developed and can be found here, you can also find this smart contract deployed on:Mainnet : 0xd3ddccdd3b25a8a7423b5bee360a42146eb4baf3​Ropsten : 0xde469c7106a9fbc3fb98912bb00be983a89bddca​There are also implementations in multiple languages to encode and decode contenthash:​JavaScript​​Python​CopyrightCopyright and related rights waived via CC0.PreviousENSIP-6: DNS-in-ENSNextENSIP-8: Interface DiscoveryLast modified 1yr agoCopy linkEdit on GitHubOn this pageAbstractMotivationSpecificationCopyright "
34,mains contract api reference .eth permanent registrar controller#check name availability,"mains contract api reference .eth permanent registrar controller#check name availability.   Controller - ENS Documentation    ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarRegistrarControllerDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookController​Source​This section documents the parts of the ETHRegistrarController relevant to implementers of tools that interact with it. Functionality exclusive to the registrar owner is omitted for brevity.The controller works exclusively with plaintext labels (eg, 'alice' for 'alice.eth').To prevent frontrunning, the ETHRegistrarController requires a commit/reveal process for new name registrations (but not for renewals). To register a name, the user must:1.Generate a commitment hash from the name they want to register and a secret value.2.Submit the commitment hash from #1 to the controller.3.Wait for at least 1 minute, but no longer than 24 hours.4.Submit a registration request for the name, along with the secret value from #1.This process ensures that registrations cannot be frontrun unless the attacker is able to censor the user's transactions for at least 1 minute.ExamplesName RegistrationThe below example demonstrates the steps required to register a name.web3.jsconst controller = web3.eth.contract(controller_abi).at(controller_address);async function register(name, owner, duration) { // Generate a random value to mask our commitment const random = new Uint8Array(32); crypto.getRandomValues(random); const salt = ""0x"" + Array.from(random).map(b => b.toString(16).padStart(2, ""0"")).join(""""); // Submit our commitment to the smart contract const commitment = await controller.makeCommitment(name, owner, salt); const tx = await controller.commit(commitment); // Add 10% to account for price fluctuation; the difference is refunded. const price = (await controller.rentPrice(name, duration)) * 1.1; // Wait 60 seconds before registering setTimeout(async () => { // Submit our registration request await controller.register(name, owner, duration, salt, {value: price}); }, 60000);}For clarity, this example is written using async rather than callbacks. As a result, this example works in web3 1.0.x; note that it will not work in the web3 injected by MetaMask, as this presently is an older version lacking async support.Read OperationsGet Minimum Commitment Ageuint constant public MIN_COMMITMENT_AGE;This public constant provides the minimum commitment age, in seconds. A commitment can only be revealed after at least this many seconds have passed since it was mined.DApps should fetch this constant rather than hardcoding the current value, as it's possible it will change with future releases.Get Maximum Commitment Ageuint constant public MAX_COMMITMENT_AGE;This public constant provides the maximum commitment age, in seconds. A commitment that was mined more than this number of seconds ago is no longer valid, and cannot be used to register a name.DApps should fetch this constant rather than hardcoding the current value, as it's possible it will change with future releases.Get Minimum Registration Durationuint constant public MIN_REGISTRATION_DURATION;This public constant provides the minimum registration duration, in seconds. Registrations for less than this duration will be rejected.DApps should fetch this constant rather than hardcoding the current value, as it's possible it will change with future releases.Get Commitment Timestampmapping(bytes32=>uint) public commitments;commitments stores a mapping from each submitted to commitment to the timestamp at which it was made. Callers wishing to validate that a commitment is valid before submitting a registration transaction should check this map first.Get Rent Pricefunction rentPrice(string name, uint duration) view public returns(uint);rentPrice returns the cost, in wei, to register or renew the provided name for the provided duration, in seconds. Callers should note that this price may vary over time, particularly if the pricing oracle is relying on a fiat price conversion.Callers should use this function to obtain registration costs to display to the user rather than calculating them internally, as future changes to the pricing oracle may result in different pricing schemes, with registration cost-per-year depending on name length, registration duration, or other variables.Check Name Validityfunction valid(string name) public view returns(bool);valid returns true iff name is valid for registration with this controller (eg, it meets length requirements).Check Name Availabilityfunction available(string name) public view returns(bool);available returns true iff the name is both valid and available for registration by this controller. Under the hood, this call uses the valid function (above) and the available function on the registrar contract, which checks for availability in both the legacy ENS registrar and current ENS registrar.Callers should use this function to check if a name is available for registration, rather than the available function on the registrar contract, which does not check name length.Calculate Commitment Hashfunction makeCommitment(string name, address owner, bytes32 secret) pure public returns(bytes32);makeCommitment generates and returns a commitment hash from a name label (eg, 'myname', not 'myname.eth') owner, and secret value.Write OperationsSubmit Commitmentfunction commit(bytes32 commitment) public;commit submits a precommitment generated by calling makeCommitment.Register Namefunction register(string name, address owner, uint duration, bytes32 secret) public payable;register registers a name. A valid registration request must meet the following criteria:1.available(name) == true.2.duration >= MIN_REGISTRATION_DURATION.3.secret identifies a valid commitment (eg, commitments[makeCommitment(name, secret)] exists and is between 1 minute and 24 hours old.4.msg.value >= rentPrice(name, duration).Because the rent price may vary over time, callers are recommended to send slightly more than the value returned by rentPrice - a premium of 5-10% will likely be sufficient. Any excess funds are returned to the caller.Emits the following event on a successful call:event NameRegistered(string name, bytes32 indexed label, address indexed owner, uint cost, uint expires);A successful call also results in the Registrar emitting a Name Registered Event, and the ENS registry emitting a New Owner Event.Extend Name Registrationfunction renew(string name, uint duration) external payable;renew renews a name, extending the name's expiration by duration seconds. This function can be called by anyone, as long as sufficient funds are provided. Because the rent price may vary over time, callers are recommended to send slightly more than the value returned by rentPrice - a premium of 5-10% will likely be sufficient. Any excess funds are returned to the caller.Emits the following event on a successful call:event NameRenewed(string name, bytes32 indexed label, uint cost, uint expires);A successful call also results in the Registrar emitting a Name Renewed Event.PreviousRegistrarNext - Contract API ReferenceDNS RegistrarLast modified 1yr agoCopy linkEdit on GitHubOn this pageExamplesName RegistrationRead OperationsGet Minimum Commitment AgeGet Maximum Commitment AgeGet Minimum Registration DurationGet Commitment TimestampGet Rent PriceCheck Name ValidityCheck Name AvailabilityCalculate Commitment HashWrite OperationsSubmit CommitmentRegister NameExtend Name Registration "
35,mains v governance governance proposals term 3 ep3.4 fund the endowment,"mains v governance governance proposals term 3 ep3.4 fund the endowment.   [EP3.4] [Executable] Fund the Endowment (first tranche) - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1Term 2Term 3[EP3.1.1] [Social] Q1/Q2 2023 Funding Request: ENS Ecosystem Working Group[EP3.1.2] [Social] Q1/Q2 2023 Funding Request: Meta-Governance Working Group[EP3.1.3] [Social] Q1/Q2 2023 Funding Request: Public Goods Working Group[EP3.2] [Executable] Q1/Q2 2023 Working Group Funding[EP3.3] [Executable] Sell ETH to USDC[EP3.4] [Executable] Fund the Endowment (first tranche)Powered By GitBook[EP3.4] [Executable] Fund the Endowment (first tranche)[EP 3.4][Executable] Fund the Endowment (first tranche)StatusDraftStatusActiveDiscussion Thread​Discuss​Votes​Onchain​Authors@karpatkey, @SteakhouseAbstractFirst tranche to fund the Endowment with 16,000 ETH sent from ENS DAO to the ENS Endowment and an additional 150 ETH sent to the Meta-Gov Pod to account for karpatkey and Steakhouse monthly fees.Motivation​Approximately one year ago, the ENS DAO initiated a process to ensure the sustainability of ENS as a self-funded public good for the long term. The RFP process (EP2.2.4), on which karpatkey, together with Steakhouse, made a proposal, resulted in the selection of karpatkey (EP2.2.5).For reference, the proposal submitted by karpatkey was for an initial size of $52,000,000 USD (converted to 32,000 ETH for operational purposes as the Endowment will be founded in ETH and to account for the reduction of the pool according to EP3.3). The proposal included performance fees of 10% above the investment's reference currency, with $ for $-related investments and ETH for ETH-related investments, as well as an annual fee of 0.5% based on the size of the endowment, payable entirely in ETH on a monthly basis.Karpatkey engaged in discussions with the ENS community to seek feedback on strategies and the ramp-up process, both here and here. Feedback was received regarding concerns about the required time to establish trust and the need to limit executive votes for funding. Karpatkey believes that a balanced approach, such as funding 50% on day one and the remaining 50% after six months, would be a suitable tradeoff for all parties. To address questions and concerns raised, a FAQ was provided.In the meantime, karpatkey made progress on the setup of the Endowment safe, which has been seeded to display target positions. The necessary managing permissions have been defined and audits from Ackee and Sub 7 have been completed. On its part, Steakhouse has started work on providing open source accounting and financial services, as well as a monitoring Dune dashboard, both of which are work in progress.If the Endowment is funded through this first tranche, karpatkey will allocate the funds as follows:#ProtocolAssetsStrategyShare per StratAllocated FundsShare of PortfolioProj. APRProj. RevPool TVL (MM)1Compound v2DAIUSD - neutral50%$5,506,97120.61%2.21%$121,704$5602Compound v2USDCUSD - neutral50%$5,506,97120.61%2.16%$118,951$6373Aura FinancewstETH - WETHETH - neutral40%$6,282,42323.51%10.38%$652,116$2084CurvestETH - ETHETH - neutral40%$6,282,42323.51%5.38%$337,994$1,6535Stakewise/ Uniswap v3sETH2 - ETH Range: 1.000 - 1.006ETH - neutral20%$3,141,21211.76%12.77%$401,133$65​Total​$26,720,000100.00%6.11%$1,631,897​​​Specification1.Transfer 16,000 ETH to the Endowment (0x4F2083f5fBede34C2714aFfb3105539775f7FE64)2.Transfer 150 ETH to ens-metagov.pod.xyz (0x91c32893216dE3eA0a55ABb9851f581d4503d39b) to cover Endowment fees for Q1/Q2Addresses:0xFe89cc7aBB2C4183683ab71653C4cdc9B02D44b7 - ENS DAO0x4F2083f5fBede34C2714aFfb3105539775f7FE64 - endowment0x91c32893216dE3eA0a55ABb9851f581d4503d39b - ens-metagov.pod.xyzTransactionsAddressValueFunctionArgumentValue0x4F2083f5fBede34C2714aFfb3105539775f7FE6416,000 ETH​​​0x91c32893216dE3eA0a55ABb9851f581d4503d39b150 ETH​​​Previous[EP3.3] [Executable] Sell ETH to USDCLast modified 9d agoCopy linkEdit on GitHubOn this page[EP 3.4][Executable] Fund the Endowment (first tranche)AbstractMotivationSpecificationTransactions "
36,mains v governance governance proposals term 1 ep12 working group rules,"mains v governance governance proposals term 1 ep12 working group rules.   [EP1.8] [Social] Working Group Rules - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1[EP1.1] [Executable] Set the temporary premium start price to $100,000[EP1.2.1] [Social] Removal of Brantly Millegan as Director of the ENS Foundation[EP1.2.2] [Social] Election of a new Director of The ENS Foundation[EP1.3.1] [Executable] Q1 & Q2 2022 Meta-Governance WG Budget[EP1.3.2] [Executable] Q1 & Q2 2022 ENS Ecosystem WG Budget[EP1.3.3] [Executable] Q1 & Q2 2022 Community WG Budget[EP1.3.4] [Executable] Q1 & Q2 2022 Public Goods WG Budget[EP1.4] [Executable] Reimburse True Names for expenses and tax obligations incurred for the DAO[EP1.5][Executable] Change to Exponential Premium Price Oracle[EP1.6] [Executable] A DAO-Governed Identity Server[EP1.7] [Executable] End the $ENS and EP2 airdrops[EP1.8] [Social] Working Group Rules[EP1.9] [Executable] Fund the Protocol Guild pilot with 200,000 $ENSTerm 2Term 3Powered By GitBook[EP1.8] [Social] Working Group RulesProposes to repeal the working group rules passed in EP4 and replace those rules with the working group rules specified in this proposal.StatusPassedDiscussion Thread​Discuss​Votes​Snapshot​Authors​alisha.eth​Note: This was previously numbered EP12.AbstractThis is a proposal to repeal the working group rules passed in EP4 and replace those rules with working group rules specified in this proposal for the Second Term of 2022 and all Terms thereafter.The working group rules specified in this proposal add more details about Steward responsibilities and the management of working group funds, as well as introducing the requirement of each working group to appoint a lead steward.The specification below also introduces a rule to appoint a new DAO Secretary, responsible for managing working relationships and communications across working groups as well as performing administrative duties for the DAO.SpecificationWorking Groups Rules1.Formation of Working Groups1.To create a new working group, a social proposal, as defined by the ENS governance documentation (‘Social Proposal’), must be put forward and passed by the DAO.2.A Social Proposal to create a new working group must demonstrate that the new working group is needed and the work cannot be undertaken within an existing working group.2.Dissolution of Working Groups1.A working group can be dissolved by passing a Social Proposal requesting the dissolution of a working group or working groups.2.If an active proposal is put forward to dissolve a working group, all working group funds, including outgoing payments, within that working group, are to be frozen with immediate effect, pending the outcome of that vote.3.Upon the dissolution of a working group, any and all unspent working group funds from that working group, at the time of dissolution, must be immediately returned to the DAO treasury, without delay.3.Working Group Stewards1.Each working group shall be managed by three stewards (hereafter a ‘Steward’ or ‘Stewards’).2.Stewards will be elected to serve within working groups for a set period of time (hereafter known as a ‘Term’ or ‘Terms’).3.There are two Terms each calendar year:1.The first Term commences at 9am UTC on January 1 each year and ends immediately prior to the commencement of the second Term (‘First Term’); and2.The second Term commences at 9am UTC on July 1 each year and ends immediately prior to the commencement of the First Term of the following year (‘Second Term’).4.Stewards are responsible for overseeing the operation of working groups in accordance with these rules and the ENS DAO constitution.5.The responsibilities of Stewards include, but are not limited to:1.Requesting working group funds from the DAO in accordance with these rules;2.Approving the creation of sub-groups or workstreams within a working group to undertake work and/or carry out specific projects or tasks;3.Dissolving sub-groups or workstreams within a working group;4.Using discretion to make working group funds available to sub-groups, workstreams, or contributors within a working group;5.Using discretion to disburse working group funds to people and/or projects in accordance with the ENS DAO constitution; and6.Acting as keyholders of working group multi-sigs.4.Steward Eligibility and Nominations1.Any individual is eligible to nominate themselves to be a Steward of a working group within the DAO (‘Eligible Person’ or ‘Eligible Persons’).2.To be eligible to be included in the ballot for First Term elections of a given year, Eligible Persons must nominate themselves between 9am UTC on December 6 and 9am UTC on December 9 (‘First Term Nomination Window’).3.To be eligible to be included in the ballot for Second Term elections of a given year, Eligible Persons must nominate themselves between 9am UTC on June 6 and 9am UTC on June 9 (‘Second Term Nomination Window’).4.An Eligible Person may nominate themselves to become a Steward of a working group or working groups during the First Term Nomination Window or the Second Term Nomination Window (each a ‘Nomination Window’), by meeting the requirements set out in a call for nominations posted in the relevant working group category of the ENS governance forum.5.An Eligible Person who completes the steps outlined in rule 4.4 above during a Nomination Window and receives 10,000 signed votes to support their nomination will be included in the ballot as a nominee in the election for Stewards that takes place following that Nomination Window (‘Nominee’).5.Steward Elections1.Elections for working group Stewards for the First Term of a given year will take place by a vote of governance token holders using signed messages and will be open for 120 hours, commencing at 9am UTC on December 10 each year (‘First Term Election Window’).2.Elections for working group Stewards for the Second Term of a given year will take place by a vote of governance token holders using signed messages and will be open for 120 hours, commencing at 9am UTC on June 10 each year (‘Second Term Election Window’).3.The top-ranked Nominees from each working group vote held during a First Term Election Window or a Second Term Election Window (each an 'Election Window'), will fill any available positions for the role of Steward for those working groups for the Term immediately following an Election Window, based on the order in which they are ranked in each working group vote.4.A Nominee elected to serve as a Steward may not take up the role of Steward for more than two working groups during a single Term.6.Delay of Nominations or Elections1.In the event that nominations or elections for Stewards take place after a Nomination Window or after an Election Window, the nomination process and/or elections shall take place, as otherwise prescribed in rules 4 and 5 above, as soon as is practicable after the missed Nomination Window or missed Election Window.2.In the event that an election takes place outside of an Election Window and after the commencement date of a new Term, outgoing Stewards from the previous Term shall stay in their positions as working group Stewards until immediately prior to 9am UTC the day following the end of the election, which, for the avoidance of doubt, is 120 hours after voting in those elections commenced.3.In the event that an election takes place outside of an Election Window and after the commencement date of a new Term, newly elected Stewards will assume the responsibilities of stewardship within working groups at 9am UTC the day following the end of the election, as defined in rule 6.2 above, for the remainder of that Term.7.Removal and Replacement of Stewards1.Stewards may be removed at any time by:1.a Social Proposal passed by the DAO; or2.a simple indicative majority vote among Stewards of all working groups, with the outcome of that vote communicated in the relevant working group category of the ENS governance forum.2.Stewards may step down from their position at any time by communicating their intention to step down in the ENS governance forum.3.In the event that a Steward is removed, steps down, or is unable to continue as a Steward, for whatever reason, prior to the end of a Term, a new election must be held to fill any vacant Steward positions, in accordance with rule 6 above.8.Lead Stewards1.Each working group must appoint a lead Steward within the first five days of a Term (hereafter a 'Lead Steward' or 'Lead Stewards').2.Only current elected Stewards of a working group are eligible to serve as Lead Stewards within a given working group.3.Lead Stewards may be appointed or removed from that role at any time by a simple indicative majority vote among the Stewards of a working group, with the outcome of that vote communicated in the relevant working group category of the ENS governance forum.4.In the event that a Lead Steward steps down from the position or is removed as a Lead Steward before the end of a Term in accordance with rule 8.3 above, a new Lead Steward must be appointed within five calendar days.5.A Steward who is appointed to serve as a Lead Steward of a working group will remain in that position, as Lead Steward, from the date of appointment until the end of their elected Term as a Steward or until they are removed as a Lead Steward in accordance with rule 8.3 above or until they are removed as a Steward in accordance with rule 7 above.6.Lead Stewards are responsible for the operational management and administration of working groups and are expected to provide regular updates to the DAO in the ENS governance forum related to working group progress, achievements, and challenges.7.The responsibilities of Lead Stewards include, but are not limited to:1.Acting as a representative of a working group;2.Managing resource requests from sub-groups, workstreams, and contributors within a working group;3.Initiating the disbursement of working group funds on an as-needed basis;4.Providing reports of working group spending in the ENS governance forum; and5.Maintaining open communications with DAO participants in the ENS governance forum.9.DAO Secretary1.At the start of each Term, the current Stewards of each working group shall collaborate to appoint an individual who will serve as the secretary of the DAO (hereafter 'Secretary' or 'Secretaries').2.The Secretary may be appointed or removed from that role at any time by a majority vote of all elected Stewards in a given Term with the outcome of that vote communicated in the ENS governance forum.3.The Secretary will remain in that position, as Secretary of the DAO, from the date of appointment until the end of a given Term or until the date at which they are removed from that position in accordance with rule 9.2 above.4.Secretaries are eligible to receive fair compensation for their work as Secretary of the DAO.5.Compensation for the Secretary of the DAO is to be paid by the Meta-Governance Working Group using funds requested in accordance with rule 10 below.6.Any individual is eligible to be appointed as the Secretary of the DAO, including past and present working group Stewards.7.The Secretary is responsible for managing working relationships and communications across working groups as well as performing administrative duties for the DAO.8.The responsibilities of the Secretary include, but are not limited to:1.Managing a DAO-wide calendar;2.Coordinating and attending working group meetings where possible and ensuring meeting summaries are posted in the ENS governance forum;3.Assisting Stewards with coordination challenges within working groups; and4.Acting as a multi-sig keyholder for each working group.10.Working Group Funds1.To request working group funds, Stewards of all working groups will collaborate to submit an active executable proposal, as defined by the ENS governance documentation ('Collective Proposal'), to the DAO during the months of January, April, July, and October each calendar year (each a ‘Funding Window’).1.In order for a working group to have a funding request included in a Collective Proposal submitted to the DAO during a Funding Window, the funding request must have passed as a Social Proposal in the same Funding Window.2.In the case of an emergency, where working group funds are needed by a working group outside of a Funding Window, an executable proposal, as defined by the ENS governance documentation, may be submitted at any time by a Steward of a working group to request funds from the DAO.2.Working group funds requested and approved in accordance with rule 10.1 above are to be paid out into separate working group multi-sigs controlled by the DAO.3.Each working group multi-sig must have four keyholders, made up of three current elected Stewards for that working group and the Secretary of the DAO for that Term, with no other keyholders permitted.4.Working group funds may be disbursed from working group multi-sigs with three-of-four keyholder signing.5.Stewards of a given working group shall have the discretion to reallocate funds approved in a Collective Proposal where appropriate and where it is not in conflict with any rules of the DAO, DAO bylaws, or the ENS DAO constitution.11.Compensation for Stewards and Lead Stewards1.Stewards are eligible to receive fair compensation for their work as a Steward or Lead Steward in the DAO.2.All requests for Steward or Lead Steward compensation must be detailed in a Collective Proposal for working group funds submitted to the DAO in accordance with rule 10.1 above.3.Stewards may not receive compensation for their role as a Steward or Lead Steward outside of that compensation expressly provided for in a Collective Proposal submitted to the DAO in accordance with rule 10.1 above.12.Amendments1.These rules may be amended at any time by passing a Social Proposal.Next StepsThis vote will be a single choice vote. You may vote 'for' or 'against' the proposal, or choose to abstain from the vote.By voting 'for' this proposal, you are voting in favor of repealing the working group rules passed in EP4 and replacing them with the working group rules provided in the specification of this proposal.Previous[EP1.7] [Executable] End the $ENS and EP2 airdropsNext[EP1.9] [Executable] Fund the Protocol Guild pilot with 200,000 $ENSLast modified 6mo agoCopy linkEdit on GitHubOn this pageAbstractSpecificationWorking Groups RulesNext Steps "
37,mains contract api reference subgraphdata entities#newowner,"mains contract api reference subgraphdata entities#newowner.   Entities - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookEntitiesEntities​Domain​​DomainEvent​​Transfer​​NewOwner​​NewResolver​​NewTTL​​Account​​Registration​​RegistrationEvent​​NameRegistered​​NameRenewed​​NameTransferred​​Resolver​​ResolverEvent​​AddrChanged​​MulticoinAddrChanged​​NameChanged​​AbiChanged​​PubKeyChanged​​TextChanged​​ContentHashChanged​​InterfaceChanged​​AuthorisationChanged​DomainDescription:FieldTypeDescriptionidID!The namehash of the namenameStringThe human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)labelNameStringThe human readable label name (imported from CSV), if knownlabelhashByteskeccak256(labelName)parentDomainThe namehash (id) of the parent namesubdomains​Domain!​Can count domains from length of arraysubdomainCountInt!The number of subdomainsresolvedAddressaccountAddress logged from current resolver, if anyownerAccount!​resolverResolver​ttlBigInt​isMigratedBoolean!​createdAtBigInt!​events​DomainEvent!​​TransferDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​NewOwnerDescription:FieldTypeDescriptionidID!​parentDomainDomain!​domainDomain!​TransactionIDBytes!​ownerAccount!​NewResolverDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​resolverResolver!​NewTTLDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​transactionIDBytes!​ttlBigInt!​AccountDescription:FieldTypeDescriptionidID!​domain​Domain!​​registration​Registration!​​RegistrationDescription:FieldTypeDescriptionidID!​domainDomain​registrationDateBigInt!​expiryDateBigInt!​costBigInt!​registrantAccount!​labelNameString​events​RegistrationEven!​​RegistrationEventDescription:FieldTypeDescriptionidID!​registrationRegistrationEvent​blockNumberInt!​transactionIDBytes!​NameRegisteredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​registrantAccount!​expiryDateBigInt!​NameRenewedDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​expiryDateBigInt!​NameTransferredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​newOwnerAccount!​ResolverDescription:FieldTypeDescriptionidID!Concatenation of resolver address and namehashdomainDomain​addressBytes!Address of resolver contractaddrAccountCurrent value of addr record (per events)contenHashBytesContent hash, in binary formattexts[String!]Set of observed text record keyscointTypes[BigInt!]Set of observed SLIP-44 coin typesevents​ResolverEvent!​​ResolverEventDescription:FieldTypeDescriptionidID!Concatenation of block number and log IDresolverResolver!Used to derive relationships to ResolversblockNumberInt!​transactionIDBytes!​AddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​addrAccount!​MulticoinAddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​coinTypeBigInt!​addrBytes!​NameChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​nameString!​AbiChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​contentTypeBigInt!​PubkeyChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​xBytes!​yBytes!​TextChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​keyString!​valueString​ContenthashChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​hashBytes!​InterfaceChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​interfacedIDBytes!​implementerBytes!​AuthorisationChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​ownerBytes!​targetBytes!​isAuthorizedBoolean!​Contract API Reference - PreviousSubgraphNextQuery ExamplesLast modified 6mo agoCopy linkEdit on GitHubOn this pageEntitiesDomainTransferNewOwnerNewResolverNewTTLAccountRegistrationRegistrationEventNameRegisteredNameRenewedNameTransferredResolverResolverEventAddrChangedMulticoinAddrChangedNameChangedAbiChangedPubkeyChangedTextChangedContenthashChangedInterfaceChangedAuthorisationChanged "
38,mains v governance governance proposals term 1 ep9 executable change to exponential premium price oracle,"mains v governance governance proposals term 1 ep9 executable change to exponential premium price oracle.   [EP1.5][Executable] Change to Exponential Premium Price Oracle - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1[EP1.1] [Executable] Set the temporary premium start price to $100,000[EP1.2.1] [Social] Removal of Brantly Millegan as Director of the ENS Foundation[EP1.2.2] [Social] Election of a new Director of The ENS Foundation[EP1.3.1] [Executable] Q1 & Q2 2022 Meta-Governance WG Budget[EP1.3.2] [Executable] Q1 & Q2 2022 ENS Ecosystem WG Budget[EP1.3.3] [Executable] Q1 & Q2 2022 Community WG Budget[EP1.3.4] [Executable] Q1 & Q2 2022 Public Goods WG Budget[EP1.4] [Executable] Reimburse True Names for expenses and tax obligations incurred for the DAO[EP1.5][Executable] Change to Exponential Premium Price Oracle[EP1.6] [Executable] A DAO-Governed Identity Server[EP1.7] [Executable] End the $ENS and EP2 airdrops[EP1.8] [Social] Working Group Rules[EP1.9] [Executable] Fund the Protocol Guild pilot with 200,000 $ENSTerm 2Term 3Powered By GitBook[EP1.5][Executable] Change to Exponential Premium Price OracleProposes to deploy Exponential Price Oracle Contract to replace the current Linear Price Oracle Contract.StatusExecutedVotes​Snapshot, passed March 21, 2022 Tally, passed April 26, 2022AuthorsJeff LauNote: This was previously numbered EP9.AbstractIn the past we deployed the Linear Premium Oracle as a way to create a distribution mechanism that did not involve gas auctions and bots. This was largely successful and those who wanted a recently expired name could participate in the dutch auction and not have to compete on gas or with bots. Recently with the popularity of ENS increasing, the demand and the price people are willing to pay for these premium names has increased. In response to this TNL quickly drafted a short-term solution to raise the premium to 100k, which we felt was the upper limit for what a linear price decay curve could handle.There are a couple reasons for this:1.On a linear curve, if the price is too high the price decreases too fast and the UX is bad for a user who wants an exact price (especially at the lower end of the curve)2.If you extend the time period out, the premium lasts for too long. E.g. If we made it 1 million USD and we wanted a similar price decay speed as 100k, we would need to run it for 10 months, which seems unreasonable.We can see from the data below, even with the new 100k premium, we have already had a 5-7 domains go for maximum, or close to maximum premium. If a domain sells for the actual premium, it means the dutch auction is not doing its job and so we need to deploy a long-term solution for dealing with premium pricing.Row	label	event_timestamp	premium	1	bbc 2022-01-30 17:46:03 UTC 100230.753218372792	mets 2022-02-04 17:16:22 UTC 100082.498473193993	fbi 2022-02-05 06:02:31 UTC 99894.006324724854	fly 2022-02-04 18:49:00 UTC 99747.226402476215	ups 2022-02-05 07:46:24 UTC 98822.147478085396	dog 2022-02-06 16:19:05 UTC 92950.092087527717	ubs 2022-02-01 15:31:35 UTC 89633.150810633678	ubi 2022-02-19 17:06:17 UTC 72161.563287716539	punks 2022-02-16 00:15:44 UTC 59153.16614633610	omg 2022-02-24 16:05:57 UTC 33214.42499419019The long-term solution would be to change the actual curve to something that could start at a very high price, would decrease rapidly at the beginning and slow down at the end so you have better UX for users. And therefore this proposal is to deploy an exponential price curve, that does exactly this. This would allow fairer bidding on both high and low priced names.Contract Codehttps://github.com/ensdomains/ens-contracts/blob/master/contracts/ethregistrar/ExponentialPremiumPriceOracle.solSpecificationCall setPriceOracle on controller.ens.eth, passing in the address of the deployed ExponentialPremiumPriceOracle (TBD).​Previous[EP1.4] [Executable] Reimburse True Names for expenses and tax obligations incurred for the DAONext[EP1.6] [Executable] A DAO-Governed Identity ServerLast modified 6mo agoCopy linkEdit on GitHubOn this pageAbstractContract CodeSpecification "
39,mains contract api reference subgraphdata entities#resolverevent,"mains contract api reference subgraphdata entities#resolverevent.   Entities - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookEntitiesEntities​Domain​​DomainEvent​​Transfer​​NewOwner​​NewResolver​​NewTTL​​Account​​Registration​​RegistrationEvent​​NameRegistered​​NameRenewed​​NameTransferred​​Resolver​​ResolverEvent​​AddrChanged​​MulticoinAddrChanged​​NameChanged​​AbiChanged​​PubKeyChanged​​TextChanged​​ContentHashChanged​​InterfaceChanged​​AuthorisationChanged​DomainDescription:FieldTypeDescriptionidID!The namehash of the namenameStringThe human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)labelNameStringThe human readable label name (imported from CSV), if knownlabelhashByteskeccak256(labelName)parentDomainThe namehash (id) of the parent namesubdomains​Domain!​Can count domains from length of arraysubdomainCountInt!The number of subdomainsresolvedAddressaccountAddress logged from current resolver, if anyownerAccount!​resolverResolver​ttlBigInt​isMigratedBoolean!​createdAtBigInt!​events​DomainEvent!​​TransferDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​NewOwnerDescription:FieldTypeDescriptionidID!​parentDomainDomain!​domainDomain!​TransactionIDBytes!​ownerAccount!​NewResolverDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​resolverResolver!​NewTTLDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​transactionIDBytes!​ttlBigInt!​AccountDescription:FieldTypeDescriptionidID!​domain​Domain!​​registration​Registration!​​RegistrationDescription:FieldTypeDescriptionidID!​domainDomain​registrationDateBigInt!​expiryDateBigInt!​costBigInt!​registrantAccount!​labelNameString​events​RegistrationEven!​​RegistrationEventDescription:FieldTypeDescriptionidID!​registrationRegistrationEvent​blockNumberInt!​transactionIDBytes!​NameRegisteredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​registrantAccount!​expiryDateBigInt!​NameRenewedDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​expiryDateBigInt!​NameTransferredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​newOwnerAccount!​ResolverDescription:FieldTypeDescriptionidID!Concatenation of resolver address and namehashdomainDomain​addressBytes!Address of resolver contractaddrAccountCurrent value of addr record (per events)contenHashBytesContent hash, in binary formattexts[String!]Set of observed text record keyscointTypes[BigInt!]Set of observed SLIP-44 coin typesevents​ResolverEvent!​​ResolverEventDescription:FieldTypeDescriptionidID!Concatenation of block number and log IDresolverResolver!Used to derive relationships to ResolversblockNumberInt!​transactionIDBytes!​AddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​addrAccount!​MulticoinAddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​coinTypeBigInt!​addrBytes!​NameChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​nameString!​AbiChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​contentTypeBigInt!​PubkeyChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​xBytes!​yBytes!​TextChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​keyString!​valueString​ContenthashChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​hashBytes!​InterfaceChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​interfacedIDBytes!​implementerBytes!​AuthorisationChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​ownerBytes!​targetBytes!​isAuthorizedBoolean!​Contract API Reference - PreviousSubgraphNextQuery ExamplesLast modified 6mo agoCopy linkEdit on GitHubOn this pageEntitiesDomainTransferNewOwnerNewResolverNewTTLAccountRegistrationRegistrationEventNameRegisteredNameRenewedNameTransferredResolverResolverEventAddrChangedMulticoinAddrChangedNameChangedAbiChangedPubkeyChangedTextChangedContenthashChangedInterfaceChangedAuthorisationChanged "
40,mains v governance governance proposals term 2 ep14 funding true names ltd,"mains v governance governance proposals term 2 ep14 funding true names ltd.   [EP2.1] [Executable] Funding True Names Ltd - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1Term 2[EP2.1] [Executable] Funding True Names Ltd[EP2.2.1] [Executable] Q3 & Q4 2022 Meta-Governance WG Budget[EP2.2.2] [Executable] Q3 & Q4 2022 Ecosystem WG Budget[EP2.2.3] [Executable] Q3 & Q4 2022 Public Goods WG Budget[EP2.2.4] [Social] ENS Endaoment RFP[EP2.2.5] [Social] Selection of an ENS endowment fund managerTerm 3Powered By GitBook[EP2.1] [Executable] Funding True Names Ltd[Executable] Funding True Names LtdStatusExecutedDiscussion Thread​Discuss​Votes​Onchain​Note: This was previously numbered EP14.AbstractTrue Names Ltd (“TNL”) developed the Ethereum Name Service (“ENS”) protocol, continues to manage the development of the ENS Protocol and solely focuses on this project. Incubated at the Ethereum Foundation in 2017, TNL spun out in 2018 with the charge of designing and deploying THE next generation naming service. TNL is now a growing team of web3 enthusiasts from across the globe working together to support the ENS Ecosystem that now has a passionate community that has registered over 1 million ENS names and uses more than 500 integrations.In 2021, TNL initiated the creation of the ENS DAO with the goal of 1) furthering the development of the ENS Protocol and 2) funding public goods projects.In consideration of the work completed thus far this calendar year and the work in the months and years to come, per Article III of the ENS Constitution, True Names Ltd respectfully requests an evergreen grant stream that will allow the organization to continue the development and improvement of the ENS Protocol. For Calendar Year 2022, this request will amount to $4,197,500 USDC which is equivalent to a daily stream of $11,500 USDC. In Q1 of each year, TNL or the ENS Dao may make requests to alter and/or terminate this evergreen grant stream.SpecificationWe request that the ENS DAO approve a daily grant of $11,500 USDC to True Names Ltd, backdated to January 1st, 2022.This will be accomplished by approving a dedicated token streaming contract at 0xB1377e4f32e6746444970823D5506F98f5A04201 to spend USDC on behalf of the DAO.TransactionsAddressValueFunctionArgumentValue0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB480approvespender0xB1377e4f32e6746444970823D5506F98f5A04201value0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff​​​PreviousTerm 2Next[EP2.2.1] [Executable] Q3 & Q4 2022 Meta-Governance WG BudgetLast modified 28d agoCopy linkEdit on GitHubOn this page[Executable] Funding True Names LtdAbstractSpecificationTransactions "
41,mains dapp developer guide registering and renewing names,"mains dapp developer guide registering and renewing names.   Registering & Renewing Names - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookRegistering & Renewing NamesWhen users want to obtain a domain for the first time, they must interact with a registrar. Registrars are smart contracts that own a domain, and have a defined process for handing out subdomains. The registrar a user needs to interact with depends on the domain they want to obtain; for instance, a user wanting a .eth name will have to interact with the .eth registrar. Each registrar defines its own API for name registrations (and renewals, where appropriate).At present, there are no libraries for interacting with registrars; DApps wishing to do so must interact with the registrar contract using a generic Ethereum library such as web3.js or web3.py. See the Contract API Reference for details on each registrar's interface.Deployed Registrars.eth: The Permanent Registrar..test (testnets only): The test registrar..addr.reverse: The reverse registrar.Dapp Developer Guide - PreviousManaging NamesNext - Dapp Developer GuideENS Front-End Design GuidelinesLast modified 1yr agoCopy linkEdit on GitHub "
42,mains contract api reference subgraphdata entities#interfacechanged,"mains contract api reference subgraphdata entities#interfacechanged.   Entities - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookEntitiesEntities​Domain​​DomainEvent​​Transfer​​NewOwner​​NewResolver​​NewTTL​​Account​​Registration​​RegistrationEvent​​NameRegistered​​NameRenewed​​NameTransferred​​Resolver​​ResolverEvent​​AddrChanged​​MulticoinAddrChanged​​NameChanged​​AbiChanged​​PubKeyChanged​​TextChanged​​ContentHashChanged​​InterfaceChanged​​AuthorisationChanged​DomainDescription:FieldTypeDescriptionidID!The namehash of the namenameStringThe human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)labelNameStringThe human readable label name (imported from CSV), if knownlabelhashByteskeccak256(labelName)parentDomainThe namehash (id) of the parent namesubdomains​Domain!​Can count domains from length of arraysubdomainCountInt!The number of subdomainsresolvedAddressaccountAddress logged from current resolver, if anyownerAccount!​resolverResolver​ttlBigInt​isMigratedBoolean!​createdAtBigInt!​events​DomainEvent!​​TransferDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​NewOwnerDescription:FieldTypeDescriptionidID!​parentDomainDomain!​domainDomain!​TransactionIDBytes!​ownerAccount!​NewResolverDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​resolverResolver!​NewTTLDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​transactionIDBytes!​ttlBigInt!​AccountDescription:FieldTypeDescriptionidID!​domain​Domain!​​registration​Registration!​​RegistrationDescription:FieldTypeDescriptionidID!​domainDomain​registrationDateBigInt!​expiryDateBigInt!​costBigInt!​registrantAccount!​labelNameString​events​RegistrationEven!​​RegistrationEventDescription:FieldTypeDescriptionidID!​registrationRegistrationEvent​blockNumberInt!​transactionIDBytes!​NameRegisteredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​registrantAccount!​expiryDateBigInt!​NameRenewedDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​expiryDateBigInt!​NameTransferredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​newOwnerAccount!​ResolverDescription:FieldTypeDescriptionidID!Concatenation of resolver address and namehashdomainDomain​addressBytes!Address of resolver contractaddrAccountCurrent value of addr record (per events)contenHashBytesContent hash, in binary formattexts[String!]Set of observed text record keyscointTypes[BigInt!]Set of observed SLIP-44 coin typesevents​ResolverEvent!​​ResolverEventDescription:FieldTypeDescriptionidID!Concatenation of block number and log IDresolverResolver!Used to derive relationships to ResolversblockNumberInt!​transactionIDBytes!​AddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​addrAccount!​MulticoinAddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​coinTypeBigInt!​addrBytes!​NameChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​nameString!​AbiChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​contentTypeBigInt!​PubkeyChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​xBytes!​yBytes!​TextChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​keyString!​valueString​ContenthashChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​hashBytes!​InterfaceChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​interfacedIDBytes!​implementerBytes!​AuthorisationChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​ownerBytes!​targetBytes!​isAuthorizedBoolean!​Contract API Reference - PreviousSubgraphNextQuery ExamplesLast modified 6mo agoCopy linkEdit on GitHubOn this pageEntitiesDomainTransferNewOwnerNewResolverNewTTLAccountRegistrationRegistrationEventNameRegisteredNameRenewedNameTransferredResolverResolverEventAddrChangedMulticoinAddrChangedNameChangedAbiChangedPubkeyChangedTextChangedContenthashChangedInterfaceChangedAuthorisationChanged "
43,mains ens improvement proposals ensip 4 support for contract abis,"mains ens improvement proposals ensip 4 support for contract abis.   ENSIP-4: Support for contract ABIs - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsENSIP-1: ENSENSIP-2: Initial Hash RegistrarENSIP-3: Reverse ResolutionENSIP-4: Support for contract ABIsENSIP-5: Text RecordsENSIP-6: DNS-in-ENSENSIP-7: Contenthash fieldENSIP-8: Interface DiscoveryENSIP-9: Multichain Address ResolutionENSIP-10: Wildcard ResolutionENSIP-11: EVM compatible Chain Address ResolutionENSIP-12: Avatar Text RecordsENSIP-13: SAFE Authentication for ENSENSIP-14: On-chain Source ParameterDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookENSIP-4: Support for contract ABIsA mechanism for storing ABI definitions in ENS, for easy lookup of contract interfaces by callers (formerly EIP-205).AuthorNick Johnson <[email protected]>StatusFinalSubmitted2017-02-06AbstractABIs are important metadata required for interacting with most contracts. At present, they are typically supplied out-of-band, which adds an additional burden to interacting with contracts, particularly on a one-off basis or where the ABI may be updated over time. The small size of ABIs permits an alternative solution, storing them in ENS, permitting name lookup and ABI discovery via the same process.ABIs are typically quite compact; the largest in-use ABI we could find, that for the DAO, is 9450 bytes uncompressed JSON, 6920 bytes uncompressed CBOR, and 1128 bytes when the JSON form is compressed with zlib. Further gains on CBOR encoding are possible using a CBOR extension that permits eliminating repeated strings, which feature extensively in ABIs. Most ABIs, however, are far shorter than this, consisting of only a few hundred bytes of uncompressed JSON.This ENSIP defines a resolver profile for retrieving contract ABIs, as well as encoding standards for storing ABIs for different applications, allowing the user to select between different representations based on their need for compactness and other considerations such as onchain access.SpecificationABI encodingsIn order to allow for different tradeoffs between onchain size and accessibility, several ABI encodings are defined. Each ABI encoding is defined by a unique constant with only a single bit set, allowing for the specification of 256 unique encodings in a single uint.The currently recognised encodings are:IDDescription1JSON2zlib-compressed JSON4CBOR8URIThis table may be extended in future through the ENSIP process.Encoding type 1 specifies plaintext JSON, uncompressed; this is the standard format in which ABIs are typically encoded, but also the bulkiest, and is not easily parseable onchain.Encoding type 2 specifies zlib-compressed JSON. This is significantly smaller than uncompressed JSON, and is straightforward to decode offchain. However, it is impractical for onchain consumers to use.Encoding type 4 is CBOR. CBOR is a binary encoding format that is a superset of JSON, and is both more compact and easier to parse in limited environments such as the EVM. Consumers that support CBOR are strongly encouraged to also support the stringref extension to CBOR, which provides significant additional reduction in encoded size.Encoding type 8 indicates that the ABI can be found elsewhere, at the specified URI. This is typically the most compact of the supported forms, but also adds external dependencies for implementers. The specified URI may use any schema, but HTTP, IPFS, and Swarm are expected to be the most common.Resolver profileA new resolver interface is defined, consisting of the following method:function ABI(bytes32 node, uint256 contentType) constant returns (uint256, bytes);The interface ID of this interface is 0x2203ab56.contentType is a bitfield, and is the bitwise OR of all the encoding types the caller will accept. Resolvers that implement this interface must return an ABI encoded using one of the requested formats, or (0, """") if they do not have an ABI for this function, or do not support any of the requested formats.The abi resolver profile is valid on both forward and reverse records.ABI lookup processWhen attempting to fetch an ABI based on an ENS name, implementers should first attempt an ABI lookup on the name itself. If that lookup returns no results, they should attempt a reverse lookup on the Ethereum address the name resolves to.Implementers should support as many of the ABI encoding formats as practical.RationaleStoring ABIs onchain avoids the need to introduce additional dependencies for applications wishing to fetch them, such as swarm or HTTP access. Given the typical compactness of ABIs, we believe this is a worthwhile tradeoff in many cases.The two-step resolution process permits different names to provide different ABIs for the same contract, such as in the case where it's useful to provide a minimal ABI to some callers, as well as specifying ABIs for contracts that did not specify one of their own. The fallback to looking up an ABI on the reverse record permits contracts to specify their own canonical ABI, and prevents the need for duplication when multiple names reference the same contract without the need for different ABIs.CopyrightCopyright and related rights waived via CC0.PreviousENSIP-3: Reverse ResolutionNextENSIP-5: Text RecordsLast modified 1yr agoCopy linkEdit on GitHubOn this pageAbstractSpecificationRationaleCopyright "
44,mains v governance governance proposals term 3 ep3.1.2 social q1 q2 2023 funding request meta governance working group,"mains v governance governance proposals term 3 ep3.1.2 social q1 q2 2023 funding request meta governance working group.   [EP3.1.2] [Social] Q1/Q2 2023 Funding Request: Meta-Governance Working Group - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1Term 2Term 3[EP3.1.1] [Social] Q1/Q2 2023 Funding Request: ENS Ecosystem Working Group[EP3.1.2] [Social] Q1/Q2 2023 Funding Request: Meta-Governance Working Group[EP3.1.3] [Social] Q1/Q2 2023 Funding Request: Public Goods Working Group[EP3.2] [Executable] Q1/Q2 2023 Working Group Funding[EP3.3] [Executable] Sell ETH to USDC[EP3.4] [Executable] Fund the Endowment (first tranche)Powered By GitBook[EP3.1.2] [Social] Q1/Q2 2023 Funding Request: Meta-Governance Working GroupThis is a proposal to request funding for the Meta-Governance Working Group for Q1/Q2 2023.StatusPassedDiscussion Thread​Discuss​Votes​Snapshot​Author​Katherine Wu​AbstractThe Meta-Governance Working Group requests funding of 364,000 USDC, 125 ETH, and 3,500 $ENS from the ENS DAO for Q1/Q2 2023.This funding will be used to support the governance processes of the ENS DAO as well as manage and build infrastructure to support the ENS DAO and Working Groups.This social proposal is submitted to satisfy the requirements set out in Rule 10.1.1 of the Working Group Rules (EP 1.8). If this proposal is passed, the funding request will be included in a collective executable proposal put forward by all three Working Groups.SpecificationTextUSDCETH$ENSMeta-Governance Multisig364,0001253,500DescriptionMeta-Governance Multisig BalanceThe Meta-Governance Working Group is requesting 364,000 USDC, 125 ETH, and 3,500 $ENS.The Meta-Governance Working Group currently has 217,510 USDC, 17 ETH, and 8,940 $ENS in its multi-sigs.If this funding request is approved, the Meta-Governance Working Group multi-sigs will have a total of 581,510 USDC, 142 ETH, and 12,440 $ENS. USDCETH$ENSCarried Forward (from Q3/Q4 2022)217,510178,940Requested (for Q1/Q2 2023)364,0001253,500Total Balance581,51014212,440MetaGovernance Multisig Allocations for Q1/Q2 2023 (with funding request approved)The table below shows the total allocations for the MetaGovernance Working Group multi-sig, and related pods, with funds carried forward from last term (Q3/Q4 2022) along with funds requested in this proposal for this term (Q1/Q2 2023).TextUSDCETH$ENSSteward + Secretary Compensation184,000-3,500Governance88,500321,250DAO Tooling171,000603,000DAO Sponsorship60,00010-Discretionary78,010404,690Total Balance581,51014212,440Allocation of Requested FundsThe 364,000 USDC, 125 ETH, and 3,500 $ENS of funds requested in this proposal will be allocated to the following initiatives/outcomes.TextUSDCETH$ENSSteward + Secretary Compensation184,000-3,500Governance40,00030-DAO Tooling80,00050-DAO Sponsorship60,00010-Discretionary-35-Total Requested Funds364,0001253,500Description of Initiatives/PodsInitiative/PodDescriptionMultisig Signers or Lead SignerSteward + Secretary CompensationWorking Group Steward compensation totaling $144k USDC + 3,000 $ENS plus Secretary compensation of $40k USDCMetaGov stewardsGovernanceFee reimbursements and initiatives related to reducing friction in the governance processMetaGov stewardsDAO ToolingDeveloping interfaces and dashboards to improve the governance process and increase transparency across the DAOalisha.ethDAO SponsorshipSponsoring DAO-specific events such as DAO NYC, DAO Tokyo, and Aragon’s DAO Global HackathonMetaGov stewardsDiscretionaryFunds distributed at the discretion of stewards towards new initiatives + governance experimentsMetaGov stewardsThis proposal was prepared by Katherine Wu, lead steward of the MetaGovernance Working Group.Previous[EP3.1.1] [Social] Q1/Q2 2023 Funding Request: ENS Ecosystem Working GroupNext[EP3.1.3] [Social] Q1/Q2 2023 Funding Request: Public Goods Working GroupLast modified 1mo agoCopy linkEdit on GitHubOn this pageAbstractSpecificationDescription "
45,mains contract api reference subgraphdata entities#account,"mains contract api reference subgraphdata entities#account.   Entities - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookEntitiesEntities​Domain​​DomainEvent​​Transfer​​NewOwner​​NewResolver​​NewTTL​​Account​​Registration​​RegistrationEvent​​NameRegistered​​NameRenewed​​NameTransferred​​Resolver​​ResolverEvent​​AddrChanged​​MulticoinAddrChanged​​NameChanged​​AbiChanged​​PubKeyChanged​​TextChanged​​ContentHashChanged​​InterfaceChanged​​AuthorisationChanged​DomainDescription:FieldTypeDescriptionidID!The namehash of the namenameStringThe human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)labelNameStringThe human readable label name (imported from CSV), if knownlabelhashByteskeccak256(labelName)parentDomainThe namehash (id) of the parent namesubdomains​Domain!​Can count domains from length of arraysubdomainCountInt!The number of subdomainsresolvedAddressaccountAddress logged from current resolver, if anyownerAccount!​resolverResolver​ttlBigInt​isMigratedBoolean!​createdAtBigInt!​events​DomainEvent!​​TransferDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​NewOwnerDescription:FieldTypeDescriptionidID!​parentDomainDomain!​domainDomain!​TransactionIDBytes!​ownerAccount!​NewResolverDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​resolverResolver!​NewTTLDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​transactionIDBytes!​ttlBigInt!​AccountDescription:FieldTypeDescriptionidID!​domain​Domain!​​registration​Registration!​​RegistrationDescription:FieldTypeDescriptionidID!​domainDomain​registrationDateBigInt!​expiryDateBigInt!​costBigInt!​registrantAccount!​labelNameString​events​RegistrationEven!​​RegistrationEventDescription:FieldTypeDescriptionidID!​registrationRegistrationEvent​blockNumberInt!​transactionIDBytes!​NameRegisteredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​registrantAccount!​expiryDateBigInt!​NameRenewedDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​expiryDateBigInt!​NameTransferredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​newOwnerAccount!​ResolverDescription:FieldTypeDescriptionidID!Concatenation of resolver address and namehashdomainDomain​addressBytes!Address of resolver contractaddrAccountCurrent value of addr record (per events)contenHashBytesContent hash, in binary formattexts[String!]Set of observed text record keyscointTypes[BigInt!]Set of observed SLIP-44 coin typesevents​ResolverEvent!​​ResolverEventDescription:FieldTypeDescriptionidID!Concatenation of block number and log IDresolverResolver!Used to derive relationships to ResolversblockNumberInt!​transactionIDBytes!​AddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​addrAccount!​MulticoinAddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​coinTypeBigInt!​addrBytes!​NameChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​nameString!​AbiChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​contentTypeBigInt!​PubkeyChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​xBytes!​yBytes!​TextChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​keyString!​valueString​ContenthashChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​hashBytes!​InterfaceChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​interfacedIDBytes!​implementerBytes!​AuthorisationChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​ownerBytes!​targetBytes!​isAuthorizedBoolean!​Contract API Reference - PreviousSubgraphNextQuery ExamplesLast modified 6mo agoCopy linkEdit on GitHubOn this pageEntitiesDomainTransferNewOwnerNewResolverNewTTLAccountRegistrationRegistrationEventNameRegisteredNameRenewedNameTransferredResolverResolverEventAddrChangedMulticoinAddrChangedNameChangedAbiChangedPubkeyChangedTextChangedContenthashChangedInterfaceChangedAuthorisationChanged "
46,mains v governance governance proposals term 3 ep3.3 executable sell eth to usdc,"mains v governance governance proposals term 3 ep3.3 executable sell eth to usdc.   [EP3.3] [Executable] Sell ETH to USDC - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1Term 2Term 3[EP3.1.1] [Social] Q1/Q2 2023 Funding Request: ENS Ecosystem Working Group[EP3.1.2] [Social] Q1/Q2 2023 Funding Request: Meta-Governance Working Group[EP3.1.3] [Social] Q1/Q2 2023 Funding Request: Public Goods Working Group[EP3.2] [Executable] Q1/Q2 2023 Working Group Funding[EP3.3] [Executable] Sell ETH to USDC[EP3.4] [Executable] Fund the Endowment (first tranche)Powered By GitBook[EP3.3] [Executable] Sell ETH to USDCThis proposal executes a swap of 10,000 ETH into USDC, to ensure ENS DAO has enough to cover operating expenses for 18 - 24 months.StatusExecutedDiscussion Thread​Discuss​Votes​Tally​Author​James.eth​AbstractThis proposal executes a swap of 10,000 ETH into USDC, to ensure ENS DAO has enough to cover operating expenses for 18 - 24 months.MotivationThe DAO currently keeps almost 100% of its spendable treasury in ETH. While ENS generates protocol revenue in ETH, having so much exposure to a single volatile asset places the DAO in a vulnerable position.This is a proposal to convert 10,000 ETH into USDC through a Cowswap swap.10,000 ETH is approximately 25% of the total amount of ETH held by the ENS DAO (wallet.ensdao.eth) and register controller (controller.ens.eth) as of January 18, 2023.It is hoped that this sale will generate in excess of $13m in USDC. The goal is to ensure that the DAO has enough USDC to cover operations for the next 18 - 24 months.Specification1.Call withdraw() on controller.ens.eth (0x283af0b28c62c092c9727f1ee09c02ca627eb7f5)2.Call deposit() on WETH9 (0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), sending 10,000 ETH3.Call approve(<milkman>, 10000 ETH) on WETH9 (0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)4.Call requestSwapExactTokensForTokens(10000 ETH, <WETH9>, <USDC>, wallet.ensdao.eth, <uniswap v3 price checker>, <price checker data>) on milkman (0x11C76AD590ABDFFCD980afEC9ad951B160F02797)Price checker data is configured to check the swap against the Uniswap v3 pool and limit to 2% slippage. It is generated using the below code:import { ethers } from ""https://cdn.ethers.io/lib/ethers-5.2.esm.min.js"";​function getCheckerData(slippage, path, fees) { return ethers.utils.defaultAbiCoder.encode( [""uint256"", ""bytes""], [  slippage,  ethers.utils.defaultAbiCoder.encode(  [""address[]"", ""uint24[]""],  [path, fees],  ), ], );}​const checkerData = getCheckerData( 200, [ ""0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"", ""0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"", ], [5],);console.log(""checkerData:"", checkerData);Addresses:0xfe89cc7abb2c4183683ab71653c4cdc9b02d44b7 - wallet.ensdao.eth0x283af0b28c62c092c9727f1ee09c02ca627eb7f5 - controller.ens.eth0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 - WETH90x11C76AD590ABDFFCD980afEC9ad951B160F02797 - milkman0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 - USDC0x2F965935f93718bB66d53a37a97080785657f0AC - Uniswap v3 slippage checkerTransactionsAddressValueFunctionArgumentValue0x283Af0B28c62C092C9727F1Ee09c02CA627EB7F5-withdraw​​0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc210000 ETHdeposit​​0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2-approveguy0x11C76AD590ABDFFCD980afEC9ad951B160F02797​​​wad100000000000000000000000x11C76AD590ABDFFCD980afEC9ad951B160F02797-requestSwapExactTokensForTokensamountIn10000000000000000000000​​​fromToken0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2​​​toToken0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48​​​to0xfe89cc7abb2c4183683ab71653c4cdc9b02d44b7​​​priceChecker0x2F965935f93718bB66d53a37a97080785657f0AC​​​priceCheckerData0x00000000000000000000000000000000000000000000000000000000000000c8000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb4800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000005Previous[EP3.2] [Executable] Q1/Q2 2023 Working Group FundingNext[EP3.4] [Executable] Fund the Endowment (first tranche)Last modified 26d agoCopy linkEdit on GitHubOn this pageAbstractMotivationSpecificationTransactions "
47,mains contract api reference subgraphdata entities#multicoinaddrchanged,"mains contract api reference subgraphdata entities#multicoinaddrchanged.   Entities - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookEntitiesEntities​Domain​​DomainEvent​​Transfer​​NewOwner​​NewResolver​​NewTTL​​Account​​Registration​​RegistrationEvent​​NameRegistered​​NameRenewed​​NameTransferred​​Resolver​​ResolverEvent​​AddrChanged​​MulticoinAddrChanged​​NameChanged​​AbiChanged​​PubKeyChanged​​TextChanged​​ContentHashChanged​​InterfaceChanged​​AuthorisationChanged​DomainDescription:FieldTypeDescriptionidID!The namehash of the namenameStringThe human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)labelNameStringThe human readable label name (imported from CSV), if knownlabelhashByteskeccak256(labelName)parentDomainThe namehash (id) of the parent namesubdomains​Domain!​Can count domains from length of arraysubdomainCountInt!The number of subdomainsresolvedAddressaccountAddress logged from current resolver, if anyownerAccount!​resolverResolver​ttlBigInt​isMigratedBoolean!​createdAtBigInt!​events​DomainEvent!​​TransferDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​NewOwnerDescription:FieldTypeDescriptionidID!​parentDomainDomain!​domainDomain!​TransactionIDBytes!​ownerAccount!​NewResolverDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​resolverResolver!​NewTTLDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​transactionIDBytes!​ttlBigInt!​AccountDescription:FieldTypeDescriptionidID!​domain​Domain!​​registration​Registration!​​RegistrationDescription:FieldTypeDescriptionidID!​domainDomain​registrationDateBigInt!​expiryDateBigInt!​costBigInt!​registrantAccount!​labelNameString​events​RegistrationEven!​​RegistrationEventDescription:FieldTypeDescriptionidID!​registrationRegistrationEvent​blockNumberInt!​transactionIDBytes!​NameRegisteredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​registrantAccount!​expiryDateBigInt!​NameRenewedDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​expiryDateBigInt!​NameTransferredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​newOwnerAccount!​ResolverDescription:FieldTypeDescriptionidID!Concatenation of resolver address and namehashdomainDomain​addressBytes!Address of resolver contractaddrAccountCurrent value of addr record (per events)contenHashBytesContent hash, in binary formattexts[String!]Set of observed text record keyscointTypes[BigInt!]Set of observed SLIP-44 coin typesevents​ResolverEvent!​​ResolverEventDescription:FieldTypeDescriptionidID!Concatenation of block number and log IDresolverResolver!Used to derive relationships to ResolversblockNumberInt!​transactionIDBytes!​AddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​addrAccount!​MulticoinAddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​coinTypeBigInt!​addrBytes!​NameChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​nameString!​AbiChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​contentTypeBigInt!​PubkeyChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​xBytes!​yBytes!​TextChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​keyString!​valueString​ContenthashChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​hashBytes!​InterfaceChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​interfacedIDBytes!​implementerBytes!​AuthorisationChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​ownerBytes!​targetBytes!​isAuthorizedBoolean!​Contract API Reference - PreviousSubgraphNextQuery ExamplesLast modified 6mo agoCopy linkEdit on GitHubOn this pageEntitiesDomainTransferNewOwnerNewResolverNewTTLAccountRegistrationRegistrationEventNameRegisteredNameRenewedNameTransferredResolverResolverEventAddrChangedMulticoinAddrChangedNameChangedAbiChangedPubkeyChangedTextChangedContenthashChangedInterfaceChangedAuthorisationChanged "
48,mains v governance governance proposals term 2 social ep2.2.5 selection of an ens endowment fund manager,"mains v governance governance proposals term 2 social ep2.2.5 selection of an ens endowment fund manager.   [EP2.2.5] [Social] Selection of an ENS endowment fund manager - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1Term 2[EP2.1] [Executable] Funding True Names Ltd[EP2.2.1] [Executable] Q3 & Q4 2022 Meta-Governance WG Budget[EP2.2.2] [Executable] Q3 & Q4 2022 Ecosystem WG Budget[EP2.2.3] [Executable] Q3 & Q4 2022 Public Goods WG Budget[EP2.2.4] [Social] ENS Endaoment RFP[EP2.2.5] [Social] Selection of an ENS endowment fund managerTerm 3Powered By GitBook[EP2.2.5] [Social] Selection of an ENS endowment fund manager​StatusPassed (winner: Karpatkey)Discussion Thread​Discuss​Votes​Snapshot​AbstractFollowing the RFP process approved in EP2.2.4, the Meta-Governance Working Group stewards have selected a short list of potential fund managers for the DAO to elect to manage the ENS Endowment.SpecificationEP2.2.4 set out a process for fund managers to submit proposals to the Meta-Governance Working Group for consideration as fund managers over an ENS Endowment. The Endowment's goal is to ensure the long-term viability of ENS by ensuring it can meet its ongoing financial obligations even in the face of reduced ETH price and registration/renewal revenue.Eight submissions were made as a result of the RFP process, and the stewards have narrowed this down to three finalists. All three finalists are established actors with track records of fund management, and their proposals reflect an understanding of the low-risk, long-term sustainability approach that an endowment should take.Rather than select a winner themselves, the Meta-Governance Working Group Stewards believe that the selection of a fund manager should be put to the DAO. This EP implements a Snapshot vote using Ranked Choice voting with the following options:1.Avantgarde2.Karpatkey3.Llama4.None of the aboveSubmissions for the vote are listed in alphabetical order.Following the conclusion of the vote, the Meta-Governance Stewards will work with the winning team to develop an initial treasury allocation strategy, resulting in a separate executable proposal to enact the initial setup of the endowment.Submission SummaryThe table below summarizes the final submissions made by each candidate.SubmissionInitial SizeTarget SizePerformance FeeAdmin FeeBreakeven Return​Avantgarde​25,000 ETH$100,000,000 USD12.5%0.5%0.57%​Karpatkey​$52,000,000 USD$69,000,000 USD10%0.5%0.56%​Llama​30,000 ETH$80,000,000 USD0%1% min. $500k USD1% - 1.28%Breakeven return is calculated as admin_fee / (1 - performance_fee).Previous[EP2.2.4] [Social] ENS Endaoment RFPNextTerm 3Last modified 1mo agoCopy linkEdit on GitHubOn this pageAbstractSpecificationSubmission Summary "
49,mains contract api reference name processing,"mains contract api reference name processing.   Name Processing - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookName ProcessingDescribes how to normalize and hash ENS names.In place of human-readable names, ENS works purely with fixed length 256-bit cryptographic hashes. In order to derive the hash from a name while still preserving its hierarchal properties, a process called Namehash is used. For example, the namehash of 'alice.eth' is 0x787192fc5378cc32aa956ddfdedbf26b24e8d78e40109add0eea2c1a012c3dec; this is the representation of names that is used exclusively inside ENS.Before being hashed with namehash, names are first normalized, using a process called UTS-46 normalization. This ensures that upper- and lower-case names are treated equivalently, and that invalid characters are prohibited. Anything that hashes and resolves a name must first normalize it, to ensure that all users get a consistent view of ENS.Normalising NamesBefore a name can be converted to a node hash using Namehash, the name must first be normalized and checked for validity - for instance, converting fOO.eth into foo.eth, and prohibiting names containing forbidden characters such as underscores. It is crucial that all applications follow the same set of rules for normalization and validation, as otherwise two users entering the same name on different systems may resolve the same human-readable name into two different ENS names.Applications using ENS and processing human-readable names must follow UTS46 for normalization and validation. Processing should be done with non-transitional rules, and with UseSTD3ASCIIRules=true.The eth-ens-namehash Javascript library performs both normalization and hashing as described here. All of the ENS libraries covered in the DApp Developer Guide also perform normalization and hashing.Hashing NamesNamehash is a recursive process that can generate a unique hash for any valid domain name. Starting with the namehash of any domain - for example, 'alice.eth' - it's possible to derive the namehash of any subdomain - for example 'iam.alice.eth' - without having to know or handle the original human-readable name. It is this property that makes it possible for ENS to provide a hierarchal system, without having to deal with human-readable text strings internally.Terminologydomain - The complete, human-readable form of a name; eg, iam.alice.eth.label - A single component of a domain - eg, iam, alice, or eth.label hash - the output of the keccak-256 function applied to a label; eg, keccak256(‘eth’) = 0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0node - The output of the namehash function, used to uniquely identify a name in ENS.AlgorithmFirst, a domain is divided into labels by splitting on periods (‘.’). So, ‘vitalik.wallet.eth’ becomes the list [‘vitalik’, ‘wallet’, ‘eth’].The namehash function is then defined recursively as follows:namehash([]) = 0x0000000000000000000000000000000000000000000000000000000000000000namehash([label, …]) = keccak256(namehash(…), keccak256(label))A sample implementation in Python is provided below.def namehash(name): if name == '': return '\0' * 32 else: label, _, remainder = name.partition('.') return sha3(namehash(remainder) + sha3(label))Namehash is specified in EIP 137.How do I find the labelhash/namehash of a name?In some cases, you may need to know the hash of the name stored in ENS. labelhash means hash of the label of the domain (eg: makoto for makoto.eth) and namehash is the hash which combines labelhashes. We are currently working to include this information in our Manager app. In the meantime, you can query the information via https://thegraph.com/explorer/subgraph/ensdomains/ens with the following query.{ domains(where: {name:""vitalik.eth""}) { id name labelName labelhash }}Handling of Ambiguous NamesBecause of the large number of characters in unicode, and the wide variety of scripts represented, inevitably there are different Unicode characters that are similar or even identical when shown in common fonts. This can be abused to trick users into thinking they are visiting one site or resource, when in fact they are visiting another. This is known as a homoglyph attack.User agents and other software that display names to users should take countermeasures against these attacks, such as by highlighting problematic characters, or showing warnings to users about mixed scripts. Chromium’s IDNA strategy may serve as a useful reference for user-agent behaviour around rendering IDNA names.Dapp Developer Guide - PreviousENS Data guideNext - Contract API ReferenceRegistryLast modified 1yr agoCopy linkEdit on GitHubOn this pageNormalising NamesHashing NamesTerminologyAlgorithmHow do I find the labelhash/namehash of a name?Handling of Ambiguous Names "
50,mains contract api reference subgraphdata entities#transfer,"mains contract api reference subgraphdata entities#transfer.   Entities - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookEntitiesEntities​Domain​​DomainEvent​​Transfer​​NewOwner​​NewResolver​​NewTTL​​Account​​Registration​​RegistrationEvent​​NameRegistered​​NameRenewed​​NameTransferred​​Resolver​​ResolverEvent​​AddrChanged​​MulticoinAddrChanged​​NameChanged​​AbiChanged​​PubKeyChanged​​TextChanged​​ContentHashChanged​​InterfaceChanged​​AuthorisationChanged​DomainDescription:FieldTypeDescriptionidID!The namehash of the namenameStringThe human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)labelNameStringThe human readable label name (imported from CSV), if knownlabelhashByteskeccak256(labelName)parentDomainThe namehash (id) of the parent namesubdomains​Domain!​Can count domains from length of arraysubdomainCountInt!The number of subdomainsresolvedAddressaccountAddress logged from current resolver, if anyownerAccount!​resolverResolver​ttlBigInt​isMigratedBoolean!​createdAtBigInt!​events​DomainEvent!​​TransferDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​NewOwnerDescription:FieldTypeDescriptionidID!​parentDomainDomain!​domainDomain!​TransactionIDBytes!​ownerAccount!​NewResolverDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​resolverResolver!​NewTTLDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​transactionIDBytes!​ttlBigInt!​AccountDescription:FieldTypeDescriptionidID!​domain​Domain!​​registration​Registration!​​RegistrationDescription:FieldTypeDescriptionidID!​domainDomain​registrationDateBigInt!​expiryDateBigInt!​costBigInt!​registrantAccount!​labelNameString​events​RegistrationEven!​​RegistrationEventDescription:FieldTypeDescriptionidID!​registrationRegistrationEvent​blockNumberInt!​transactionIDBytes!​NameRegisteredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​registrantAccount!​expiryDateBigInt!​NameRenewedDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​expiryDateBigInt!​NameTransferredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​newOwnerAccount!​ResolverDescription:FieldTypeDescriptionidID!Concatenation of resolver address and namehashdomainDomain​addressBytes!Address of resolver contractaddrAccountCurrent value of addr record (per events)contenHashBytesContent hash, in binary formattexts[String!]Set of observed text record keyscointTypes[BigInt!]Set of observed SLIP-44 coin typesevents​ResolverEvent!​​ResolverEventDescription:FieldTypeDescriptionidID!Concatenation of block number and log IDresolverResolver!Used to derive relationships to ResolversblockNumberInt!​transactionIDBytes!​AddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​addrAccount!​MulticoinAddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​coinTypeBigInt!​addrBytes!​NameChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​nameString!​AbiChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​contentTypeBigInt!​PubkeyChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​xBytes!​yBytes!​TextChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​keyString!​valueString​ContenthashChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​hashBytes!​InterfaceChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​interfacedIDBytes!​implementerBytes!​AuthorisationChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​ownerBytes!​targetBytes!​isAuthorizedBoolean!​Contract API Reference - PreviousSubgraphNextQuery ExamplesLast modified 6mo agoCopy linkEdit on GitHubOn this pageEntitiesDomainTransferNewOwnerNewResolverNewTTLAccountRegistrationRegistrationEventNameRegisteredNameRenewedNameTransferredResolverResolverEventAddrChangedMulticoinAddrChangedNameChangedAbiChangedPubkeyChangedTextChangedContenthashChangedInterfaceChangedAuthorisationChanged "
51,mains v governance ens dao constitution,"mains v governance ens dao constitution.   ENS DAO Constitution - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsPowered By GitBookENS DAO ConstitutionThe ENS constitution is a set of binding rules that determine what governance actions are legitimate for the DAO to take.Each article has examples of permissible and non permissible actions. These examples are illustrative and should not be considered a binding part of the text of the constitution itself.I. Name ownership shall not be infringedENS governance will not enact any change that infringes on the rights of ENS users to retain names they own, or unfairly discriminate against name owners’ ability to extend, transfer, or otherwise use their names.ExamplesPermissible: ENS governance may enact a change affecting the registration or extension costs of all names based on transparent criteria such as length, as long as it pursues a goal outlined in this constitution.Not Permissible: ENS governance must not enact a change increasing or reducing the extension costs of a list of existing ENS names, as this would unfairly benefit or penalise a handpicked group.II. Fees are primarily an incentive mechanismThe primary purpose of registration fees is as an incentive mechanism to prevent the namespace becoming overwhelmed with speculatively registered names. A secondary purpose is to provide enough revenue to the DAO to fund ongoing development and improvement of ENS. ENS governance will not enact any fee other than for these purposes.ExamplesPermissible: ENS governance may increase the price of name registrations in order to address excessive speculative registrations induced by a price that is set too low, or because the current price is insufficient to fund ongoing ENS operations at a reasonable level.Not Permissible: ENS governance must not enact a change imposing a fee for claiming DNS domains inside ENS, because such a fee would be purely an income generating measure and not an incentive mechanism.III. Income funds ENS and other public goodsAny income generated to the ENS treasury is to be used first of all to ensure the long-term viability of ENS, and to fund continuing development and improvement of the ENS system. Funds that are not reasonably required to achieve this goal may be used to fund other public goods within web3 as ENS governance sees fit.ENS governance will not allocate funds to a team or individual who does not commit to uphold the same principles outlined in this constitution in their use of the allocated funds.ExamplesPermissible: ENS governance may offer grant funding for a public good unrelated to ENS or Ethereum, so long as doing so does not affect the long-term viability of ENS.Not Permissible: ENS governance must not use the funds to support projects that conflict with the goals of ENS.IV. ENS Integrates with the global namespaceIn order to facilitate making the most widely usable naming system, ENS aims to integrate with the legacy DNS naming system to the greatest extent possible without sacrificing decentralization of ENS. ENS governance will not enact changes that compromise ENS’s ability to do this.ExamplesPermissible: ENS governance should grant control of a top-level domain to its owner in the DNS system on request.Not permissible: ENS governance must not create new top-level domains unless those domains have been granted to ENS by a DNS authority.V. Amendments to this constitution by majority voteAny change may be made to this constitution only by two-thirds majority and at least 1% of all tokens participating.PreviousModerator ChecklistsNextThe ENS FoundationLast modified 1yr agoCopy linkEdit on GitHubOn this pageI. Name ownership shall not be infringedExamplesII. Fees are primarily an incentive mechanismExamplesIII. Income funds ENS and other public goodsExamplesIV. ENS Integrates with the global namespaceExamplesV. Amendments to this constitution by majority vote "
52,mains ens improvement proposals ensip 6 dns in ens,"mains ens improvement proposals ensip 6 dns in ens.   ENSIP-6: DNS-in-ENS - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsENSIP-1: ENSENSIP-2: Initial Hash RegistrarENSIP-3: Reverse ResolutionENSIP-4: Support for contract ABIsENSIP-5: Text RecordsENSIP-6: DNS-in-ENSENSIP-7: Contenthash fieldENSIP-8: Interface DiscoveryENSIP-9: Multichain Address ResolutionENSIP-10: Wildcard ResolutionENSIP-11: EVM compatible Chain Address ResolutionENSIP-12: Avatar Text RecordsENSIP-13: SAFE Authentication for ENSENSIP-14: On-chain Source ParameterDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookENSIP-6: DNS-in-ENSDefines a resolver profile for ENS that provides features for storage and lookup of DNS records (formerly EIP-1185).This standard is obsolete, and does not reflect the current implementation.AuthorJim McDonald (@mcdee)StatusStagnantCreated2018-06-26AbstractThis ENSIP defines a resolver profile for ENS that provides features for storage and lookup of DNS records. This allows ENS to be used as a store of authoritative DNS information.MotivationENS is a highly desirable store for DNS information. It provides the distributed authority of DNS without conflating ownership and authoritative serving of information. With ENS, the owner of a domain has full control over their own DNS records. Also, ENS has the ability (through smart contracts) for a domain's subdomains to be irrevocably assigned to another entity.SpecificationThe resolver profile to support DNS on ENS follows the resolver specification as defined in #137.Traditionally, DNS is a zone-based system in that all of the records for a zone are kept together in the same file. This has the benefit of simplicity and atomicity of zone updates, but when transposed to ENS can result in significant gas costs for simple changes. As a result, the resolver works on the basis of record sets. A record set is uniquely defined by the tuple (domain, name, resource record type), for example the tuple (example.com, www.example.com, A) defines the record set of A records for the name www.example.com in the domain example.com. A record set can contain 0 or more values, for example if www.example.com has A records 1.2.3.4 and 5.6.7.8 then the aforementioned tuple will have two values.The choice to work at the level of record sets rather than zones means that this specification cannot completely support some features of DNS, such as zone transfers and DNSSEC. It would be possible to build a different resolver profile that works at the zone level, however it would be very expensive to carry out updates and so is not considered further for this ENSIP.The DNS resolver interface consists of two functions to set DNS information and two functions to query DNS information.setDNSRecords(bytes32 node, bytes data)setDNSRecords() sets, updates or clears 1 or more DNS records for a given node. It has function signature 0x0af179d7.The arguments for the function are as follows:node: the namehash of the fully-qualified domain in ENS for which to set the records. Namehashes are defined in #137data: 1 or more DNS records in DNS wire format. Any record that is supplied without a value will be cleared. Note that all records in the same RRset should be contiguous within the data; if not then the later RRsets will overwrite the earlier one(s)clearDNSZone(bytes32 node)clearDNSZone() removes all DNS records for the domain. It has function signature 0xad5780af.Although it is possible to clear records individually with setDNSRecords() as described above this requires the owner to know all of the records that have been set (as the resolver has no methods to iterate over the records for a given domain), and might require multiple transactions. clearDNSZone() removes all zone information in a single operation.The arguments for the function is as follows:node: the namehash of the fully-qualified domain in ENS for which to clear the records. Namehashes are defined in #137dnsRecords(bytes32 node, bytes32 name, uint16 resource) view returns (bytes)dnsRecords() obtains the DNS records for a given node, name and resource. It has function signature 0x2461e851.The arguments for the function are as follows:node: the namehash of the fully-qualified domain in ENS for which to set the records. Namehashes are defined in #137name: the keccak256() hash of the name of the record in DNS wire format.resource: the resource record ID. Resource record IDs are defined in https://en.wikipedia.org/wiki/List_of_DNS_record_typesThe function returns all matching records in DNS wire format. If there are no records present the function will return nothing.hasDNSRecords(bytes32 node, bytes32 name) view returns (bool)hasDNSRecords() reports if there are any records for the provided name in the domain. It has function signature 0x4cbf6ba4.This function is needed by DNS resolvers when working with wildcard resources as defined in https://tools.ietf.org/html/rfc4592The arguments for the function are as follows:node: the namehash of the fully-qualified domain in ENS for which to set the records. Namehashes are defined in #137name: the keccak256() hash of the name of the record in DNS wire format.The function returns true if there are any records for the provided node and name, otherwise false.Backwards compatibilityNot applicable.ImplementationThe reference implementation of the DNS resolver is at https://github.com/wealdtech/wealdtech-solidity/blob/master/contracts/ens/DNSResolver.solhttps://github.com/wealdtech/ethereal.git can be used to test the functionality of the resolver with the ""dns set"", ""dns get"" and ""dns clear"" commands.Test CasesTest cases for the DNS resolver are at https://github.com/wealdtech/wealdtech-solidity/blob/master/test/ens/DNSResolver.jsCopyrightCopyright and related rights waived via CC0.PreviousENSIP-5: Text RecordsNextENSIP-7: Contenthash fieldLast modified 1yr agoCopy linkEdit on GitHubOn this pageAbstractMotivationSpecificationBackwards compatibilityImplementationTest CasesCopyright "
53,mains v governance governance proposals term 1 ep7.1 executable q1 and q2 2022 meta governance wg budget,"mains v governance governance proposals term 1 ep7.1 executable q1 and q2 2022 meta governance wg budget.   [EP1.3.1] [Executable] Q1 & Q2 2022 Meta-Governance WG Budget - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1[EP1.1] [Executable] Set the temporary premium start price to $100,000[EP1.2.1] [Social] Removal of Brantly Millegan as Director of the ENS Foundation[EP1.2.2] [Social] Election of a new Director of The ENS Foundation[EP1.3.1] [Executable] Q1 & Q2 2022 Meta-Governance WG Budget[EP1.3.2] [Executable] Q1 & Q2 2022 ENS Ecosystem WG Budget[EP1.3.3] [Executable] Q1 & Q2 2022 Community WG Budget[EP1.3.4] [Executable] Q1 & Q2 2022 Public Goods WG Budget[EP1.4] [Executable] Reimburse True Names for expenses and tax obligations incurred for the DAO[EP1.5][Executable] Change to Exponential Premium Price Oracle[EP1.6] [Executable] A DAO-Governed Identity Server[EP1.7] [Executable] End the $ENS and EP2 airdrops[EP1.8] [Social] Working Group Rules[EP1.9] [Executable] Fund the Protocol Guild pilot with 200,000 $ENSTerm 2Term 3Powered By GitBook[EP1.3.1] [Executable] Q1 & Q2 2022 Meta-Governance WG Budget​StatusExecutedDiscussion Thread​Discourse​Votes​Snapshot, passed March 6th 2022 Onchain, passed March 29th 2022Note: This was previously numbered EP7.1.SummaryThe goal of the Meta-Governance working group (MG WG) is to manage the administration of the ENS DAO. The MG WG shall focus on the following three areas over the Q1/Q2 2022 Term.1.Treasury Management2.Governance process and DAO structures3.DAO ToolingThe following budget is requested to provide the MG WG with the resources to work on the areas mentioned above over the Q1/Q2 2022 Term.Proposed BudgetElected Steward Compensation (2,700 $ENS)Elected steward compensation: 100 $ENS for each 3 elected stewards / month x 6 months = 1,800 $ENS.Lead coordinator compensation, to be paid to the steward that is the lead coordinator or other WG members who take on lead coordinator responsibilities, at the discretion of the Stewards: 150 $ENS / month x 6 months = 900 $ENSSubgroupsTreasury Management ($20k USDC)Management and diversification strategies.DAO Governance ($20k USDC)Documentation related to governance processes within the DAOAdminister experiments related to onboarding, engaging, and valuing contributors within the DAO.DAO Tooling ($10K USDC)Develop dashboards to improve transparency and visibility on DAO and ENS metrics.The MG WG stewards may choose to purchase $ENS with the USDC requested and distribute a mix of USDC and $ENS to contributors as they see fit.Total MG WG Funding Request for Q1/Q2 2022Steward related compensation: 2,700 $ENS MG WG funding: $50k USDCPrevious[EP1.2.2] [Social] Election of a new Director of The ENS FoundationNext[EP1.3.2] [Executable] Q1 & Q2 2022 ENS Ecosystem WG BudgetLast modified 6mo agoCopy linkEdit on GitHubOn this pageSummaryProposed Budget "
54,mains contract api reference subgraphdata entities#contenthashchanged,"mains contract api reference subgraphdata entities#contenthashchanged.   Entities - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookEntitiesEntities​Domain​​DomainEvent​​Transfer​​NewOwner​​NewResolver​​NewTTL​​Account​​Registration​​RegistrationEvent​​NameRegistered​​NameRenewed​​NameTransferred​​Resolver​​ResolverEvent​​AddrChanged​​MulticoinAddrChanged​​NameChanged​​AbiChanged​​PubKeyChanged​​TextChanged​​ContentHashChanged​​InterfaceChanged​​AuthorisationChanged​DomainDescription:FieldTypeDescriptionidID!The namehash of the namenameStringThe human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)labelNameStringThe human readable label name (imported from CSV), if knownlabelhashByteskeccak256(labelName)parentDomainThe namehash (id) of the parent namesubdomains​Domain!​Can count domains from length of arraysubdomainCountInt!The number of subdomainsresolvedAddressaccountAddress logged from current resolver, if anyownerAccount!​resolverResolver​ttlBigInt​isMigratedBoolean!​createdAtBigInt!​events​DomainEvent!​​TransferDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​NewOwnerDescription:FieldTypeDescriptionidID!​parentDomainDomain!​domainDomain!​TransactionIDBytes!​ownerAccount!​NewResolverDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​resolverResolver!​NewTTLDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​transactionIDBytes!​ttlBigInt!​AccountDescription:FieldTypeDescriptionidID!​domain​Domain!​​registration​Registration!​​RegistrationDescription:FieldTypeDescriptionidID!​domainDomain​registrationDateBigInt!​expiryDateBigInt!​costBigInt!​registrantAccount!​labelNameString​events​RegistrationEven!​​RegistrationEventDescription:FieldTypeDescriptionidID!​registrationRegistrationEvent​blockNumberInt!​transactionIDBytes!​NameRegisteredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​registrantAccount!​expiryDateBigInt!​NameRenewedDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​expiryDateBigInt!​NameTransferredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​newOwnerAccount!​ResolverDescription:FieldTypeDescriptionidID!Concatenation of resolver address and namehashdomainDomain​addressBytes!Address of resolver contractaddrAccountCurrent value of addr record (per events)contenHashBytesContent hash, in binary formattexts[String!]Set of observed text record keyscointTypes[BigInt!]Set of observed SLIP-44 coin typesevents​ResolverEvent!​​ResolverEventDescription:FieldTypeDescriptionidID!Concatenation of block number and log IDresolverResolver!Used to derive relationships to ResolversblockNumberInt!​transactionIDBytes!​AddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​addrAccount!​MulticoinAddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​coinTypeBigInt!​addrBytes!​NameChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​nameString!​AbiChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​contentTypeBigInt!​PubkeyChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​xBytes!​yBytes!​TextChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​keyString!​valueString​ContenthashChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​hashBytes!​InterfaceChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​interfacedIDBytes!​implementerBytes!​AuthorisationChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​ownerBytes!​targetBytes!​isAuthorizedBoolean!​Contract API Reference - PreviousSubgraphNextQuery ExamplesLast modified 6mo agoCopy linkEdit on GitHubOn this pageEntitiesDomainTransferNewOwnerNewResolverNewTTLAccountRegistrationRegistrationEventNameRegisteredNameRenewedNameTransferredResolverResolverEventAddrChangedMulticoinAddrChangedNameChangedAbiChangedPubkeyChangedTextChangedContenthashChangedInterfaceChangedAuthorisationChanged "
55,mains ens improvement proposals ensip 14 platform source parameter,"mains ens improvement proposals ensip 14 platform source parameter.   ENSIP-14: On-chain Source Parameter - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsENSIP-1: ENSENSIP-2: Initial Hash RegistrarENSIP-3: Reverse ResolutionENSIP-4: Support for contract ABIsENSIP-5: Text RecordsENSIP-6: DNS-in-ENSENSIP-7: Contenthash fieldENSIP-8: Interface DiscoveryENSIP-9: Multichain Address ResolutionENSIP-10: Wildcard ResolutionENSIP-11: EVM compatible Chain Address ResolutionENSIP-12: Avatar Text RecordsENSIP-13: SAFE Authentication for ENSENSIP-14: On-chain Source ParameterDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookENSIP-14: On-chain Source ParameterUsing the reveal secret as a way to have on chain information about the source of the registrationAuthorAlex Slobo (@slobo.eth) and Alex Van de Sande (Avsa.eth)StatusDraftSubmitted2023-02-07AbstractWe have many reasons to measure user registration names. Knowing our ecosystem and which apps are popular is essential for identifying the creators who contribute. Retroactive funding via grants is often better than proactive funding, as it allows us to detect what has already worked, rather than relying on guesses. This community often sees unexpected successes that we can't predict.At the same time, it's important to make the process transparent, open source, and privacy-preserving. Source data would also help create referral programs.SpecificationThe ETH Registrar Controller takes a random secret as part of its input. This secret parameter is random data that obscures the name before the final step of the registration process is complete. It is 32 bytes of entropy and the ens manager app on app.ens.domains generates it by calling require('crypto').randomBytes(32).This proposal suggests a social convention that generates the secret from a combination of the first 4 bytes of the namehash, plus another 4 bytes for user referrals, combined with the appropriate number of random bytes.In hex formatted string it means that the first 8 chars of the secret would be the platform name and the next 8 would be used as an identifier of the user referral. For example, if the above was registered via ensfairy, the secret would be:0x 1b7f8b3c 612c63bc c635528d3b7196bc89d13566c1be2068af0cad6fb3ecebf0With this, we can attribute registrations using the first 16 chars of the secret. The loss of entropy of 64 bits is not relevant, since the only goal of the secret is to obscure the details of the bid to avoid front-running during the short period (usually a few minutes, but it could be as long as a week) before the reveal transaction is executed. The secret still retains 192 bits, which is highly secure, especially for such a short time frame.User Referral DataThe goal of this ENSIP is to empower app makers and anyone who wants to start a registration campaign. Any app that conforms to this standard should accept a referral link in the form of ?ensref=12345678 (or a similar scheme for mobile apps and other platforms). When a new user arrives at the site via a referral code, the platform should try to remember the user if they later register an ENS name, by appending the code to the platform code, followed by the rest of the secret. Standard cookie and private data regulations apply. While we encourage users to derive their code from a namehash, any random code should be accepted.The extra data can be used in this example:Alice refers Bob to an ENS registrar app using a custom link like app.ens.domains/?ensref=deadbeefIf Bob clicks the link, the information is saved on the cookies/local storage (until it's overwritten by another referral code, Bob clears his memory, or the code expires).Later, Bob wants to register a name; the secret will be prepended by the first 8 letters of the platform, followed by the code provided by Alice.This allows individuals who don't own a name registrar app, but have their own audience, to have a cross-registrar referral, which registrars can choose to share revenue with.Privacy ConcernsThis action makes it public which apps users are using to register names, and may reveal who they are friends with or who they follow. It could also reveal some demographic information about accounts - if a registrar app is known to be popular in a certain country or to only have a UI in a certain language, it can indicate that a specific Ethereum address might be from that demographic. This is not unlike seeing a user send funds to a known exchange address.To address these concerns, we ask app makers to make the process transparent and allow users to opt-out of either the referral code or the whole platform code being added to their secret.This would also enable comparison of different clients' usage - again, this is by design. If a given platform doesn't want any of their numbers to be public, they can simply not implement it.A Reverse Code RegistrySince the source code is derived from the namehash, it's not reversible. Therefore, some sort of registry of names is needed to make sense of these names. Such registrars could be made on-chain or simply be a git text file with multiple forks across many repos. A registrar definition is outside the scope of this ENSIP, as if the ground truth was on-chain it would be relatively easy to game.With a purely random number, it would take about 30,000 registrants to create a 10% chance of an accidental collision, and by 77,163 codes that chance increases to 50%. This means it should be quite rare for an accidental collision to happen, but it is still trivial to create such a collision or to spam a registry. Therefore, instead of trying to play the security cat and mouse game, we would rather leave the ""truth"" of the codes to their usage. If someone is using them to create a ranking website or launch a referral program, each should simply exercise common sense to maintain their own copy of the registry for the very top of the ranking, where it should be easier to disambiguate.PreviousENSIP-13: SAFE Authentication for ENSNext - Dapp Developer GuideENS Enabling your DAppLast modified 5d agoCopy linkEdit on GitHubOn this pageAbstractSpecificationUser Referral DataPrivacy ConcernsA Reverse Code Registry "
56,mains contract api reference publicresolver,"mains contract api reference publicresolver.   PublicResolver - ENS Documentation    ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookPublicResolverThe default public resolver.​Source​PublicResolver implements a general-purpose ENS resolver that is suitable for most standard ENS use-cases. The public resolver permits updates to ENS records by the owner of the corresponding name.The public resolver implements the following EIPs:​EIP 137 - Contract address interface (addr()).​EIP 165 - Interface Detection (supportsInterface()).​EIP 181 - Reverse resolution (name()).​EIP 205 - ABI support (ABI()).​EIP 619 - SECP256k1 public keys (pubkey()).​EIP 634 - Text records (text()).​EIP 1577 - Content hash support (contenthash()).​EIP 2304 - Multicoin support (addr()).While the PublicResolverprovides a convenient default implementation, many resolver implementations and versions exist. Callers must not assume that a domain uses the current version of the public resolver, or that all of the methods described here are present. To check if a resolver supports a feature, see Check Interface Support.Check Interface Supportfunction supportsInterface(bytes4 interfaceID) external pure returns (bool)ENS uses ERC 165 for interface detection. ERC 165 requires that supporting contracts implement a function, supportsInterface, which takes an interface ID and returns a boolean value indicating if this interface is supported or not.Interface IDs are calculated as the exclusive-or of the four-byte function identifiers of each function included in the interface. For example, addr(bytes32) has the function ID 0x3b3b57de. Because it is the only function in the Ethereum Address interface, its interface ID is also 0x3b3b57de, and so calling supportsInterface(0x3b3b57de) will return true for any resolver that supports addr().ERC 165 has an interface ID of 0x01ffc9a7, so supportsInterface(0x01ffc9a7) will always return true for any ERC 165 supporting contract (and hence for any resolver).Note that the public resolver does not expose explicit interfaces for setter functions, so there are no automated means to check for support for a given setter function.Get Ethereum Addressfunction addr(bytes32 node) external view returns (address)Returns the Ethereum address associated with the provided node, or 0 if none.This function has interface ID 0x3b3b57de.This function is specified in EIP 137.Set Ethereum Addressfunction setAddr(bytes32 node, address addr) external;Sets the Ethereum address associated with the provided node to addr.Only callable by the owner of node.Emits the following event:event AddrChanged(bytes32 indexed node, address a);Get Blockchain Addressfunction addr(bytes32 node, uint coinType) external view returns(bytes memory);Returns the Blockchain address associated with the provided node and coinType, or 0 if none.This function has interface ID 0xf1cb7e06.This function is specified in EIP 2304.The return value is the cryptocurrency address in its native binary format and each blockchain address has a different encoding and decoding method.For example, the Bitcoin address 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa base58check decodes to the 21 bytes 0062e907b15cbf27d5425399ebf6f0fb50ebb88f18 then scriptPubkey encodes to 25 bytes 76a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1888ac whereas the BNB address bnb1grpf0955h0ykzq3ar5nmum7y6gdfl6lxfn46h2 Bech32 decodes to the binary representation 40c2979694bbc961023d1d27be6fc4d21a9febe6.To convert the binary representation into the address, use formatsByCoinType[SYMBOL].encoder(binary) of address-encoder.A zero-length string will be returned if the specified coin ID does not exist on the specified node.Set Blockchain Addressfunction setAddr(bytes32 node, uint coinType, bytes calldata a) external;Sets the blockchain address associated with the provided node and coinType to addr.coinType is the cryptocurrency coin type index from SLIP44.To convert the address into the binary representation, use formatsByName[SYMBOL].decoder(text) of address-encoder​Only callable by the owner of node.Emits the following event:event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);Get Canonical Namefunction name(bytes32 node) external view returns (string memory);Returns the canonical ENS name associated with the provided node. Used exclusively for reverse resolution.This function has interface ID 0x691f3431.This function is specified in EIP 181.Set Canonical Namefunction setName(bytes32 node, string calldata name) external;Sets the canonical ENS name for the provided node to name.Only callable by the owner of node.Emits the following event:event NameChanged(bytes32 indexed node, string name);Get Content Hashfunction contenthash(bytes32 node) external view returns (bytes memory);Returns the content hash for node, if one exists. Values are formatted as machine-readable multicodecs, as specified in EIP 1577.contenthash is used to store IPFS and Swarm content hashes, which permit resolving ENS addresses to distributed content (eg, websites) hosted on these distributed networks.This function has interface ID 0xbc1c58d1.This function is specified in EIP 1577.Set Content Hashfunction setContenthash(bytes32 node, bytes calldata hash) external;Sets the content hash for the provided node to hash.Only callable by the owner of node.Values are formatted as machine-readable multicodecs, as specified in EIP 1577.Emits the following event:event ContenthashChanged(bytes32 indexed node, bytes hash);Get Contract ABIABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory);Returns a matching ABI definition for the provided node, if one exists. contentTypes is the bitwise-OR of the encodings that the caller can accept. If multiple content types are specified, the resolver will select one to return. Currently supported content types are:Content Type IDDescription1JSON2zlib-compressed JSON4​CBOR​8URIABI returns a two-tuple of the content type ID and the ABI data. If no data of the appropriate content type ID was found, 0 is returned for the content type ID, and the ABI data will be the empty string.This function has interface ID 0x2203ab56.This function is specified in EIP 205.Set Contract ABIfunction setABI(bytes32 node, uint256 contentType, bytes calldata data) externalSets or updates ABI data for node. contentType specifies the content type ID (see Get Contract ABI for valid values); exactly one type ID must be specified. data contains the encoded ABI data. To clear ABI data for a name, specify the empty string for data.Only callable by the owner of node.Emits the following event:event ABIChanged(bytes32 indexed node, uint256 indexed contentType);Get Public Keyfunction pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y)Returns the ECDSA SECP256k1 public key for node, as a 2-tuple (x, y). If no public key is set, (0, 0) is returned.This function has interface ID 0xc8690233.This function is specified in EIP 619.Set Public Keyfunction setPubkey(bytes32 node, bytes32 x, bytes32 y) externalSets the ECDSA SECP256k1 public key for node to (x, y).Only callable by the owner of node.Emits the following event:event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);Get Text Datafunction text(bytes32 node, string calldata key) external view returns (string memory)Retrieves text metadata for node. Each name may have multiple pieces of metadata, identified by a unique string key. If no text data exists for node with the key key, the empty string is returned.Standard values for key are:keyMeaningemailAn email addressurlA URLavatarA URL to an image used as an avatar or logodescriptionA description of the namenoticeA notice regarding this namekeywordsA list of comma-separated keywords, ordered by most significant first; clients that interpresent this field may choose a threshold beyond which to ignoreIn addition, anyone may specify vendor-specific keys, which must be prefixed with vnd.. The following vendor-specific keys are currently known:keyMeaningcom.twitterTwitter handlecom.githubGithub usernameThis function has interface ID 0x59d1d43c.This function is specified in EIP 634.Set Text Datafunction setText(bytes32 node, string calldata key, string calldata value) externalSets text metadata for node with the unique key key to value, overwriting anything previously stored for node and key. To clear a text field, set it to the empty string.Only callable by the owner of node.Emits the following event:event TextChanged(bytes32 indexed node, string indexedKey, string key);Multicallfunction multicall(bytes[] calldata data) external returns(bytes[] memory results)Permits users to set multiple records in a single operation.Use encodeABI function to encode your contract calls and pass it to data.The frontend usage will be as follows:var addrSet = resolver.contract.methods['setAddr(bytes32,address)'](node, accounts[1]).encodeABI();var textSet = resolver.contract.methods.setText(node, ""url"", ""https://ethereum.org/"").encodeABI();var tx = await resolver.multicall([addrSet, textSet], {from: accounts[0]});Contract API Reference - PreviousTestRegistrarNext - Contract API Reference.eth Permanent RegistrarLast modified 1yr agoCopy linkEdit on GitHubOn this pageCheck Interface SupportGet Ethereum AddressSet Ethereum AddressGet Blockchain AddressSet Blockchain AddressGet Canonical NameSet Canonical NameGet Content HashSet Content HashGet Contract ABISet Contract ABIGet Public KeySet Public KeyGet Text DataSet Text DataMulticall "
57,mains htps:  twitter.com endomains,mains htps:  twitter.com endomains. 
58,mains v governance governance proposals term 1 ep5 executable set the temporary premium start price to usd100 000,"mains v governance governance proposals term 1 ep5 executable set the temporary premium start price to usd100 000.   [EP1.1] [Executable] Set the temporary premium start price to $100,000 - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1[EP1.1] [Executable] Set the temporary premium start price to $100,000[EP1.2.1] [Social] Removal of Brantly Millegan as Director of the ENS Foundation[EP1.2.2] [Social] Election of a new Director of The ENS Foundation[EP1.3.1] [Executable] Q1 & Q2 2022 Meta-Governance WG Budget[EP1.3.2] [Executable] Q1 & Q2 2022 ENS Ecosystem WG Budget[EP1.3.3] [Executable] Q1 & Q2 2022 Community WG Budget[EP1.3.4] [Executable] Q1 & Q2 2022 Public Goods WG Budget[EP1.4] [Executable] Reimburse True Names for expenses and tax obligations incurred for the DAO[EP1.5][Executable] Change to Exponential Premium Price Oracle[EP1.6] [Executable] A DAO-Governed Identity Server[EP1.7] [Executable] End the $ENS and EP2 airdrops[EP1.8] [Social] Working Group Rules[EP1.9] [Executable] Fund the Protocol Guild pilot with 200,000 $ENSTerm 2Term 3Powered By GitBook[EP1.1] [Executable] Set the temporary premium start price to $100,000Increases the start price for the temporary premium added when names expire from $2,000 to $100,000.​StatusExecutedDiscussion Thread​Discourse​Votes​Snapshot, passed Jan 15 Onchain, passed Jan 26Note: This was previously numbered EP5.AbstractWhen a name expires, it goes through a 90 day grace period, after which it becomes available for general registration. To prevent it becoming a race to register, a ‘temporary premium’ is attached, starting at $2000 and diminishing to 0 over 28 days. Done properly this results in a dutch auction for the name.When the premium was set, $2000 was roughly the 98th percentile of all auction prices for the short name auction, and seemed like a reasonable starting price. Today, we’re seeing multiple reports of names, particularly 3 character names, being snapped up by bots the moment they become available at the maximum premium.Long-term we can improve the mechanism by setting the initial premium based on the base price of the name (so 3 letter names start off more expensive than 5+ letter names), and by introducing a nonlinear pricing curve (for example, having the price diminish by 1% per hour for 28 days). In the short term, however, I’d like to propose setting the initial premium to a much higher value, which we can do with a simple transaction from the DAO account.Research of current trends shows:2,798 names have been bought during the temporary premium period so far.Of these, 340 (12%) were purchased the moment they became available.Registrations of names during the temporary premium period have been on the increase since the DAO launched in November.12 names have been purchased at a premium and flipped on OpenSea; the most valuable of these, punk.eth, went for $85,636.Accordingly, I propose increasing the temporary premium from its current value of $2,000 to a new value of $100,000. This will ensure that the start price exceeds the secondary market resale value of almost all released domains, and corresponds to a rate of decrease of just under $150/hr, meaning that less valuable domains will still have a multi-hour period during which people can purchase them before the premium expires.In parallel, work should be initiated on a new nonlinear premium model, so that high initial premiums can be combined with a slow decrease towards 0, allowing both high and low value names to be bid on fairly.Specification1.Deploy a new instance of the LinearPremiumPriceOracle with the initial premium set to 100,000 USD and the period set to 28 days, with other pricing variables identical to the current oracle.2.Call setPriceOracle on controller.ens.eth, passing in the address of the new price oracle contract.CodeTBDPreviousTerm 1Next[EP1.2.1] [Social] Removal of Brantly Millegan as Director of the ENS FoundationLast modified 6mo agoCopy linkEdit on GitHubOn this pageAbstractSpecificationCode "
59,mains contract api reference dns registrar,"mains contract api reference dns registrar.   DNS Registrar - ENS Documentation    ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookDNS RegistrarAt ENS, we have two smart contracts, DNSSECOracle and DNSRegistrar.DNSSEC (The Domain Name System Security Extensions) establishes a chain of trust from the root key which is signed by ICANN (.) and down through each key. We start off knowing the hash of the root key of DNS (this is hard coded in the smart contract oracle). Given the hashes of that key, we can pass in the actual key, we can verify that it matches the hash and we can add it to the set of the trusted records.Given that key, we can now verify any record that is signed with that key, so in this case, it’s the hash of the root of the xyz top-level domain. Given that, we can recognize the key, and so on and so forth.DNSSEC oracle allows anyone to submit proof of any DNSSEC-signed DNS record on the Ethereum blockchain, as long as it was signed using supported public key schemes and digests. DNSRegistrar grants ENS domains to anyone who can prove ownership of the corresponding domain in DNS through DNSSEC Oracle to prove this.Deployed DNSRegistrar addressesMainnet, at TBD.Ropsten, at 0x475e527d54b91b0b011DA573C69Ac54B2eC269ea.When you register ENS names, you can look up the registrar contract address by looking up its parent domain owner (eg: .eth, for .matoken.eth). However, when you register via DNSSEC Registrars, the parent domain owner may not exist if you are the first person to register under the TLD.Gas costSubmitting proof to DNSSEC Oracle takes up a lot of gas because it is heavy computation work. It will take up even more gas if you submit the first domain under the specific TLD. This is because it submits proof of both your domain and its parent domain(eg: matoken.live, as well as .live). When tested on Ropsten network, it cost 1,663,953 gas​Typescript/Javascript LibrariesTo help you interact with DNSSEC data and the DNSRegistrar, we provide two libraries.​DNSProvejs = A library for querying and validating DNSSEC data from DNS​dnssecoraclejs = A library for generating proof data for the ENS DNSSEC Oracle.ExamplesRetrieving proof from DNSimport { Oracle } from '@ensdomains/dnssecoraclejs'import { DNSProver } from '@ensdomains/dnsprovejs'​const textDomain = '_ens.matoken.xyz'const prover = DNSProver.create(""https://cloudflare-dns.com/dns-query"")const result = await prover.queryWithProof('TXT', textDomain)Retrieving the DNS text recordconst result = { answer: SignedSet { records: [{ name: '_ens.matoken.xyz', type: 'TXT', ttl: 300, class: 'IN', flush: false, data: [Array] }], signature: { name: '_ens.matoken.xyz', type: 'RRSIG', ttl: 300, class: 'IN', flush: false, data: [Object] } }, proofs: [ SignedSet { records: [Array], signature: [Object] }, SignedSet { records: [Array], signature: [Object] }, SignedSet { records: [Array], signature: [Object] }, SignedSet { records: [Array], signature: [Object] }, SignedSet { records: [Array], signature: [Object] } ]}​// Retrieving the text recordresult.answer.records[0].data.toString()// 'a=0xa5313060f9fa6b607ac8ca8728a851166c9f612'queryWithProof returns answer and proofs. answer contains the human-readable record of the DNS record and its signing signature (RRSIG). The example above shows that the leaf of the chain (the first returned record) contains the TXT record type in a=$ETHEREUM_ADDRESS format.Submitting the proof to the DNSRegistrarimport { Oracle } from '@ensdomains/dnssecoraclejs'import { abi } from '@ensdomains/contracts/abis/dnsregistrar/DNSRegistrar.json'import { Contract } from 'ethers'​// The registrar address nees to be hard-codedconst registrarAddress = '0x475e527d54b91b0b011DA573C69Ac54B2eC269ea'const registrar new Contract(registrarAddress, abi, provider)const oracleAddress = await registrar.oracle()const oracle = new Oracle(oracleAddress, provider)const { data, proof } = oracle.getProofData(result)​if(data.length === 0){ // This happens if someone has submitted the proof directly to DNSSECOracle, hence only claim a name on the registrar. return registrar.claim(claim.encodedName, proof)}else{ // This submits proof to DNSSECOracle, then claim a name. return registrar.proveAndClaim(claim.encodedName, data, proof)}TodoIt is currently missing the Typescript/JS library support to delete the record from DNSSECOracle by providing NSEC/NSEC3(Next Secure Record) proof.PreviousControllerNext - Contract API ReferenceSubgraphLast modified 1yr agoCopy linkEdit on GitHubOn this pageDeployed DNSRegistrar addressesGas costTypescript/Javascript LibrariesExamplesRetrieving proof from DNSRetrieving the DNS text recordSubmitting the proof to the DNSRegistrarTodo "
60,mains ens improvement proposals ensip 11 evmchain address resolution,"mains ens improvement proposals ensip 11 evmchain address resolution.   ENSIP-11: EVM compatible Chain Address Resolution - ENS Documentation    ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsENSIP-1: ENSENSIP-2: Initial Hash RegistrarENSIP-3: Reverse ResolutionENSIP-4: Support for contract ABIsENSIP-5: Text RecordsENSIP-6: DNS-in-ENSENSIP-7: Contenthash fieldENSIP-8: Interface DiscoveryENSIP-9: Multichain Address ResolutionENSIP-10: Wildcard ResolutionENSIP-11: EVM compatible Chain Address ResolutionENSIP-12: Avatar Text RecordsENSIP-13: SAFE Authentication for ENSENSIP-14: On-chain Source ParameterDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookENSIP-11: EVM compatible Chain Address ResolutionIntroduces coinType for EVM compatible chains (amending ENSIP9).AuthorMakoto Inoue <[email protected]>StatusDraftSubmitted2022-01-13AbstractThis ENSIP extends ENSIP 9 (multichain address resolution), dedicates a range of coin types for EVM compatible chains, and specifies a way to derive EVM chain IDs to the designated coin types.The dedicated range uses over 0x80000000 (2147483648) which is reserved under ENSIP 9 so there will be no possibility of coin type collision with other non EVM coin types to be added in future. However, some of coin types previously allocated to EVM chain ides will be deprecated.MotivationThe existing ENSIP 9 relies on the existence of coin types on SLIP44 which was designed to define address encoding type for deterministic wallets. As the majority of EVM compatible chains inherit the same encoding type as Ethereum, it is redundant to keep requesting the addition of EVM compatible chains into SLIP 44. This specification standardises a way to derive coinType based on Chain ID.SpecificationThis specification amends ENSIP 9 to specify that coin types with the most-significant bit set are to be treated as EVM chain IDs. The MSB is reserved in SLIP44 for other purposes relating to HD wallet key derivation, so no coin types exist in this range.To compute the new coin type for EVM chains, bitwise-OR the chain ID with 0x80000000: 0x80000000 | chainId.export const convertEVMChainIdToCoinType = (chainId: number) =>{ return (0x80000000 | chainId) >>> 0}And to reverse the operation, bitwise-AND the cointType with 0x7fffffff: 0x7fffffff & coinType.export const convertCoinTypeToEVMChainId = (coinType: number) =>{ return (0x7fffffff & coinType) >> 0}ImplementationAn implementation of this interface is provided in the ensdomains/address-encoder repository.ExampleTo compute the new coin type for EVM chains, call convertEVMChainIdToCoinType(chainId)const encoder = require('@ensdomains/address-encoder')> encoder.convertEVMChainIdToCoinType(61)2147483709> encoder.convertCoinTypeToEVMChainId(2147483709)61You can also use existing functions formatsByName and formatsByCoinType to derive these chain IDs> encoder.formatsByName['XDAI']{ coinType: 2147483748, decoder: [Function (anonymous)], encoder: [Function (anonymous)], name: 'XDAI'}> encoder.formatsByCoinType[2147483748]{ coinType: 2147483748, decoder: [Function (anonymous)], encoder: [Function (anonymous)], name: 'XDAI'}ExceptionsThe following EVM chains are the exception to this standard.AVAX = AVAX has multiple chain address formats, and only c chain is EVM compatibleRSK = RSK has its own additional validationThey will continue using coinType defined at SLIP44Backwards CompatibilityThe following EVM compatible cointypes existed before introducing this new standard.NRGPOATTCELOCLOTOMOEWTTHETAGOFTMXDAIETCWhen you display them for backward compatibility purposes, append _LEGACY to the cointype and make them read only.CopyrightCopyright and related rights waived via CC0.PreviousENSIP-10: Wildcard ResolutionNextENSIP-12: Avatar Text RecordsLast modified 1yr agoCopy linkEdit on GitHubOn this pageAbstractMotivationSpecificationCopyright "
61,mains v governance governance proposals term 3 ep3.1.3 social q1 q2 2023 funding request public goods working group,"mains v governance governance proposals term 3 ep3.1.3 social q1 q2 2023 funding request public goods working group.   [EP3.1.3] [Social] Q1/Q2 2023 Funding Request: Public Goods Working Group - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1Term 2Term 3[EP3.1.1] [Social] Q1/Q2 2023 Funding Request: ENS Ecosystem Working Group[EP3.1.2] [Social] Q1/Q2 2023 Funding Request: Meta-Governance Working Group[EP3.1.3] [Social] Q1/Q2 2023 Funding Request: Public Goods Working Group[EP3.2] [Executable] Q1/Q2 2023 Working Group Funding[EP3.3] [Executable] Sell ETH to USDC[EP3.4] [Executable] Fund the Endowment (first tranche)Powered By GitBook[EP3.1.3] [Social] Q1/Q2 2023 Funding Request: Public Goods Working GroupThis is a proposal to request funding for the Public Goods Working Group for Q1/Q2 2023.StatusPassedDiscussion Thread​Discuss​Votes​Snapshot​Author​Coltron.eth​AbstractThe Public Goods Working Group requests funding of 250,000 USDC and 50 ETH from the ENS DAO for Q1/Q2 2023.This funding will be used to support projects and builders as provisioned by Article III of the ENS DAO Constitution, which provides for the funding of public goods in web3.This social proposal is submitted to satisfy the requirements set out in Rule 10.1.1 of the Working Group Rules (EP 1.8). If this proposal is passed the funding request will be included in a collective executable proposal put forward by all three Working Groups.SpecificationTextUSDCETH$ENSPublic Goods Multisig250,00050-DescriptionPublic Goods Multisig BalanceThe Public Goods Working Group is requesting 250,000 USDC, 50 ETH, and 0 $ENS.The Public Goods Working Group currently has 146,548 USDC, 75 ETH, and 200 $ENS in its multisigs.If this funding request is approved, the Public Goods Working Group multisigs will have a total of 396,548 USDC, 125 ETH, and 200 $ENS. USDCETH$ENSCarried Forward (from Q3/Q4 2022)146,54875200Requested (for Q1/Q2 2023)250,000500Total Balance396,548125200Public Goods Multisig Allocations for Q1/Q2 2023 (with funding request approved)The table below shows the total allocations for the Public Goods Working Group multisig, and related pods, with funds carried forward from last term (Q3/Q4 2022) along with funds requested in this proposal for this term (Q1/Q2 2023). USDCETH$ENSSmall Grants-50-Gitcoin Grants100,000--Rapid Grants50,00010-Large Grants200,00050-Discretionary46,54815200Total Balance396,548125200Allocation of Requested FundsThe 250,000 USDC and 50 ETH will be allocated to the following initiatives/outcomes.TextUSDCETH$ENSSmall Grants-40-Gitcoin Grants50,000--Rapid Grants50,00010-Large Grants150,000--Discretionary---Total Requested Funds250,00050-Description of Initiatives/PodsInitiative/PodDescriptionMultisig SignerSmall GrantsETH for the top Public Goods proposals submitted to ensgrants.xyzPublic Goods stewardsGitcoin GrantsSupport for Open Source and Ethereum Infrastructure rounds by Gitcoin through their grants protocolPublic Goods stewardsRapid GrantsGrants up to $10k each for web3 public goodsPublic Goods stewardsLarge GrantsGrants up to $100k each for web3 public goodsPublic Goods stewardsDiscretionaryFunds distributed at the discretion of stewards towards new initiatives + public goods experimentsPublic Goods stewardsThis proposal was prepared by Coltron.eth, lead steward of the Public Goods Working Group.Previous[EP3.1.2] [Social] Q1/Q2 2023 Funding Request: Meta-Governance Working GroupNext[EP3.2] [Executable] Q1/Q2 2023 Working Group FundingLast modified 1mo agoCopy linkEdit on GitHubOn this pageAbstractSpecificationDescription "
62,mains v governance governance proposals term 0 ep4 social proposal creation of foundational working groups and working group rules,"mains v governance governance proposals term 0 ep4 social proposal creation of foundational working groups and working group rules.   [EP0.4] [Social] Proposal: Creation of Foundational Working Groups and Working Group Rules - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0[EP0.1] [Social] Proposal: Transfer ENS Treasury and Contract Ownership[EP0.2] [Executable] Retrospective airdrop for accounts that owned another account’s primary ENS 1[EP0.3] [Social] Amend airdrop proposal to include accidentally returned funds[EP0.4] [Social] Proposal: Creation of Foundational Working Groups and Working Group RulesTerm 1Term 2Term 3Powered By GitBook[EP0.4] [Social] Proposal: Creation of Foundational Working Groups and Working Group RulesCreates four foundational working groups and establish rules related to the creation, management, and dissolution of working groups within the ENS DAO.StatusPassedDiscussion Thread​Discuss​Votes​Snapshot passed on 2021-12-18Note: This was previously numbered EP4.AbstractThe work-related activities of the ENS DAO will take place within working groups. Each working group will have a specific focus area and mission, aligned with the constitution and needs of the DAO.This proposal establishes four foundational working groups:1.Meta-Governance: providing governance oversight and support of the management and operation of the ENS DAO and working groups;2.ENS Ecosystem: continuing development and improvement of the ENS protocol and ecosystem, with a focus on all technical matters related to ENS;3.Community: supporting the people and organizations that are users of ENS, with a focus on non-technical matters; and4.Public Goods: amplifying ENS as a public good and funding public goods within the ENS ecosystem, and more broadly within web3.This proposal also sets out rules related to the creation and dissolution of working groups and outlines how working groups will be managed within the DAO.MotivationEstablishing working groups to manage DAO-related work will allow decisions to be made, and action to be taken, without the need for every initiative or decision of the DAO to be passed as a proposal.The creation of working groups will streamline the management of the DAO into core areas that will persist, irrespective of changes in activities or contributors. A working group system will promote stability and encourage long-term thinking and planning.The working group structure will provide new and existing community members clear onboarding pathways for meaningful participation and engagement in the DAO.SpecificationCreate four foundational working groups and establish rules related to the creation, management, and dissolution of working groups within the ENS DAO (‘DAO’).1.Working Groups1.Four foundational working groups will be established within the DAO:1.Meta-Governance Working Group;2.ENS Ecosystem Working Group;3.Community Working Group; and4.Public Goods Working Group.2.Formation of Working Groups1.To create a new working group, a social proposal, as defined by the ENS governance documentation (‘Social Proposal’), must be put forward and passed by the DAO.2.A Social Proposal to create a new working group must demonstrate that the new working group is needed and the work cannot be undertaken within an existing working group.3.Dissolution of Working Groups1.A working group can be dissolved by passing a Social Proposal requesting the dissolution of a working group or working groups.2.If an active proposal is put forward to dissolve a working group, all working group funds, including outgoing payments, within that working group, are to be frozen with immediate effect, pending the outcome of the vote.3.Upon the dissolution of a working group, any and all unspent working group funds from that working group, at the time of dissolution, must be immediately returned to the DAO treasury, without delay.4.Working Group Stewards1.Each working group shall be managed by five stewards (hereafter a ‘Steward’ or ‘Stewards’).2.Stewards will be elected, unless otherwise stated in these rules, to serve within working groups for a set period of time (hereafter known as a ‘Term’ or ‘Terms’).3.There are two Terms each calendar year:1.The first Term commences at 9am UTC on January 1 each year and ends immediately prior to the commencement of the second Term (‘First Term’); and2.The second Term commences at 9am UTC on July 1 each year and ends immediately prior to the commencement of the First Term of the following year (‘Second Term’).4.Stewards are responsible for managing the operations of each working group.5.The responsibilities of Stewards include, but are not limited to:1.Managing operational tasks related to the administration of a working group;2.Maintaining a description that sets forth the focus and intent of the working group;3.Developing working group goals for the Term and providing a clear road map for achieving those goals, to be published in the ENS governance forum within the first 30 days of a Term;4.Approving the creation and dissolution of sub-groups or workstreams within a working group to undertake work and/or carry out specific projects or tasks;5.Requesting working group funds from the DAO; and6.Approving and making funding available to sub-groups, workstreams, or contributors within a working group.6.To request working group funds, Stewards of all working groups will collaborate to submit an active executable proposal, as defined by the ENS governance documentation ('Collective Proposal'), to the DAO within the final 15 days (inclusive) of the months of January, March, July, and October each calendar year (each a ‘Funding Window’).1.In order for a working group to have a funding request included in a Collective Proposal submitted to the DAO during a Funding Window, the funding request must have passed as a Social Proposal in the same Funding Window.2.In the case of an emergency, where working group funds are needed by a working group outside of a Funding Window, an Executable Proposal may be submitted at any time by a Steward of a working group to request funds from the DAO.5.Steward Eligibility and Nominations1.Any individual is eligible to nominate themselves to be a Steward of a working group within the DAO (‘Eligible Person’ or ‘Eligible Persons’).2.To be eligible to be included in the ballot for First Term elections of a given year, Eligible Persons must nominate themselves between 9am UTC on December 6 and 9am UTC on December 9 (‘First Term Nomination Window’).3.To be eligible to be included in the ballot for Second Term elections of a given year, Eligible Persons must nominate themselves between 9am UTC on June 6 and 9am UTC on June 9 (‘Second Term Nomination Window’).4.An Eligible Person may nominate themselves to become a Steward of a working group or working groups during the First Term Nomination Window or the Second Term Nomination Window (each a ‘Nomination Window’), by meeting the requirements set out in a call for nominations posted in the relevant working group category of the ENS governance forum.5.An Eligible Person who completes the steps outlined in rule 5.4 above during a Nomination Window and receives 10,000 signed votes to support their nomination will be included in the ballot as a nominee in the election for Stewards that takes place following that Nomination Window (‘Nominee’).6.Steward Elections1.Elections for working group Stewards for the First Term of a given year will take place by a ranked-choice vote of governance token holders using signed messages and will be open for 120 hours, commencing at 9am UTC on December 10 each year (‘First Term Election Window’).2.Elections for working group Stewards for the Second Term of a given year will take place by a ranked-choice vote of governance token holders using signed messages and will be open for 120 hours, commencing at 9am UTC on June 10 each year (‘Second Term Election Window’).3.The top-ranked Nominees from each working group vote held during a First Term Election Window or a Second Term Election Window (each an 'Election Window'), will fill any available positions for the role of Steward for those working groups for the Term immediately following an Election Window, based on the order in which they are ranked in each working group vote.4.A Nominee elected to serve as a Steward may not take up the role of Steward for more than two working groups during a single Term.7.Delay of Nominations or Elections1.In the event that nominations or elections for Stewards take place after a Nomination Window or after an Election Window, the nomination process or elections shall take place, as otherwise prescribed in rules 5 and 6 above, as soon as is practicable after the missed Nomination Window or missed Election Window.2.In the event that an election takes place outside of an Election Window and after the commencement date of a new Term, outgoing Stewards from the previous Term shall stay in their positions as working group Stewards until immediately prior to 9am UTC the day following the end of the election, which, for the avoidance of doubt, is 120 hours after voting in those elections commenced.3.In the event that an election takes place outside of an Election Window and after the commencement date of a new Term, newly elected Stewards will assume the responsibilities of stewardship within working groups at 9am UTC the day following the end of the election, as defined in rule 7.2 above, for the remainder of that Term.8.Core Team Stewards1.For the First Term, commencing January 1 2022 at 9am UTC, each working group will include two Stewards who are core team members of True Names Limited (Singapore) (‘TNL’), as selected by TNL and not subject to the Steward nomination and election process outlined in rules 5 and 6 above.2.For the Second Term, commencing July 1 2022 at 9am UTC, each working group will include one Steward who is a core team member of TNL, as selected by TNL and not subject to the Steward nomination and election process outlined in rules 5 and 6 above.3.For the First Term of the following year, commencing January 1 2023, and for all Terms thereafter, all Stewards must be elected and appointed in accordance with the rules set out in rules 5 and 6 above.9.Removal and Replacement of Stewards1.Stewards may be removed at any time by:1.a Social Proposal passed by the DAO; or2.a simple indicative majority vote among the Stewards of a given working group, with the outcome of the vote communicated in the relevant working group category of the ENS governance forum.2.Stewards may step down from their position at any time by communicating their intention to step down in the ENS governance forum.3.In the event that a Steward is removed, steps down, or is unable to continue as a Steward, for whatever reason, prior to the end of a Term, any vacant positions will be filled for the remainder of a Term by the next highest ranked Nominee(s) in a given working group from the most recent working group vote in the most recent election for Stewards.4.In the event that a Steward steps down or is removed prior to the end of a Term and is a member of the core team of TNL in accordance with rule 8.1 or 8.2 above, the vacant position(s) will be filled by a core team member or team members of TNL, as selected by TNL.5.Any Steward selected by TNL in accordance with rule 8.1 or 8.2 above, can be removed by TNL at any time prior to the end of a Term, for any reason, and replaced by another core team member for the remainder of that Term.10.Compensation for Stewards1.Elected Stewards are eligible to receive fair compensation for their work as a Steward.2.All requests for Steward compensation must be detailed in a Collective Proposal for working group funds submitted to the DAO in accordance with rule 4.6.3.Stewards may not receive compensation for their role as a Steward outside of that compensation expressly provided for in a Collective Proposal submitted to the DAO in accordance with rule 10.2.4.Stewards selected by TNL are not eligible to receive compensation from the DAO or working groups for their work as a Steward.11.Amendments1.These rules may be amended at any time by passing a Social Proposal.Next StepsThis proposal will be open for voting on Snapshot for five days. This vote will be a single choice vote. You may vote 'for' or 'against' the proposal, or choose to abstain from the vote.By voting 'for' this proposal, you are voting in favor of creating four foundational working groups and establishing rules related to the creation, management, and dissolution of working groups within the ENS DAO, as provided in this proposal.Given the time of year, Steward nominations and elections for the First Term of 2022 will be delayed until the beginning of 2022.The Nomination Window for the First Term of 2022 will be open between 9am UTC on January 5, 2022 and 9am UTC on January 8, 2022. Any individual is eligible to nominate themselves to be a Steward of a working group or working groups during this Nomination Window. All Eligible Persons who satisfy the requirements set out in rule 5.4 and 5.5 will be included on the ballot for the First Term elections. More details about the nomination process will be available in the call for nominations released prior to the Nomination Window opening.The Election Window for the First Term of 2022 will be open for 120 hours, commencing at 9am UTC on January 10 2022. Following the election, in accordance with rule 7.3, newly elected Stewards will assume the responsibilities of stewardship within working groups at 9am UTC on January 16, 2022, for the remainder of the First Term.To stay up to date on developments regarding working groups, please follow the DAO-Bulletin channel in the ENS Discord Server and follow @ens_dao on Twitter.Previous[EP0.3] [Social] Amend airdrop proposal to include accidentally returned fundsNextTerm 1Last modified 6mo agoCopy linkEdit on GitHubOn this pageAbstractMotivationSpecificationNext Steps "
63,mains contract developer guide resolving names on chain,"mains contract developer guide resolving names on chain.   Resolving Names On-chain - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookResolving Names On-chainSolidity libraries for on-chain resolution are not yet available, but ENS resolution is straightforward enough it can be done trivially without a library. First, we define some pared-down interfaces containing only the methods we need:abstract contract ENS { function resolver(bytes32 node) public virtual view returns (Resolver);}​abstract contract Resolver { function addr(bytes32 node) public virtual view returns (address);}For resolution, only the resolver function in the ENS contract is required; other methods permit looking up owners and updating ENS from within a contract that owns a name.With these definitions, looking up a name given its node hash is straightforward:contract MyContract { // Same address for Mainet, Ropsten, Rinkerby, Gorli and other networks; ENS ens = ENS(0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e);​ function resolve(bytes32 node) public view returns(address) {  Resolver resolver = ens.resolver(node);  return resolver.addr(node); }}While it is possible for a contract to process a human-readable name into a node hash, we highly recommend working with node hashes instead, as they are easier and more efficient to work with, and allow contracts to leave the complex work of normalizing the name to their callers outside the blockchain. Where a contract always resolves the same names, those names may be converted to a node hash and stored in the contract as a constant.PreviousQuery ExamplesNext - Contract Developer GuideWriting a ResolverLast modified 1yr agoCopy linkEdit on GitHub "
64,mains contract api reference,"mains contract api reference.   Name Processing - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookName ProcessingDescribes how to normalize and hash ENS names.In place of human-readable names, ENS works purely with fixed length 256-bit cryptographic hashes. In order to derive the hash from a name while still preserving its hierarchal properties, a process called Namehash is used. For example, the namehash of 'alice.eth' is 0x787192fc5378cc32aa956ddfdedbf26b24e8d78e40109add0eea2c1a012c3dec; this is the representation of names that is used exclusively inside ENS.Before being hashed with namehash, names are first normalized, using a process called UTS-46 normalization. This ensures that upper- and lower-case names are treated equivalently, and that invalid characters are prohibited. Anything that hashes and resolves a name must first normalize it, to ensure that all users get a consistent view of ENS.Normalising NamesBefore a name can be converted to a node hash using Namehash, the name must first be normalized and checked for validity - for instance, converting fOO.eth into foo.eth, and prohibiting names containing forbidden characters such as underscores. It is crucial that all applications follow the same set of rules for normalization and validation, as otherwise two users entering the same name on different systems may resolve the same human-readable name into two different ENS names.Applications using ENS and processing human-readable names must follow UTS46 for normalization and validation. Processing should be done with non-transitional rules, and with UseSTD3ASCIIRules=true.The eth-ens-namehash Javascript library performs both normalization and hashing as described here. All of the ENS libraries covered in the DApp Developer Guide also perform normalization and hashing.Hashing NamesNamehash is a recursive process that can generate a unique hash for any valid domain name. Starting with the namehash of any domain - for example, 'alice.eth' - it's possible to derive the namehash of any subdomain - for example 'iam.alice.eth' - without having to know or handle the original human-readable name. It is this property that makes it possible for ENS to provide a hierarchal system, without having to deal with human-readable text strings internally.Terminologydomain - The complete, human-readable form of a name; eg, iam.alice.eth.label - A single component of a domain - eg, iam, alice, or eth.label hash - the output of the keccak-256 function applied to a label; eg, keccak256(‘eth’) = 0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0node - The output of the namehash function, used to uniquely identify a name in ENS.AlgorithmFirst, a domain is divided into labels by splitting on periods (‘.’). So, ‘vitalik.wallet.eth’ becomes the list [‘vitalik’, ‘wallet’, ‘eth’].The namehash function is then defined recursively as follows:namehash([]) = 0x0000000000000000000000000000000000000000000000000000000000000000namehash([label, …]) = keccak256(namehash(…), keccak256(label))A sample implementation in Python is provided below.def namehash(name): if name == '': return '\0' * 32 else: label, _, remainder = name.partition('.') return sha3(namehash(remainder) + sha3(label))Namehash is specified in EIP 137.How do I find the labelhash/namehash of a name?In some cases, you may need to know the hash of the name stored in ENS. labelhash means hash of the label of the domain (eg: makoto for makoto.eth) and namehash is the hash which combines labelhashes. We are currently working to include this information in our Manager app. In the meantime, you can query the information via https://thegraph.com/explorer/subgraph/ensdomains/ens with the following query.{ domains(where: {name:""vitalik.eth""}) { id name labelName labelhash }}Handling of Ambiguous NamesBecause of the large number of characters in unicode, and the wide variety of scripts represented, inevitably there are different Unicode characters that are similar or even identical when shown in common fonts. This can be abused to trick users into thinking they are visiting one site or resource, when in fact they are visiting another. This is known as a homoglyph attack.User agents and other software that display names to users should take countermeasures against these attacks, such as by highlighting problematic characters, or showing warnings to users about mixed scripts. Chromium’s IDNA strategy may serve as a useful reference for user-agent behaviour around rendering IDNA names.Dapp Developer Guide - PreviousENS Data guideNext - Contract API ReferenceRegistryLast modified 1yr agoCopy linkEdit on GitHubOn this pageNormalising NamesHashing NamesTerminologyAlgorithmHow do I find the labelhash/namehash of a name?Handling of Ambiguous Names "
65,mains contract api reference .eth permanent registrar registrar#name renewed,"mains contract api reference .eth permanent registrar registrar#name renewed.   Registrar - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarRegistrarControllerDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookRegistrar​Source​This contract implements the core functionality of the permanent registrar, with the following features:The owner of the registrar may add and remove 'controllers'.Controllers may register new domains and extend the expiry of (renew) existing domains. They can not change the ownership or reduce the expiration time of existing domains.Name owners may transfer ownership to another address.Name owners may reclaim ownership in the ENS registry if they have lost it.Owners of names in the legacy registrar may transfer them to the new registrar, during the 1 year transition period. When they do so, their deposit is returned to them in its entirety.This section documents the parts of the registrar interface relevant to implementers of tools that interact with it. Functionality exclusive to the registrar owner or to controllers is omitted for brevity.The registrar works exclusively with label hashes - the keccak256 of the first component of the label (eg, keccak256('ens') for ens.eth). For compatibility with ERC721, these are expressed as uint256 values rather than bytes32, but can be cast backwards and forwards transparently. The namehash of a name can be derived by computing keccak256(baseNode, labelHash), where basenode is the namehash of the TLD the registrar manages - eg, namehash('eth').Registrations and renewals are handled via the controller.Names and RegistrationsAll names inside ENS have an owner. The owner of a name can transfer the name to a new owner, set a resolver, and create and reassign subdomains. This functionality is all contained in the ENS registry.Allocation of names directly under .eth (eg, second-level domains ending with .eth, such as alice.eth) is governed by the .eth Permanent Registrar, described here. While buying a name from the registrar grants ownership of it in ENS, the registrar itself keeps independent track of who owns the registration. The concept of a registrant - the owner of a registration - is unique to the .eth permanent registrar.The registrant of a name can transfer the registration to another account, and they can recover ownership of the name by calling reclaim, which resets ownership of the ENS name to the registrant's account.Separating the concept of owning a name from owning a registration makes it possible to more easily build systems that make automated updates to ENS. The registrant can transfer ownership of the name to another account or to a smart contract that manages records, subdomains, etc, while still retaining the ability to recover ownership for upgrades, or in the case of a compromise.When thinking about ownership, it's important to be clear whether you're considering ownership of the name or the registration.Read OperationsGet Name Expiryfunction nameExpires(uint256 label) external view returns(uint);Returns the unix timestamp at which a registration currently expires. Names that do not exist or are not yet migrated from the legacy registrar will return 0.Check Name Availabilityfunction available(uint256 label) public view returns(bool);Returns true if a name is available for registration. Takes into account not-yet-migrated registrations from the legacy registrar. Registrar controllers may impose more restrictions on registrations than this contract (for example, a minimum name length), so this function should not be used to check if a name can be registered by a user. To check if a name can be registered by a user, check name availability via the controller.Get Transfer Period Enduint public transferPeriodEnds;transferPeriodEnds documents the unix timestamp at which it is no longer possible to migrate over registrations from the legacy registrar, and any non-migrated registrations become available for registration by anyone.Get Controller Statusmapping(address=>bool) public controllers;controllers allows callers to check if the supplied address is authorized as a registrar controller.Check Token Approvalfunction getApproved(uint256 tokenId) public view returns (address operator);Returns the address of the approved operator for this name.This function is part of ERC721.Check All Tokens Approvalfunction isApprovedForAll(address owner, address operator) public view returns (bool);Returns true if operator is authorized to transfer all tokens for owner.This function is part of ERC721.Get Name Ownerfunction ownerOf(uint256 label) external view returns(address);ownerOf returns the address that owns the registration identified by the label hash, or reverts if the registration does not exist. Registrations that have not yet been migrated from the legacy registrar are treated the same as registrations that do not exist.This function is part of ERC721.Write OperationsTransfer a Namefunction transferFrom(address from, address to, uint256 tokenId) public;function safeTransferFrom(address from, address to, uint256 tokenId) public;function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;These functions transfer the registration.They behave as specified in ERC721.Emits the following event on a successful transfer:event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);Approve Operatorfunction approve(address to, uint256 tokenId) public;function setApprovalForAll(address operator, bool _approved) public;These functions manage approvals as documented in ERC721.Reclaim ENS Recordfunction reclaim(uint256 label) external;Sets the owner record of the name in the ENS registry to match the owner of the registration in this registry. May only be called by the owner of the registration.EventsName Migratedevent NameMigrated(uint256 indexed hash, address indexed owner, uint expires);This event is emitted when a name is migrated from the legacy registrar.Name Registeredevent NameRegistered(uint256 indexed hash, address indexed owner, uint expires);This event is emitted when a controller registers a new name.Name Renewedevent NameRenewed(uint256 indexed hash, uint expires);This event is emitted when a controller renews (extends the registration of) a name.Transferevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);This event is emitted when registration is transferred to a new owner. This is distinct from the ENS Registry's Transfer event, which records transfers of ownership of the ENS record.Contract API Reference - Previous.eth Permanent RegistrarNextControllerLast modified 1yr agoCopy linkEdit on GitHubOn this pageNames and RegistrationsRead OperationsGet Name ExpiryCheck Name AvailabilityGet Transfer Period EndGet Controller StatusCheck Token ApprovalCheck All Tokens ApprovalGet Name OwnerWrite OperationsTransfer a NameApprove OperatorReclaim ENS RecordEventsName MigratedName RegisteredName RenewedTransfer "
66,mains dapp developer guide resolving names#looking up ethereum addresses,"mains dapp developer guide resolving names#looking up ethereum addresses.   Resolving Names - ENS Documentation    ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookResolving NamesThe ENS namespace includes both .eth names (which are native to ENS) and DNS names imported into ENS. Because the DNS suffix namespace expands over time, a hardcoded list of name suffixes for recognizing ENS names will regularly be out of date, leading to your application not recognizing all valid ENS names. To remain future-proof, a correct integration of ENS treats any dot-separated name as a potential ENS name and will attempt a look-up.Looking up cryptocurrency addressesNames can have many types of data associated with them; the most common is cryptocurrency addresses. ENS supports storing and resolving the addresses of any arbitrary blockchain.Resolving a name to an Ethereum address using a library is simple:ensjsweb3.jsethjs-ensethers.jsgo-ensweb3.pyweb3jvar address = await ens.name('resolver.eth').getAddress();var address = ens.getAddress('alice.eth');var address = await ens.lookup('alice.eth');var address = await provider.resolveName('alice.eth');ethers.js also supports using ENS names anywhere you would use an address, meaning you often do not need to directly call resolveName. For example, to look up an account's balance, you can do:var balance = await provider.getBalance('alice.eth');Or, to instantiate a contract:const abi = [ ""function getValue() view returns (string value)"", ""function setValue(string value)""];const contract = new ethers.Contract('contract.alice.eth', abi, provider);address, err := ens.Resolve(client, ""alice.eth"")address = ns.address('alice.eth')String address = ens.resolve(""alice.eth"");web3j also supports using ENS names anywhere you would use an address, meaning you often do not need to directly interact with the EnsResolver object. For example, to instantiate a contract interface, you can do:YourSmartContract contract = YourSmartContract.load( ""contract.alice.eth"", web3j, credentials, GAS_PRICE, GAS_LIMIT);Resolution without a library is a three step process:1.Normalise and hash the name - see name processing for details.2.Call resolver() on the ENS registry, passing in the output of step 1. This returns the address of the resolver responsible for the name.3.Using the resolver interface, call addr() on the resolver address returned in step 2, passing in the hashed name calculated in step 1.Resolution support for the addresses of other blockchains is implemented with an additional overload on addr(). To resolve a non-Ethereum address, supply both the namehash and the SLIP44 chain ID of the cryptocurrency whose address you want to resolve. For example, to resolve a Bitcoin address, you would call addr(hash, 0). Note that the returned address will be in binary representation, and so will need decoding to a text-format address; for details, see EIP 2304.If you are resolving addr() records, you MUST treat a return value from the resolver of 0x00…00 as that record being unset. Failing to do so could result in users accidentally sending funds to the null address if they have configured a resolver in ENS, but not set the resolver record!Looking up other resourcesENS supports many types of resources besides Ethereum addresses, including other cryptocurrency addresses, content hashes (hashes for IPFS, Skynet, and Swarm, and Tor .onion addresses), contract interfaces (ABIs), and text-based metadata. The process for looking these up varies from library to library; for specific details see your chosen library's documentation.Resolving these content types without a library follows the same 3-step process detailed above; simply call the relevant method on the resolver in step 3 instead of addr().ensjsweb3.jsethjs-ensethers.jsgo-ensweb3.pyweb3j// Getting contenthashawait ens.name('abittooawesome.eth').getContent()// Setting contenthashawait ens.name('abittooawesome.eth').setContenthash(contentHash)​// Getting other coinsawait ens.name('brantly.eth').getAddress('BTC')// Setting other coinsawait ens.name('superawesome.eth').setAddress('ETC', '0x0000000000000000000000000000000000012345')// Getting textawait ens.name('resolver.eth').getText('url')// Setting textawait ens.name('superawesome.eth').setText('url', 'http://google.com')// Getting contenthashweb3.eth.ens.getContenthash('ethereum.eth').then(function (result) { console.log(result);});// Setting contenthashweb3.eth.ens.setContenthash('ethereum.eth', hash);Not supported. const resolver = await provider.getResolver('abittooawesome.eth'); const contentHash = await resolver.getContentHash(); const btcAddress = await resolver.getAddress(0); const dogeAddress = await resolver.getAddress(3); const email = await resolver.getText(""email"");// Encodingbin, err := ens.StringToContenthash(""/ipfs/QmayQq2DWCkY3d4x3xKh4suohuRPEXe2fBqMBam5xtDj3t"")// Setting contenthashresolver.SetContenthash(opts, data)// Getting contenthashresolver.Contenthash()// Decodingrepr, err := ens.ContenthashToString(bin)​// Getting MulticoinbtcAddress, err := resolver.MultiAddress(0)// Setting Multicoinresolver.SetMultiAddress(opts, address)​// Setting textresolver.SetText(opts, name, value)// Getting textresolver.Text(name)Not supported.Not supported.Encoding and decoding contenthashcontenthash is used to store IPFS and Swarm content hashes, which permit resolving ENS addresses to distributed content (eg, websites) hosted on these distributed networks. content-hash javascript library provides a convenient way to encode/decode these hashes. const contentHash = require('content-hash')const encoded = 'e3010170122029f2d17be6139079dc48696d1f582a8530eb9805b561eda517e22a892c7e3f1f'const content = contentHash.decode(encoded)// 'QmRAQB6YaCyidP37UdDnjFY5vQuiBrcqdyoW1CuDgwxkD4'​const onion = 'zqktlwi4fecvo6ri'contentHash.encode('onion', onion);// 'bc037a716b746c776934666563766f367269'​const encoded = 'e40101701b20d1de9994b4d039f6548d191eb26786769f580809256b4685ef316805265ea162'​const codec = contentHash.getCodec(encoded) // 'swarm-ns'codec === 'ipfs-ns' // falseNote for ipns: For security reasons, the encoding of ipns is only allowed for libp2p-key codec. Decoding with other formats will show a deprecation warning. Please read here for more detail.Coin type and encoding/decodingWhile some libraries allow you to query cryptocurrency addresses via their symbol (e.g.: BTC), others do not have the built-in support, and you have to call via each coin id (e.g.: 0 for BTC, 16 for `ETH). For Javascript/Typescript, we have @ensdomains/address-encoder library that allows you to convertimport { formatsByName, formatsByCoinType } from '@ensdomains/address-encoder';​formatsByName['BTC']// {// coinType: 0,// decoder: [Function (anonymous)],// encoder: [Function (anonymous)],// name: 'BTC'// }To save storage space as well as prevent users from setting wrong token address, the library has encoder and decoderconst data = formatsByName['BTC'].decoder('1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa');console.log(data.toString('hex')); // 76a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1888acconst addr = formatsByCoinType[0].encoder(data);console.log(addr); // 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNaListing cryptocurrency addresses and text recordsFor cryptocurrency addresses and text records, you need to know the coin type or key names to get the value. If you want to list down all the cryptocurrency addresses and text records the user has set, you have to either retrieve the information from Event or query via ENS subgraph.For example{ domains(where:{name:""vitalik.eth""}) { id name resolver{  texts  coinTypes } }}will return the following result{ ""data"": { ""domains"": [ { ""id"": ""0xee6c4522aab0003e8d14cd40a6af439055fd2577951148c14b6cea9a53475835"", ""name"": ""vitalik.eth"", ""resolver"": { ""coinTypes"": [ 60 ], ""texts"": [ ""url"" ] } } ] }}Reverse ResolutionWhile 'regular' resolution involves mapping from a name to an address, reverse resolution maps from an address back to a name. ENS supports reverse resolution to allow applications to display ENS names in place of hexadecimal addresses.Reverse resolution is accomplished via the special purpose domain addr.reverse and the resolver function name(). addr.reverse is owned by a special purpose registrar contract that allocates subdomains to the owner of the matching address - for instance, the address 0x314159265dd8dbb310642f98f50c066173c1259b may claim the name 314159265dd8dbb310642f98f50c066173c1259b.addr.reverse, and configure a resolver and records on it. The resolver in turn supports the name() function, which returns the name associated with that address.ENS does not enforce the accuracy of reverse records - for instance, anyone may claim that the name for their address is 'alice.eth'. To be certain that the claim is accurate, you must always perform a forward resolution for the returned name and check it matches the original address.Most libraries provide functionality for doing reverse resolution:ensjsweb3.jsethjs-ensethers.jsgo-ensweb3.pyweb3jconst address = '0x1234...';let ensName = null;({ name: ensName } = await ens.getName(address))// Check to be sure the reverse record is correct. skip check if the name is nullif(ensName == null || address != await ens.name(ensName).getAddress()) { ensName = null;}Not supported.var address = '0x1234...';var name = await ens.reverse(address);// Check to be sure the reverse record is correct.if(address != await ens.lookup(name)) { name = null;}var address = '0x1234...';var name = await provider.lookupAddress(address);// ethers.js automatically checks that the forward resolution matches.name, err := ens.ReverseResolve(client, common.HexToAddress(""0x1234..."")address = '0x1234...'name = ns.reverse(address)# Check to be sure the reverse record is correct.if address != ns.address(name): name = NoneString address = ""0x1234..."";String name = ens.reverseResolve(address);// Check to be sure the reverse record is correct.if(address != ens.resolve(name)) { name = null;}Reverse resolution without a library follows the same pattern as forward resolution: Get the resolver for 1234....addr.reverse(where 1234... is the address you want to reverse-resolve), and call the name() function on that resolver. Then, perform a forward resolution to verify the record is accurate.If you need to process many addresses (eg: showing reverse record of transaction histories), resolving both reverse and forward resolution for each item may not be practical. We have a seperate smart contract called ReverseRecords which allows you to lookup multiple names in one function call.const namehash = require('eth-ens-namehash');const allnames = await ReverseRecords.getNames(['0x123','0x124'])const validNames = allnames.filter((n) => namehash.normalize(n) === n )Make sure to compare that the returned names match with the normalised names to prevent from homograph attack as well as people simply using capital letters.Dapp Developer Guide - PreviousWorking with ENSNext - Dapp Developer GuideManaging NamesLast modified 6mo agoCopy linkEdit on GitHubOn this pageLooking up cryptocurrency addressesLooking up other resourcesEncoding and decoding contenthashCoin type and encoding/decodingListing cryptocurrency addresses and text recordsReverse Resolution "
67,mains v governance process,"mains v governance process.   Governance Process - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessModerator ChecklistsENS DAO ConstitutionThe ENS FoundationGovernance ProposalsPowered By GitBookGovernance ProcessAn overview of the ENS DAO's governance processes, and how you can get involved.This document is a suggested process for developing and advancing ENS Governance Proposals. It is a living document intended to be owned, modified and enforced by the ENS community.Venues​discuss.ens.domains is a Discourse forum for governance-related discussion. Community members must register for an account before sharing or liking posts. Registering for the forum allows community members to post in the general forum; for access to the working groups, fill out the participant request form.There are four workstream categories: Meta-Governance, Community, ENS Ecosystem, and Public Goods. Each category has subcategories for each of the steps of the governance process described below.Snapshot​Snapshot is a simple voting interface that allows users to signal sentiment off-chain. Votes on snapshot are weighted by the number of ENS delegated to the address used to vote.Governance portals​Tally is a governance portal that allows token holders to delegate their votes, and allows delegates to create and vote on binding proposals.There are also other governance interfaces that users can use to cast their votes:​Sybil​*Note: this is not a complete list, and should be updated by the community frequently.Getting Work DoneYou are probably here because you want the DAO to do something. The primary mechanism by which the DAO gets things done is via ""Requests for Proposal"" (RFPs). An RFP is a request from the DAO for contributors to offer to do work on its behalf, and receive compensation in return.Anyone who identifies a need can write an RFP, and if the RFP is passed, anyone can write a proposal in response and be awarded the work. Even if you believe you can do the work yourself, you will still need to pass an RFP in order to be awarded the work (and corresponding compensation) by the DAO.RFPs vary in detail and complexity. An RFP for improving the DAO's documentation may only be a paragraph or two long, and proposals for it will be equally short. At the other extreme, an RFP for managing the DAO's funds may be lengthy, and a successful proposal could be multiple pages justifying the proposer's ability to take on the job.The RFP ProcessRFPs all follow this process:1.Write a draft RFP (template here) and post it as a discussion thread in the appropriate working group on the DAO forum. At a minimum, RFPs must:a. Explain the need for the RFP and describe the work to be done - the scope of work and deliverables.b. Specify the requirements for a winning bid - criteria for selection.c. Provide a timeline for submissions and completion of the work.d. Nominate a party who will select a winning bid and approve & disburse compensation (the RFP manager). Normally this will be the working group who adopts the RFP.e. Specify a maximum budget for the RFP.2.Incorporate feedback from DAO participants into your draft. When you believe it is ready, tag the stewards of the working group and request they consider adopting it.3.If the stewards agree to adopt your RFP, they will decide if it can be paid out of WG funds, or if it needs a DAO wide vote.a. If the RFP can be paid out of WG funds, they will set a submission period and post it as an active RFP.b. Otherwise, the stewards will create an executable proposal (or, they may ask you to do this) asking the DAO as a whole to approve the RFP. The proposal should contain the RFP. The executable component should specify approvals from the DAO funds to the RFP manager in the amount of the maximum budget for the proposal.4.Once the RFP is approved - either by the WG or by a DAO-wide vote - the submission period begins. You or a WG steward should create a post on the DAO forum for proposals, and anyone can submit a proposal to this thread.5.Once the submission period is concluded, the RFP manager selects a winning bid. Normally the manager will be the stewards of the working group who has adopted your RFP.6.The author of the winning proposal commences the work. As they meet milestones specified in the RFP and their proposal, they can request compensation from the RFP manager, who disburses it from the allocated funds.Passing a ProposalTypes of ProposalThere are three main types of governance proposals you can make:1.​Executable Proposal: This is a proposal for a series of smart contract operations to be executed by accounts the DAO controls. These can include transfers of tokens as well as arbitrary smart contract calls. Examples of this include allocating funding to a workstream multisig wallet, or upgrading an ENS core contract. Executable proposals have a quorum requirement of 1% and require a minimum approval of 50% to pass.2.​Social Proposal: This is a proposal that asks for the agreement of the DAO on something that cannot be enforced onchain. Examples of this include a proposal to change the royalty percentage for the ENS secondary market on OpenSea, or a petition to the root keyholders. Social proposals have a quorum requirement of 1% and require a minimum approval of 50% to pass.3.​Constitutional Amendment: This is a social proposal that asks the DAO to amend the constitution. Your draft proposal should include a diff showing the exact changes you propose to make to the constitution. Rules for amending the constitution are set in the constitution itself, and currently require a quorum of 1% and a minimum approval of two thirds to pass.Phase 1: Temperature Check — DiscourseThe purpose of the Temperature Check is to determine if there is sufficient will to make changes to the status quo.To create a Temperature Check, ask a general, non-biased question to the community on discuss.ens.domains about a potential change (example: “Should ENS decrease registration costs for 3-letter domains?”). Forum posts should be in the ""DAO-wide -> Temperature Check"" category.Temperature checks are informal and optional; it's up to you to use the feedback to decide if you want to proceed further with your proposal.Phase 2: Draft Proposal — GitHubThe purpose of the Draft Proposal is to establish formal discussion around a potential proposal.To create a Draft Proposal, create a new governance proposal in the governance-docs repository on GitHub. Start by copying the template for an executable proposal, social proposal, or constitutional amendment, as appropriate. Once you have written your proposal, create a Draft Pull Request for it. Start a new post in the DAO-wide -> Draft Proposals"" category with a link to the PR for discussion.Reach out to your network to build support for the proposal. Discuss the proposal and solicit delegates to provide feedback on it. Be willing to respond to questions on the Draft Proposal topic and in comments on the pull request. Share your viewpoint, although try to remain as impartial as possible.If your proposal is an executable proposal, you will need to specify the actions your proposal will take while it is in draft stage. You may wish to wait until the proposal is stable before doing this. The executable proposal template explains how to do this.If your proposal is a constitutional amendment, you will need to produce a diff showing the exact changes you are proposing to make. The easiest way to do this is to go to the constitution, click ""Edit on GitHub"", then click the pencil icon to edit the document in a fork. You can then create a pull request via the GitHub UI and include this in your proposal. You should do this in a separate branch to your draft proposal; while the proposal will be merged as soon as it goes to a vote, the amendment will only be merged if the proposal passes.Once you are confident the proposal is in a stable state, you can proceed to phase 3.Phase 3: Active Proposal — Snapshot / Governance PortalUse GitHub to flag your PR as Ready for Review. A contributor will:1.Merge your PR if it meets the requirements.2.Assign your proposal a proposal number in the form EP###.3.Schedule the proposal for a snapshot vote.If your proposal is a Social Proposal or a Constitutional Amendment, that's it! If the snapshot vote passes, the proposal is passed and you are done.If your proposal is an Executable Proposal, you will now need to submit it to the governor contract for voting onchain.To enact an Executable Proposal:1.Ensure at least 100k ENS is delegated to your address in order to submit a proposal, or find a delegate who has enough delegated ENS to meet the proposal threshold to propose on your behalf.2.Call the propose() function of the ENS governor (at governor.ensdao.eth) to deploy your proposal.Once the propose() function has been called, a seven day voting period is started. Ongoing discussion can take place on your proposal post. If the proposal passes successfully, a two day timelock will follow before the proposed code is executed.Governance GlossaryENS: An ERC-20 token that designates the weight of a user’s voting rights. The more ENS a user has in their wallet, the more weight their delegation or vote on a proposal holds.Delegation: ENS holders cannot vote or create proposals until they delegate their voting rights to an address. Delegation can be given to one address at a time, including the holder’s own address. Note that delegation does not lock tokens; it simply adds votes to the chosen delegation address.Executable Proposal: An executable proposal is a type of proposal that is executed by the governance contract through timelock. It can replace the governance contract, transfer tokens from the community treasury, or perform an almost infinite range of other on-chain actions. In order to create a proposal, an address must have at least 0.1% (100k ENS) of all ENS delegated to their address. Proposals are stored in the “proposals” mapping of the Governor smart contract. All proposals are subject to a 7-day voting period.Quorum: In order for a vote to pass, a certain percentage of ENS tokens must vote in the affirmative. The current quorum requirements are:Executable Proposals: 1%Social Proposals: 1%Constitutional Amendments: 1%The purpose of this quorum is to ensure that the only measures that pass have adequate voter participation.Voting on Executable Proposals: Users can vote for or against single proposals once they have voting rights delegated to their address. Votes can be cast while a proposal is in the “Active” state. Votes can be submitted immediately using “castVote” or submitted later with “castVoteBySig” (For more info on castVoteBySig and offline signatures, see EIP-712). If the majority of votes (and a 1% quorum of ENS) vote for a proposal, the proposal may be queued in the Timelock.Voting Period: Proposals on Snapshot have a 5 day voting period. Once an executable proposal has been put forward, ENS community members will have a seven day period (the Voting Period) to cast their votes.Timelock: All governance actions are delayed for a minimum of 2 days by the timelock contract before they can be executed.PreviousWelcome to ENS DAONextModerator ChecklistsLast modified 10mo agoCopy linkEdit on GitHubOn this pageVenuesSnapshotGovernance portalsGetting Work DoneThe RFP ProcessPassing a ProposalTypes of ProposalPhase 1: Temperature Check — DiscoursePhase 2: Draft Proposal — GitHubPhase 3: Active Proposal — Snapshot / Governance PortalGovernance Glossary "
68,mains dapp developer guide working with ens,"mains dapp developer guide working with ens.   Working with ENS - ENS Documentation    ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookWorking with ENSBefore you can begin interacting with ENS, you will need to obtain a reference to the ENS registry. How you do this depends on the library you are using.Example code for the Javascript-based APIs (ensjs, web3.js, ethjs-ens, and ethers.js) here expect that they are being run inside a DApp browser, such as Chrome with metamask installed, which exposes the ethereum object.ensjsweb3.jsethjs-ensethers.jsgo-ensweb3.pyweb3jimport ENS, { getEnsAddress } from '@ensdomains/ensjs'​const ens = new ENS({ provider, ensAddress: getEnsAddress('1') })var Web3 = require(""web3"")​var accounts = ethereum.enable();var web3 = new Web3(ethereum);var ens = web3.eth.ens;const ENS = require('ethjs-ens');// Currently requires both provider and// either a network or registryAddress paramvar accounts = ethereum.enable();const ens = new ENS({ ethereum, network: '1' });var ethers = require('ethers');var provider = new ethers.providers.Web3Provider(ethereum);// ENS functionality is provided directly on the core provider object.import ( ens ""github.com/wealdtech/go-ens/v2"" ethereum ""github.com/ethereum/go-ethereum"")​// Can dial up a connection through either IPC or HTTP/HTTPSclient, err := ethereum.Dial(""/home/ethereum/.ethereum/geth.ipc"")registry, err := ens.Registry(client)from ens.auto import nsEnsResolver ens = new EnsResolver(web3j, 300 /* sync threshold, seconds */);Some web3 libraries - e.g., ethers.js, web3j, and web3.py - have integrated support for name resolution. In these libraries, you can pass in an ENS name anywhere you can supply an address, meaning you do not need to interact directly with their ENS APIs unless you want to manually resolve names or do other ENS operations.If no library is available for your platform, you can instantiate the ENS registry contract directly using the interface definition here. Addresses for the ENS registry on each supported network are available in the ENS Deployments page.Dapp Developer Guide - PreviousENS LibrariesNext - Dapp Developer GuideResolving NamesLast modified 1yr agoCopy linkEdit on GitHub "
69,mains ens improvement proposals ensip 13 secondary authentication for ens,"mains ens improvement proposals ensip 13 secondary authentication for ens.   ENSIP-13: SAFE Authentication for ENS - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsENSIP-1: ENSENSIP-2: Initial Hash RegistrarENSIP-3: Reverse ResolutionENSIP-4: Support for contract ABIsENSIP-5: Text RecordsENSIP-6: DNS-in-ENSENSIP-7: Contenthash fieldENSIP-8: Interface DiscoveryENSIP-9: Multichain Address ResolutionENSIP-10: Wildcard ResolutionENSIP-11: EVM compatible Chain Address ResolutionENSIP-12: Avatar Text RecordsENSIP-13: SAFE Authentication for ENSENSIP-14: On-chain Source ParameterDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookENSIP-13: SAFE Authentication for ENSUsing ENS Text Records to facilitate safer and more convenient signing operations.AuthorWilkins Chung (@wwhchung), Jalil Wahdatehagh (@jwahdatehagh), Cry (@crydoteth), Sillytuna (@sillytuna), Cyberpnk (@CyberpnkWin)StatusDraftSubmitted2022-08-03AbstractThis EIP links one or more signing wallets via Ethereum Name Service Specification (EIP-137) to prove control and asset ownership of a main wallet.MotivationProving ownership of an asset to a third party application in the Ethereum ecosystem is common. Users frequently sign payloads of data to authenticate themselves before gaining access to perform some operation. However, this method--akin to giving the third party root access to one's main wallet--is both insecure and inconvenient.Examples:1.In order for you to edit your profile on OpenSea, you must sign a message with your wallet.2.In order to access NFT gated content, you must sign a message with the wallet containing the NFT in order to prove ownership.3.In order to gain access to an event, you must sign a message with the wallet containing a required NFT in order to prove ownership.4.In order to claim an airdrop, you must interact with the smart contract with the qualifying wallet.5.In order to prove ownership of an NFT, you must sign a payload with the wallet that owns that NFT.In all the above examples, one interacts with the dApp or smart contract using the wallet itself, which may beinconvenient (if it is controlled via a hardware wallet or a multi-sig)insecure (since the above operations are read-only, but you are signing/interacting via a wallet that has write access)Instead, one should be able to approve multiple wallets to authenticate on behalf of a given wallet.Problems with existing methods and solutionsUnfortunately, we've seen many cases where users have accidentally signed a malicious payload. The result is almost always a significant loss of assets associated with the signing address.In addition to this, many users keep significant portions of their assets in 'cold storage'. With the increased security from 'cold storage' solutions, we usually see decreased accessibility because users naturally increase the barriers required to access these wallets.Some solutions propose dedicated registry smart contracts to create this link, or new protocols to be supported. This is problematic from an adoption standpoint, and there have not been any standards created for them.Proposal: Use the Ethereum Name Service (EIP-137)Rather than 're-invent the wheel', this proposal aims to use the widely adopted Ethereum Name Service in conjunction with the ENS Text Records feature (EIP-634) in order to achieve a safer and more convenient way to sign and authenticate, and provide 'read only' access to a main wallet via one or more secondary wallets.From there, the benefits are twofold. This EIP gives users increased security via outsourcing potentially malicious signing operations to wallets that are more accessible (hot wallets), while being able to maintain the intended security assumptions of wallets that are not frequently used for signing operations.Improving dApp Interaction SecurityMany dApps requires one to prove control of a wallet to gain access. At the moment, this means that you must interact with the dApp using the wallet itself. This is a security issue, as malicious dApps or phishing sites can lead to the assets of the wallet being compromised by having them sign malicious payloads.However, this risk would be mitigated if one were to use a secondary wallet for these interactions. Malicious interactions would be isolated to the assets held in the secondary wallet, which can be set up to contain little to nothing of value.Improving Multiple Device Access SecurityIn order for a non-hardware wallet to be used on multiple devices, you must import the seed phrase to each device. Each time a seed phrase is entered on a new device, the risk of the wallet being compromised increases as you are increasing the surface area of devices that have knowledge of the seed phrase.Instead, each device can have its own unique wallet that is an authorized secondary wallet of the main wallet. If a device specific wallet was ever compromised or lost, you could simply remove the authorization to authenticate.Further, wallet authentication can be chained so that a secondary wallet could itself authorize one or many tertiary wallets, which then have signing rights for both the secondary address as well as the root main address. This, can allow teams to each have their own signer while the main wallet can easily invalidate an entire tree, just by revoking rights from the root stem.Improving ConvenienceMany invididuals use hardware wallets for maximum security. However, this is often inconvenient, since many do not want to carry their hardware wallet with them at all times.Instead, if you approve a non-hardware wallet for authentication activities (such as a mobile device), you would be able to use most dApps without the need to have your hardware wallet on hand.SpecificationThe key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.Let:mainAddress represent the wallet address we are trying to authenticate or prove asset ownership for.mainENS represent the reverse lookup ENS string for mainAddress.authAddress represent the address we want to use for signing in lieu of mainAddress.authENS represent the reverse lookup ENS string for authAddress.authKey represents a string in the format [0-9A-Za-z]+.Control of mainAddress and ownership of mainAddress assets by authAddress is proven if all the following conditions are met:mainAddress has an ENS resolver record and a reverse record set to mainENS.authAddress has an ENS resolver record and a reverse record set to authENS.authENS has an ENS TEXT record eip5131:vault in the format <authKey>:<mainAddress>.mainENS has an ENS TEXT record eip5131:<authKey>.Setting up one or many authAddress records on a single ENS domainThe mainAddress MUST have an ENS resolver record and reverse record configured. In order to automatically discover the linked account, the authAddress SHOULD have an ENS resolver record and reverse record configured.1.Choose an unused <authKey>. This can be any string in the format [0-0A-Za-z]+.2.Set a TEXT record eip5131:<authKey> on mainENS, with the value set to the desired authAddress.3.Set a TEXT record eip5131:vault on authENS, with the value set to the <authKey>:mainAddress.Currently this EIP does not enforce an upper-bound on the number of authAddress entries you can include. Users can repeat this process with as many address as they like.Authenticating mainAddress via authAddressControl of mainAddress and ownership of mainAddress assets is proven if any associated authAddress is the msg.sender or has signed the message.Practically, this would work by performing the following operations:1.Get the resolver for authENS2.Get the eip5131:vault TEXT record of authENS3.Parse <authKey>:<mainAddress> to determine the authKey and mainAddress.4.MUST get the reverse ENS record for mainAddress and verify that it matches <mainENS>.Otherwise one could set up other ENS nodes (with auths) that point to mainAddress and authenticate via those.5.Get the eip5131:<authKey> TEXT record of mainENS and ensure it matches authAddress.Note that this specification allows for both contract level and client/server side validation of signatures. It is not limited to smart contracts, which is why there is no proposed external interface definition.Revocation of authAddressTo revoke permission of authAddress, delete the eip5131:<authKey> TEXT record of mainENS or update it to point to a new authAddress.RationaleUsage of EIP-137The proposed specification makes use of EIP-137 rather than introduce another registry paradigm. The reason for this is due to the existing wide adoption of EIP-137 and ENS.However, the drawback to EIP-137 is that any linked authAddress must contain some ETH in order to set the authENS reverse record as well as the eip5131:vault TEXT record. This can be solved by a separate reverse lookup registry that enables mainAddress to set the reverse record and TEXT record with a message signed by authAddress.With the advent of L2s and ENS Layer 2 functionalities, off chain verification of linked addresses is possible even with domains managed across different chains.One-to-Many Authentication RelationshipThis proposed specification allows for a one (mainAddress) to many (authAddress) authentication relationship. i.e. one mainAddress can authorize many authAddress to authenticate, but an authAddress can only authenticate itself or a single mainAddress.The reason for this design choice is to allow for simplicity of authentication via client and smart contract code. You can determine which mainAddress the authAddress is signing for without any additional user input.Further, you can design UX without any user interaction necessary to 'pick' the interacting address by display assets owned by authAddress and mainAddress and use the appropriate address dependent on the asset the user is attempting to authenticate with.Reference ImplementationClient/Server SideIn typescript, the validation function, using ethers.js would be as follows:export interface LinkedAddress { ens: string, address: string,}​export async function getLinkedAddress( provider: ethers.providers.EnsProvider, address: string): Promise<LinkedAddress | null> { const addressENS = await provider.lookupAddress(address); if (!addressENS) return null;​ const vaultInfo = await (await provider.getResolver(addressENS))?.getText('eip5131:vault'); if (!vaultInfo) return null;​ const vaultInfoArray = vaultInfo.split(':'); if (vaultInfoArray.length !== 2) { throw new Error('EIP5131: Authkey and vault address not configured correctly.'); }​ const [ authKey, vaultAddress ] = vaultInfoArray;​ const vaultENS = await provider.lookupAddress(vaultAddress); if (!vaultENS) { throw new Error(`EIP5131: No ENS domain with reverse record set for vault.`); };​ const expectedSigningAddress = await ( await provider.getResolver(vaultENS) )?.getText(`eip5131:${authKey}`);​ if (expectedSigningAddress?.toLowerCase() !== address.toLowerCase()) { throw new Error(`EIP5131: Authentication mismatch.`); };​ return { ens: vaultENS, address: vaultAddress };}Contract sideWith a backendIf your application operates a secure backend server, you could run the client/server code above, then use the result in conjunction with specs like EIP-1271 : Standard Signature Validation Method for Contracts for a cheap and secure way to validate that the the message signer is indeed authenticated for the main address.Without a backend (JavaScript only)Provided is a reference implementation for an internal function to verify that the message sender has an authentication link to the main address.// SPDX-License-Identifier: MIT​pragma solidity ^0.8.0;​/// @author: manifold.xyz​/** * ENS Registry Interface */interface ENS { function resolver(bytes32 node) external view returns (address);}​/** * ENS Resolver Interface */interface Resolver { function addr(bytes32 node) external view returns (address); function name(bytes32 node) external view returns (string memory); function text(bytes32 node, string calldata key) external view returns (string memory);}​/** * Validate a signing address is associtaed with a linked address */library LinkedAddress { /**  * Validate that the message sender is an authentication address for mainAddress  *  * @param ensRegistry Address of ENS registry  * @param mainAddress  The main address we want to authenticate for.  * @param mainENSNodeHash The main ENS Node Hash  * @param authKey   The TEXT record of the authKey we are using for validation  * @param authENSNodeHash The auth ENS Node Hash  */ function validateSender(  address ensRegistry,  address mainAddress,  bytes32 mainENSNodeHash,  string calldata authKey,  bytes32 authENSNodeHash ) internal view returns (bool) {  return validate(ensRegistry, mainAddress, mainENSNodeHash, authKey, msg.sender, authENSNodeHash); }​ /**  * Validate that the authAddress is an authentication address for mainAddress  *  * @param ensRegistry  Address of ENS registry  * @param mainAddress  The main address we want to authenticate for.  * @param mainENSNodeHash The main ENS Node Hash  * @param authAddress  The address of the authentication wallet  * @param authENSNodeHash The auth ENS Node Hash  */ function validate(  address ensRegistry,  address mainAddress,  bytes32 mainENSNodeHash,  string calldata authKey,  address authAddress,  bytes32 authENSNodeHash ) internal view returns (bool) {  _verifyMainENS(ensRegistry, mainAddress, mainENSNodeHash, authKey, authAddress);  _verifyAuthENS(ensRegistry, mainAddress, authKey, authAddress, authENSNodeHash);​  return true; }​ // ********************* // Helper Functions // ********************* function _verifyMainENS(  address ensRegistry,  address mainAddress,  bytes32 mainENSNodeHash,  string calldata authKey,  address authAddress ) private view {  // Check if the ENS nodes resolve correctly to the provided addresses  address mainResolver = ENS(ensRegistry).resolver(mainENSNodeHash);  require(mainResolver != address(0), ""Main ENS not registered"");  require(mainAddress == Resolver(mainResolver).addr(mainENSNodeHash), ""Main address is wrong"");​  // Verify the authKey TEXT record is set to authAddress by mainENS  string memory authText = Resolver(mainResolver).text(mainENSNodeHash, string(abi.encodePacked(""eip5131:"", authKey)));  require(   keccak256(bytes(authText)) == keccak256(bytes(_addressToString(authAddress))),   ""Invalid auth address""  ); }​ function _verifyAuthENS(  address ensRegistry,  address mainAddress,  string memory authKey,  address authAddress,  bytes32 authENSNodeHash ) private view {  // Check if the ENS nodes resolve correctly to the provided addresses  address authResolver = ENS(ensRegistry).resolver(authENSNodeHash);  require(authResolver != address(0), ""Auth ENS not registered"");  require(authAddress == Resolver(authResolver).addr(authENSNodeHash), ""Auth address is wrong"");​  // Verify the TEXT record is appropriately set by authENS  string memory vaultText = Resolver(authResolver).text(authENSNodeHash, ""eip5131:vault"");  require(   keccak256(abi.encodePacked(authKey, "":"", _addressToString(mainAddress))) ==    keccak256(bytes(vaultText)),   ""Invalid auth text record""  ); }​ bytes16 private constant _HEX_SYMBOLS = ""0123456789abcdef"";​ function sha3HexAddress(address addr) private pure returns (bytes32 ret) {  uint256 value = uint256(uint160(addr));  bytes memory buffer = new bytes(40);  for (uint256 i = 39; i > 1; --i) {   buffer[i] = _HEX_SYMBOLS[value & 0xf];   value >>= 4;  }  return keccak256(buffer); }​ function _addressToString(address addr) private pure returns (string memory ptr) {  // solhint-disable-next-line no-inline-assembly  assembly {   ptr := mload(0x40)​   // Adjust mem ptr and keep 32 byte aligned   // 32 bytes to store string length; address is 42 bytes long   mstore(0x40, add(ptr, 96))​   // Store (string length, '0', 'x') (42, 48, 120)   // Single write by offsetting across 32 byte boundary   ptr := add(ptr, 2)   mstore(ptr, 0x2a3078)​   // Write string backwards   for {    // end is at 'x', ptr is at lsb char    let end := add(ptr, 31)    ptr := add(ptr, 71)   } gt(ptr, end) {    ptr := sub(ptr, 1)    addr := shr(4, addr)   } {    let v := and(addr, 0xf)    // if > 9, use ascii 'a-f' (no conditional required)    v := add(v, mul(gt(v, 9), 39))    // Add ascii for '0'    v := add(v, 48)    mstore8(ptr, v)   }​   // return ptr to point to length (32 + 2 for '0x' - 1)   ptr := sub(ptr, 33)  }​  return string(ptr); }}Security ConsiderationsThe core purpose of this EIP is to enhance security and promote a safer way to authenticate wallet control and asset ownership when the main wallet is not needed and assets held by the main wallet do not need to be moved. Consider it a way to do 'read only' authentication.CopyrightCopyright and related rights waived via CC0.PreviousENSIP-12: Avatar Text RecordsNextENSIP-14: On-chain Source ParameterLast modified 5mo agoCopy linkEdit on GitHubOn this pageAbstractMotivationProblems with existing methods and solutionsProposal: Use the Ethereum Name Service (EIP-137)SpecificationSetting up one or many authAddress records on a single ENS domainAuthenticating mainAddress via authAddressRevocation of authAddressRationaleUsage of EIP-137One-to-Many Authentication RelationshipReference ImplementationClient/Server SideContract sideSecurity ConsiderationsCopyright "
70,mains v governance governance proposals ep4 social proposal creation of foundational working groups and working group rules,"mains v governance governance proposals ep4 social proposal creation of foundational working groups and working group rules.   [EP0.4] [Social] Proposal: Creation of Foundational Working Groups and Working Group Rules - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0[EP0.1] [Social] Proposal: Transfer ENS Treasury and Contract Ownership[EP0.2] [Executable] Retrospective airdrop for accounts that owned another account’s primary ENS 1[EP0.3] [Social] Amend airdrop proposal to include accidentally returned funds[EP0.4] [Social] Proposal: Creation of Foundational Working Groups and Working Group RulesTerm 1Term 2Term 3Powered By GitBook[EP0.4] [Social] Proposal: Creation of Foundational Working Groups and Working Group RulesCreates four foundational working groups and establish rules related to the creation, management, and dissolution of working groups within the ENS DAO.StatusPassedDiscussion Thread​Discuss​Votes​Snapshot passed on 2021-12-18Note: This was previously numbered EP4.AbstractThe work-related activities of the ENS DAO will take place within working groups. Each working group will have a specific focus area and mission, aligned with the constitution and needs of the DAO.This proposal establishes four foundational working groups:1.Meta-Governance: providing governance oversight and support of the management and operation of the ENS DAO and working groups;2.ENS Ecosystem: continuing development and improvement of the ENS protocol and ecosystem, with a focus on all technical matters related to ENS;3.Community: supporting the people and organizations that are users of ENS, with a focus on non-technical matters; and4.Public Goods: amplifying ENS as a public good and funding public goods within the ENS ecosystem, and more broadly within web3.This proposal also sets out rules related to the creation and dissolution of working groups and outlines how working groups will be managed within the DAO.MotivationEstablishing working groups to manage DAO-related work will allow decisions to be made, and action to be taken, without the need for every initiative or decision of the DAO to be passed as a proposal.The creation of working groups will streamline the management of the DAO into core areas that will persist, irrespective of changes in activities or contributors. A working group system will promote stability and encourage long-term thinking and planning.The working group structure will provide new and existing community members clear onboarding pathways for meaningful participation and engagement in the DAO.SpecificationCreate four foundational working groups and establish rules related to the creation, management, and dissolution of working groups within the ENS DAO (‘DAO’).1.Working Groups1.Four foundational working groups will be established within the DAO:1.Meta-Governance Working Group;2.ENS Ecosystem Working Group;3.Community Working Group; and4.Public Goods Working Group.2.Formation of Working Groups1.To create a new working group, a social proposal, as defined by the ENS governance documentation (‘Social Proposal’), must be put forward and passed by the DAO.2.A Social Proposal to create a new working group must demonstrate that the new working group is needed and the work cannot be undertaken within an existing working group.3.Dissolution of Working Groups1.A working group can be dissolved by passing a Social Proposal requesting the dissolution of a working group or working groups.2.If an active proposal is put forward to dissolve a working group, all working group funds, including outgoing payments, within that working group, are to be frozen with immediate effect, pending the outcome of the vote.3.Upon the dissolution of a working group, any and all unspent working group funds from that working group, at the time of dissolution, must be immediately returned to the DAO treasury, without delay.4.Working Group Stewards1.Each working group shall be managed by five stewards (hereafter a ‘Steward’ or ‘Stewards’).2.Stewards will be elected, unless otherwise stated in these rules, to serve within working groups for a set period of time (hereafter known as a ‘Term’ or ‘Terms’).3.There are two Terms each calendar year:1.The first Term commences at 9am UTC on January 1 each year and ends immediately prior to the commencement of the second Term (‘First Term’); and2.The second Term commences at 9am UTC on July 1 each year and ends immediately prior to the commencement of the First Term of the following year (‘Second Term’).4.Stewards are responsible for managing the operations of each working group.5.The responsibilities of Stewards include, but are not limited to:1.Managing operational tasks related to the administration of a working group;2.Maintaining a description that sets forth the focus and intent of the working group;3.Developing working group goals for the Term and providing a clear road map for achieving those goals, to be published in the ENS governance forum within the first 30 days of a Term;4.Approving the creation and dissolution of sub-groups or workstreams within a working group to undertake work and/or carry out specific projects or tasks;5.Requesting working group funds from the DAO; and6.Approving and making funding available to sub-groups, workstreams, or contributors within a working group.6.To request working group funds, Stewards of all working groups will collaborate to submit an active executable proposal, as defined by the ENS governance documentation ('Collective Proposal'), to the DAO within the final 15 days (inclusive) of the months of January, March, July, and October each calendar year (each a ‘Funding Window’).1.In order for a working group to have a funding request included in a Collective Proposal submitted to the DAO during a Funding Window, the funding request must have passed as a Social Proposal in the same Funding Window.2.In the case of an emergency, where working group funds are needed by a working group outside of a Funding Window, an Executable Proposal may be submitted at any time by a Steward of a working group to request funds from the DAO.5.Steward Eligibility and Nominations1.Any individual is eligible to nominate themselves to be a Steward of a working group within the DAO (‘Eligible Person’ or ‘Eligible Persons’).2.To be eligible to be included in the ballot for First Term elections of a given year, Eligible Persons must nominate themselves between 9am UTC on December 6 and 9am UTC on December 9 (‘First Term Nomination Window’).3.To be eligible to be included in the ballot for Second Term elections of a given year, Eligible Persons must nominate themselves between 9am UTC on June 6 and 9am UTC on June 9 (‘Second Term Nomination Window’).4.An Eligible Person may nominate themselves to become a Steward of a working group or working groups during the First Term Nomination Window or the Second Term Nomination Window (each a ‘Nomination Window’), by meeting the requirements set out in a call for nominations posted in the relevant working group category of the ENS governance forum.5.An Eligible Person who completes the steps outlined in rule 5.4 above during a Nomination Window and receives 10,000 signed votes to support their nomination will be included in the ballot as a nominee in the election for Stewards that takes place following that Nomination Window (‘Nominee’).6.Steward Elections1.Elections for working group Stewards for the First Term of a given year will take place by a ranked-choice vote of governance token holders using signed messages and will be open for 120 hours, commencing at 9am UTC on December 10 each year (‘First Term Election Window’).2.Elections for working group Stewards for the Second Term of a given year will take place by a ranked-choice vote of governance token holders using signed messages and will be open for 120 hours, commencing at 9am UTC on June 10 each year (‘Second Term Election Window’).3.The top-ranked Nominees from each working group vote held during a First Term Election Window or a Second Term Election Window (each an 'Election Window'), will fill any available positions for the role of Steward for those working groups for the Term immediately following an Election Window, based on the order in which they are ranked in each working group vote.4.A Nominee elected to serve as a Steward may not take up the role of Steward for more than two working groups during a single Term.7.Delay of Nominations or Elections1.In the event that nominations or elections for Stewards take place after a Nomination Window or after an Election Window, the nomination process or elections shall take place, as otherwise prescribed in rules 5 and 6 above, as soon as is practicable after the missed Nomination Window or missed Election Window.2.In the event that an election takes place outside of an Election Window and after the commencement date of a new Term, outgoing Stewards from the previous Term shall stay in their positions as working group Stewards until immediately prior to 9am UTC the day following the end of the election, which, for the avoidance of doubt, is 120 hours after voting in those elections commenced.3.In the event that an election takes place outside of an Election Window and after the commencement date of a new Term, newly elected Stewards will assume the responsibilities of stewardship within working groups at 9am UTC the day following the end of the election, as defined in rule 7.2 above, for the remainder of that Term.8.Core Team Stewards1.For the First Term, commencing January 1 2022 at 9am UTC, each working group will include two Stewards who are core team members of True Names Limited (Singapore) (‘TNL’), as selected by TNL and not subject to the Steward nomination and election process outlined in rules 5 and 6 above.2.For the Second Term, commencing July 1 2022 at 9am UTC, each working group will include one Steward who is a core team member of TNL, as selected by TNL and not subject to the Steward nomination and election process outlined in rules 5 and 6 above.3.For the First Term of the following year, commencing January 1 2023, and for all Terms thereafter, all Stewards must be elected and appointed in accordance with the rules set out in rules 5 and 6 above.9.Removal and Replacement of Stewards1.Stewards may be removed at any time by:1.a Social Proposal passed by the DAO; or2.a simple indicative majority vote among the Stewards of a given working group, with the outcome of the vote communicated in the relevant working group category of the ENS governance forum.2.Stewards may step down from their position at any time by communicating their intention to step down in the ENS governance forum.3.In the event that a Steward is removed, steps down, or is unable to continue as a Steward, for whatever reason, prior to the end of a Term, any vacant positions will be filled for the remainder of a Term by the next highest ranked Nominee(s) in a given working group from the most recent working group vote in the most recent election for Stewards.4.In the event that a Steward steps down or is removed prior to the end of a Term and is a member of the core team of TNL in accordance with rule 8.1 or 8.2 above, the vacant position(s) will be filled by a core team member or team members of TNL, as selected by TNL.5.Any Steward selected by TNL in accordance with rule 8.1 or 8.2 above, can be removed by TNL at any time prior to the end of a Term, for any reason, and replaced by another core team member for the remainder of that Term.10.Compensation for Stewards1.Elected Stewards are eligible to receive fair compensation for their work as a Steward.2.All requests for Steward compensation must be detailed in a Collective Proposal for working group funds submitted to the DAO in accordance with rule 4.6.3.Stewards may not receive compensation for their role as a Steward outside of that compensation expressly provided for in a Collective Proposal submitted to the DAO in accordance with rule 10.2.4.Stewards selected by TNL are not eligible to receive compensation from the DAO or working groups for their work as a Steward.11.Amendments1.These rules may be amended at any time by passing a Social Proposal.Next StepsThis proposal will be open for voting on Snapshot for five days. This vote will be a single choice vote. You may vote 'for' or 'against' the proposal, or choose to abstain from the vote.By voting 'for' this proposal, you are voting in favor of creating four foundational working groups and establishing rules related to the creation, management, and dissolution of working groups within the ENS DAO, as provided in this proposal.Given the time of year, Steward nominations and elections for the First Term of 2022 will be delayed until the beginning of 2022.The Nomination Window for the First Term of 2022 will be open between 9am UTC on January 5, 2022 and 9am UTC on January 8, 2022. Any individual is eligible to nominate themselves to be a Steward of a working group or working groups during this Nomination Window. All Eligible Persons who satisfy the requirements set out in rule 5.4 and 5.5 will be included on the ballot for the First Term elections. More details about the nomination process will be available in the call for nominations released prior to the Nomination Window opening.The Election Window for the First Term of 2022 will be open for 120 hours, commencing at 9am UTC on January 10 2022. Following the election, in accordance with rule 7.3, newly elected Stewards will assume the responsibilities of stewardship within working groups at 9am UTC on January 16, 2022, for the remainder of the First Term.To stay up to date on developments regarding working groups, please follow the DAO-Bulletin channel in the ENS Discord Server and follow @ens_dao on Twitter.Previous[EP0.3] [Social] Amend airdrop proposal to include accidentally returned fundsNextTerm 1Last modified 6mo agoCopy linkEdit on GitHubOn this pageAbstractMotivationSpecificationNext Steps "
71,mains v governance governance proposals term 1 ep13 protocol guild pilot,"mains v governance governance proposals term 1 ep13 protocol guild pilot.   [EP1.9] [Executable] Fund the Protocol Guild pilot with 200,000 $ENS - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1[EP1.1] [Executable] Set the temporary premium start price to $100,000[EP1.2.1] [Social] Removal of Brantly Millegan as Director of the ENS Foundation[EP1.2.2] [Social] Election of a new Director of The ENS Foundation[EP1.3.1] [Executable] Q1 & Q2 2022 Meta-Governance WG Budget[EP1.3.2] [Executable] Q1 & Q2 2022 ENS Ecosystem WG Budget[EP1.3.3] [Executable] Q1 & Q2 2022 Community WG Budget[EP1.3.4] [Executable] Q1 & Q2 2022 Public Goods WG Budget[EP1.4] [Executable] Reimburse True Names for expenses and tax obligations incurred for the DAO[EP1.5][Executable] Change to Exponential Premium Price Oracle[EP1.6] [Executable] A DAO-Governed Identity Server[EP1.7] [Executable] End the $ENS and EP2 airdrops[EP1.8] [Social] Working Group Rules[EP1.9] [Executable] Fund the Protocol Guild pilot with 200,000 $ENSTerm 2Term 3Powered By GitBook[EP1.9] [Executable] Fund the Protocol Guild pilot with 200,000 $ENSThis is a proposal for the ENS DAO to support the Protocol Guild Pilot, a vested split contract which directs funding to 110 Ethereum core protocol contributors over one year.StatusExecutedDiscussion Thread​Discuss​Votes​Snapshot - passed Onchain - passedAuthors​Trent Van Epps (PG Member), Tim Beiko (PG Member)Note: This was previously numbered EP13.AbstractWe propose that 200k ENS (~3.7% of the unclaimed airdrop) be allocated in recognition of past and ongoing work of these core contributors.ENS is one of the most successful projects built on Ethereum, and yet core protocol contributors do not benefit in any way from the success of projects being built on Ethereum. The Protocol Guild provides a vehicle for the ENS community to distribute governance tokens to those individuals who build and maintain the foundational infrastructure that ENS relies on.ENS sponsorship of the Guild allows members to engage with ENS in a way that is values- and incentive-aligned. Simultaneously, it will allow them to continue the important work of scaling our shared infrastructure and making it as resilient as possible for the applications on top of it.SpecificationUseful links​Protocol Guild Docs​​1 Year Vesting Contract​​Split Contract​​Initial Announcement - Dec 2021​​List of Members​​Protocol Guild twitter​Context1.As a credibly neutral, maximally uncapturable infrastructure with no block reward, the Ethereum base protocol doesn’t offer the same token incentives to contributors as applications or L2s can. However, the protocol still needs to attract and retain talent to continue to evolve. As the broader ecosystem continues to grow, competition for talented individuals will only increase. This isn’t to fault individuals for rationally weighting financial incentives, or protocols for leveraging the power of tokens - this is just the reality of the current context. We also acknowledge that financial motivations aren’t the only or best motivator for people, it’s just one tool in our toolset that is currently underleveraged.2.Existing public goods funding solutions tend to be either too narrow or broad in scope, fail to exclusively target core protocol contributors, or depend on an intermediating institution, which often leads to organizations, and not individuals, being recipients of funds.3.The Protocol benefits from contributor continuity. Transferring institutional knowledge between cohorts is more likely to happen successfully the more overlap there is.Here’s a longer exploration of the project rationale.If we believe what we are building is important, then we should structure the incentives to attract more smart people to work on it. After all, “Ethereum is an unprecedented arena for playing cooperative games”; we should try to manifest the novel possibilities made possible by this arena. (Griffith, 2019)What is the Protocol Guild?The Protocol Guild aims to address the challenges mentioned above with a simple tool: a weighted split contract that includes vesting. Members will solicit sponsorships in the form of tokens from applications & protocols that build on Ethereum, which gives core contributors exposure to success at the application layer:current contributors are rewarded for past work through time-based weightingcurrent contributors contribute for longer periods, resulting in less contributor churnnew contributors are incentivized to join core protocol work, protocol evolution and maintenance is more robustTo date, the membership includes over 110 Ethereum protocol contributors, including researchers, client maintainers, upgrade coordinators, and more, all self-curated (member list here). This is a broad-based ecosystem effort: members come from 22 different teams and 9 organizations. Only 30% of members are directly employed by the EF. The membership is continuously curated through quarterly updates to the split contract - we expect the membership to grow to 150 over the course of the Pilot.The Guild contracts will act as an autonomous value routing mechanism, operated independently from any existing institution, purpose-built for incentivizing long-term core protocol work. At no point does PG take custody of funds on behalf of members, it is all handled trustlessly. The diagram below and the docs have more information.|602x3872022 PilotSince starting the project in Nov 2021, we’ve built norms around member onboarding , refined the splitting and vesting mechanisms, and created extensive documentation on how PG operates.At this point, we’re ready to test the mechanism’s efficacy with a 1 year / $10-20mm Pilot. We want to make sure the mechanism operates smoothly before graduating to a full-scale fundraising round for longer vesting periods. The funds for the Pilot would be vested directly to Guild members over one year: see the Pilot vesting contract here.ProposalWe are proposing that 200k ENS (~3.7% of the unclaimed airdrop) be sent to the Pilot vesting contract deployed at 0xF29…f1a9 in recognition of the past and ongoing work of these core contributors.The tokens would not be liquidated, but would vest for one year to each beneficiary listed on the underlying split. Each recipient would be making an independent decision about how to use their tokens once vested.The USD value of the 200k ENS is $2.49mm as of the time of this post on May 25 2022. This is roughly in line with what we have already proposed to similarly prominent Ethereum-based protocols. Lido’s 2mm LDO contribution was worth $2.6mm; the active Uniswap proposal requesting 500k UNI would be worth $2.75mm.There are a few reasons why supporting the Protocol Guild benefits the ENS community:ENS’s long-term success is tightly coupled with the continued evolution and maintenance of the Ethereum protocol. These are projects that often have multi-year timelines. Contributing to the Pilot meaningfully increases the incentive to contribute to the core protocol, including:​The Merge: moving from PoW to PoS, increasing security and sustainabilityEVM improvements: new functionality for developers like EOF​​Statelessness: sustainable management for state growthSupporting L2 scaling: EIP-4844, EIP-4488​​Proposer Builder Separation: reducing centralizing incentives for consensus participantsContinuous client maintenance: improving sync, exploring new database types, researching modular clientsCoordinating network upgrades: making sure the community helps to shape and is aware of network upgradesHaving exposure to ENS allows protocol contributors to engage more with ENS governance. Members will be encouraged (but not obligated) to delegate them within the ENS governance framework.ENS should be among the protocols maximally aligned with the Public Goods of the largest ecosystem it operates in. Pilot participation maintains and expands the ENS community’s existing reputation for funding Public Goods.Diverse funding sources from the community further decentralizes protocol governance and prevents influence from pooling with any single entity.We hope that a successful Pilot will pave the way for future funding collaborations between the ENS community and the Protocol Guild as we scale up the project after the Pilot. To that end, we think it’s important to demonstrate impact: learn more about how we intend to evaluate Pilot outcomes here. We have also adopted an active stance of continuous adjustments to improve PG while we operate the Pilot: improving documentation, resources for members, better transparency, etc.TransactionsAddressValueFunctionArgumentValuetoken.ensdao.eth0transferrecipienttheprotocolguild.ethamount200000000000000000000000​​​​Previous[EP1.8] [Social] Working Group RulesNextTerm 2Last modified 6mo agoCopy linkEdit on GitHubOn this pageAbstractSpecificationUseful linksContextWhat is the Protocol Guild?2022 PilotProposalTransactions "
72,mains dapp developer guide ens l2 offchain,"mains dapp developer guide ens l2 offchain.   ENS Layer2 and offchain data support - ENS Documentation    ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookENS Layer2 and offchain data supportSummaryWith the proliferation of layer 2 solutions for Ethereum that are starting to reach maturity, it's important that ENS is able to provide resolution services across the entire ecosystem, as well as making it possible for ENS users to take advantage of the efficiencies made possible by Layer 2 solutions. Subsequent to a post by Vitalik that suggested a possible means for this, the ENS team and the wider ENS and L2 community have been working on a general-purpose ""Layer 2 bridge"" that makes cross-platform interoperability possible for both ENS and other applications that need to be able to retrieve data from a variety of offchain sources (any data that resides outside of Ethereum Mainnet also known as layer 1/L1. This includes both propriety database and layer 2/L2 solutions such as Optimism, Arbitrum, Starkware, ZKSync, and so on) in a trustless fashion and came up with standards.​EIP-3668: CCIP Read: Secure offchain data retrieval​​EIP-5559: Cross Chain Write Deferral Protocol​​ENSIP 10: Wildcard Resolution​EIP 3668 (Final) allows for offchain (including Layer 2/L2) lookups of data in a way that is transparent to clients and provides contract authors to implement whatever validation is necessary; in many cases, this can be provided without any additional trust assumptions over and above those required if data is stored onchain.EIP 5559 (Draft) provides a mechanism in which smart contracts can request various tasks to be resolved by an external handler. This provides a mechanism in which protocols can reduce the gas fees associated with storing data on mainnet by deferring the handling of it to another system/network. These external handlers act as an extension to the core L1 contract.ENSIP 10 (Draft) is a general way to resolve wildcard (eg: *.foo.eth) on L1. Issuing subdomains and moving the resolution of the parent name offchain allows dapps to create subdomains offchain yet make it accessible through L1.Steps required for Dapps and wallets to support offchain data lookup.If your dapps or wallets use one of those libraries, the EIP 3668 and ENSIP 10 support will be built in, so simply update the library when ready. EIP 5559 is still in its early stage of draft and the content will be evolving​ethersjs​ethers.js 5.6.2 supports both EIP3668 and ENSIP 10.No code change is required as long as your app is interacting with ENS through etherjs ENS methods.To try out these features, offchainexample.eth points to so-called ""offchain resolver"" that fetches data from JSON configuration file hosted on google app engine. It will reply data to any record for offchainexample.eth and its subdomain record such as 2.offchainexample.eth. The example resolver is not using L2 data but the same mechanism works when the L2 resolver becomes ready.const { ethers } = require(""ethers"");const url = `https://mainnet.infura.io/v3/${process.env.API_KEY}`;const provider = new ethers.providers.JsonRpcProvider(url);​async function main() { let resolver = await provider.getResolver(""1.offchainexample.eth""); let address = await provider.resolveName(""1.offchainexample.eth""); let email = await resolver.getText(""email""); console.log({ resolver: resolver.address, address, email });}main();The expected output is as follows.$node index.js{ resolver: '0xC1735677a60884ABbCF72295E88d47764BeDa282', address: '0x41563129cDbbD0c5D3e1c86cf9563926b243834d', email: '[email protected]'}Please refer to offchain resolver client example code for more detail.Other supported libraries.​web3.py (Python)​web3j (Java)If you use other libraries or custom integration, please raise the GitHub issue to the project repo or at ENS project management repo if the equivalent repo does not exist so that ENS team can keep track of the progress.Wallets integrated​Alpha Wallet​​Argent​​Coinbase Wallet​​Trust Wallet​​Umbra Wallet​Steps required for Dapps and wallets to issue subdomains offchainIf you wish to issue subdomains using offchain data storage, please follow offchain resolver as a reference point. The example uses a flat file as a data source but can easily be replaced with database calls.The following projects have integrated with the Offchain resolver for issuing their subdomains​cb.id by Coinbase​​optinames = The code is closed sourced but you can read the verified contract code​Offchain resolver provides an easy way to store data offchain but please be aware of some trade off. Users have to trust that gateway server returns the correct data. Some offchain resolver returns attestation by signing the signature. To do so, the owner of the parent domain that issue subdomains have to host the gateway on their own and have to have a private key to sign. If the gateway server is compromised, there is a risk that the subdomain address are redirected to the malicious addresses.To minimise the trust to the gateway, we are currently working on L2 resolversL2 ResolverIn a L2 rollup system, contract state hashes are stored on-chain, along with the transaction calls and arguments logged as calldata. a rollup has a mechanism to verify the state of their chain on L1, either instantly or optimistically.ENS integration utilizes this mechanism in the gateway. The gateway retrieves the data from L2 along side with the proof (often via eth_getProof) and returns back to the caller. The caller passes the data to L1 resolver contract to verify its state and data(more detail). As long as L1 contract can verify the state and storage of the L2 data, users no longer need to trust the gateway itself. If a gateway service is compromised, the worst can happen is that the gateway stops responding data ( when that happens, the owner of the resolver can simply startup new gateway and update the L1 contract to return the new gateway address). The parent owner does not even have to host the gateway services by themselves but can use third party gateway services.To assess whether a L2 rollup system can integrate with ENS, please see the following steps.1.Does your chain use same address format as the ones used in Ethereum? = Some ZKRollup chains use different address format. If that's the case, you need to add your wallet address format into ENS multicoin type. Please refer to Starknet support PR as a reference.2.Does RPC of the chain return eth_getProof ? If not, it requies a way to retrieve a storage proof to verify on Ethereum L13.Does the rollup contract have a function to return information of the latest L2 block committed to Ethereum L1? For Optimistic Rollup, it needs both the committed and finalised (after challenge period) block information. The blockhash is required to call eth_getProof equivalent function on L24.Is there a way to verify on L1 contract that the state root returned from L2 is valid?5.Is there a way to verify that the storageProof is included in the state root? For Optimistic rollups, we can use Lib_SecureMerkleTrie library developed by the optimism team. If the chain doesn't support Patricia Merkle Trie, it needs own libraryFor more details, please refer to the prototype implementations of Optimism and Arbitrum. Starknet currently has a community proposal to add a support.FAQIs the change backwards compatible?Yes. The existing names on L1 will continue working without clients nor applications supporting these standards. Only names that are outside of L1 will not be resolved.Will L2/offchain data be supported by GraphQL?Once each L2 is officially supported, we will need to spin up a subgraph for each L2 bridge, and we will use schema stitching to make using them transparent to callers.For names that are not hosted on a supported L2, we won't be able to fetch data that are normally only available on the subgraphHow do you support other EVM compatible chains?Non-L2 chains lack ways to verify data on L1 in the trustless manner. The alternative is for chain bridge operators to act as a trusted third-party and hosts the offchain gateway, or individual dapps hosts own gateway and sign each data with the private key of the ENS name.Can I issue a new tld unique to an offchain environment?No. Please read ""Why ENS Doesn't Create More TLDs: Responsible Citizenship in the Global Namespace"" for more detail. Alternatively we suggest that you import DNS names as ENS like cb.id, and argent.xyzCan I set a primary name to names on offchain?Yes, you can. However, reverse registrar (it is a hidden top-level domain starting with .addr.reverse) currently resides on L1; hence you have to pay gas on L1. We may consider moving the reverse registrar to L2 in future.Can I register .eth name on offchain?Only when we migrate .eth name to a specific L2 as one of the last steps of our migration after finding out which L2 supports ENS integration the best.How do I handle contract addresses?Unlike EOA (Externally Owned Account), contract based accounts such as multisig may only be accessible in certain chains. ENSIP-11 allows a single name to hold different addresses across multiple EVM compatible chains and recommendation is to store contract addresses to EVM chain specific address record field.Can I use libraries from other name services that support .eth?@unstoppabledomains/resolution removed ENS support as of December 2021. Other services tend not to support all ENS TLDs especially DNS based TLDs (.com, .net, etc) so we advise not to rely on these libraries resolving ENS names.​Our chain is not Rollup, but we have a ways to verify our state in Ethereum L1. Can we still integrate?It would be possible If there is a lightclient that can verify the chain's state and data on Ethereum L1. References and previous discussions​MVP of ENS on L2 with Optimism: Demo Video + How to Try It Yourself​​A general-purpose bridge for Ethereum Layer 2s​​A general-purpose L2-friendly ENS standard​​Video: ENS Workshop on 18th Oct 2021​​Video: ENS Workshop on 6th April 2021​​Video: ENS on Layer 2 meeting #2 on 28th Oct 2020​​Video: ENS on Layer 2 meeting on 13th Oct 2020​​Video: ENS workshop on 29th Sep 2020​Dapp Developer Guide - PreviousENS as NFTNext - Dapp Developer GuideENS Data guideLast modified 1mo agoCopy linkEdit on GitHubOn this pageSummarySteps required for Dapps and wallets to support offchain data lookup.ethersjsOther supported libraries.Wallets integratedSteps required for Dapps and wallets to issue subdomains offchainL2 ResolverFAQIs the change backwards compatible?Will L2/offchain data be supported by GraphQL?How do you support other EVM compatible chains?Can I issue a new tld unique to an offchain environment?Can I set a primary name to names on offchain?Can I register .eth name on offchain?How do I handle contract addresses?Can I use libraries from other name services that support .eth?Our chain is not Rollup, but we have a ways to verify our state in Ethereum L1. Can we still integrate?References and previous discussions "
73,mains deploying ens on a private chain,"mains deploying ens on a private chain.   Deploying ENS on a Private Chain - ENS Documentation    ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookDeploying ENS on a Private ChainIf you’d like to deploy ENS on your own network, or deploy your own copy of ENS on a public network, this guide shows you how. If you want to use an existing ENS deployment, see Resolving Names, Managing Names, and Registering & Renewing Names instead.On this page we will use Javascript, Web3, and Hardhat with npm for simplicity. You will find a complete migration file example at the bottom of this page.Please be aware that existing frameworks such as waffle and embark have support for local ENS deployment as well.Importing contractsThe essential smart contracts are published as npm modules. You can install them in your npm project with npm install @ensdomains/ens-contracts. Now, you can require them in a migration script as follows (see the Truffle Documentation on working with contract artifacts and npm for details)import { ENS, ENSRegistry, PublicResolver} from '@ensdomains/ens-contracts'Including them within your smart contract is as followsimport '@ensdomains/ens-contracts/contracts/registry/ENS.sol'ENS contains only an interface while ENSRegistry includes the actual implementation.Deploy the RegistryThe registry is ENS’s central component and stores, among other things, who owns which domain. This is the example using ethers and hardhat.const ENSRegistry = await ethers.getContractFactory(""ENSRegistry"")await ENSRegistry.deploy()Once deployed, you will have a fresh ENS registry, whose root node is owned by the account that submitted the transaction. This account has total control over the ENS registry - it can create and replace any node in the entire tree.From here, it's possible to create and manage names by directly interacting with the registry, as described in Managing Names. However, you will probably want to deploy a resolver, and you may want to deploy a registrar so other users can register names.Deploy a ResolverRecords in the registry can point to resolver contracts which store additional domain information. The most common use-case is to store an address for a domain, but storing a contract ABI or text is also possible. For most purposes on private networks it's convenient to have an unrestricted general-purpose resolver available. Deploying one is straightforward:const ZERO_ADDRESS = ""0x0000000000000000000000000000000000000000"";const ENSRegistry = await ethers.getContractFactory(""ENSRegistry"")const registry = await ENSRegistry.deploy()await registry.deployed()const PublicResolver = await ethers.getContractFactory(""PublicResolver"")const resolver = await PublicResolver.deploy(registry.address, ZERO_ADDRESS);await resolver.deployed()The PublicResolver looks up ownership in the registry, which is why the registry's address is required at deployment.For ease of use, we can give this resolver a name:const ethers = require('ethers');const utils = ethers.utils;const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label))const namehash = require('eth-ens-namehash');​async function setupResolver(ens, resolver, accounts) { const resolverNode = namehash.hash(""resolver""); const resolverLabel = labelhash(""resolver"");​ await ens.setSubnodeOwner(""0x0000000000000000000000000000000000000000"", resolverLabel, accounts[0]); await ens.setResolver(resolverNode, resolver.address); await resolver.setAddr(resolverNode, resolver.address);}Above, we first create a new top-level domain, ""resolver"", then set its resolver address to our newly deployed public resolver. Finally, we set up an address record for ""resolver"", pointing back to the resolver address. In effect, the resolver is answering queries about its own address. After this, anyone can find the public resolver at the special ENS name ""resolver"". We call this function after deploying the public resolver in a .then() block as we did with the resolver.Deploy a RegistrarSo far, domains can only be registered manually by the owner of the registry's root node. Fortunately, contracts can also own nodes. This means we can set up a registrar contract as the owner of a node, e.g. ""test"", in the registry which enables it to distribute subdomains such as ""mycontract.test"". It allows us to have custom, on-chain logic which governs domain allocation. Once we own a (sub-)node we are free to repeat this process and set up another registrar. If you are part of the ""myorg"" organisation you could register ""myorg.test"" and let it point to your custom registrar which only allows certified members of your organisation to claim subdomains such as ""bob.myorg.test"". For our private network, we'll use the simple 'first come, first served' FIFSRegistrar, and set it as the owner of the top-level domain ""test"" in our migration script:... const registrar = await FIFSRegistrar.deploy(ens.address, namehash.hash(""test"")); await registrar.deployed(); await ens.setSubnodeOwner(""0x0000000000000000000000000000000000000000"", sha3(""test""), registrar.address);})...Deploy the Reverse RegistrarSimilarly, if you wish to enable reverse resolution on your deployment, you will need to deploy the reverse registrar:...const reverseRegistrar = await ReverseRegistrar.deploy(ens.address, resolver.address);await reverseRegistrar.deployed();setupReverseRegistrar(ens, resolver, reverseRegistrar, accounts);...​async function setupReverseRegistrar(ens, resolver, reverseRegistrar, accounts) { await ens.setSubnodeOwner(""0x0000000000000000000000000000000000000000"", utils.sha3(""reverse""), accounts[0]); await ens.setSubnodeOwner(namehash.hash(""reverse""), utils.sha3(""addr""), reverseRegistrar.address);}Migration File ExampleWe can combine the steps above in a single hardhat migration file. This allows us to deploy ENS in one go:contracts/deps.sol//SPDX-License-Identifier: MIT// These imports are here to force Hardhat to compile contracts we depend on in our tests but don't need anywhere else.import ""@ensdomains/ens-contracts/contracts/registry/ENSRegistry.sol"";import ""@ensdomains/ens-contracts/contracts/registry/FIFSRegistrar.sol"";import ""@ensdomains/ens-contracts/contracts/resolvers/PublicResolver.sol"";script/deploy.jsconst hre = require(""hardhat"");const namehash = require('eth-ens-namehash');const tld = ""test"";const ethers = hre.ethers;const utils = ethers.utils;const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label))const ZERO_ADDRESS = ""0x0000000000000000000000000000000000000000"";const ZERO_HASH = ""0x0000000000000000000000000000000000000000000000000000000000000000"";async function main() { const ENSRegistry = await ethers.getContractFactory(""ENSRegistry"") const FIFSRegistrar = await ethers.getContractFactory(""FIFSRegistrar"") const ReverseRegistrar = await ethers.getContractFactory(""ReverseRegistrar"") const PublicResolver = await ethers.getContractFactory(""PublicResolver"") const signers = await ethers.getSigners(); const accounts = signers.map(s => s.address)​ const ens = await ENSRegistry.deploy() await ens.deployed() const resolver = await PublicResolver.deploy(ens.address, ZERO_ADDRESS); await resolver.deployed() await setupResolver(ens, resolver, accounts) const registrar = await FIFSRegistrar.deploy(ens.address, namehash.hash(tld)); await registrar.deployed() await setupRegistrar(ens, registrar); const reverseRegistrar = await ReverseRegistrar.deploy(ens.address, resolver.address); await reverseRegistrar.deployed() await setupReverseRegistrar(ens, registrar, reverseRegistrar, accounts);};​async function setupResolver(ens, resolver, accounts) { const resolverNode = namehash.hash(""resolver""); const resolverLabel = labelhash(""resolver""); await ens.setSubnodeOwner(ZERO_HASH, resolverLabel, accounts[0]); await ens.setResolver(resolverNode, resolver.address); await resolver['setAddr(bytes32,address)'](resolverNode, resolver.address);}​async function setupRegistrar(ens, registrar) { await ens.setSubnodeOwner(ZERO_HASH, labelhash(tld), registrar.address);}​async function setupReverseRegistrar(ens, registrar, reverseRegistrar, accounts) { await ens.setSubnodeOwner(ZERO_HASH, labelhash(""reverse""), accounts[0]); await ens.setSubnodeOwner(namehash.hash(""reverse""), labelhash(""addr""), reverseRegistrar.address);}​// We recommend this pattern to be able to use async/await everywhere// and properly handle errors.main() .then(() => process.exit(0)) .catch((error) => { console.error(error); process.exit(1); });To execute the migration file on hardhat, run the following command line.npx hardhat run scripts/deploy.jsDeploying ENS in a single transactionAlternately you may wish to deploy a test registrar and its dependencies with a single transaction. This is useful for example in unit tests where you wish to start from a clean slate in each test. In many cases it will also be faster than sending a series of separate transactions.This can be done by deploying a new contract that creates and sets up all the other contracts in its constructor. The below code creates all the ENS contracts and assigns the eth TLD to the FIFS Registrar so that any eth domain may be registered in the unit tests.pragma solidity >=0.8.4;import {INameWrapper, PublicResolver} from '@ensdomains/ens-contracts/contracts/resolvers/PublicResolver.sol';import '@ensdomains/ens-contracts/contracts/registry/ENSRegistry.sol';import '@ensdomains/ens-contracts/contracts/registry/FIFSRegistrar.sol';import {NameResolver, ReverseRegistrar} from '@ensdomains/ens-contracts/contracts/registry/ReverseRegistrar.sol';​// Construct a set of test ENS contracts.contract ENSDeployer { bytes32 public constant TLD_LABEL = keccak256('eth'); bytes32 public constant RESOLVER_LABEL = keccak256('resolver'); bytes32 public constant REVERSE_REGISTRAR_LABEL = keccak256('reverse'); bytes32 public constant ADDR_LABEL = keccak256('addr');​ ENSRegistry public ens; FIFSRegistrar public fifsRegistrar; ReverseRegistrar public reverseRegistrar; PublicResolver public publicResolver;​ function namehash(bytes32 node, bytes32 label) public pure returns (bytes32) { return keccak256(abi.encodePacked(node, label)); }​ constructor() public { ens = new ENSRegistry(); publicResolver = new PublicResolver(ens, INameWrapper(address(0)));​ // Set up the resolver bytes32 resolverNode = namehash(bytes32(0), RESOLVER_LABEL);​ ens.setSubnodeOwner(bytes32(0), RESOLVER_LABEL, address(this)); ens.setResolver(resolverNode, address(publicResolver)); publicResolver.setAddr(resolverNode, address(publicResolver));​ // Create a FIFS registrar for the TLD fifsRegistrar = new FIFSRegistrar(ens, namehash(bytes32(0), TLD_LABEL));​ ens.setSubnodeOwner(bytes32(0), TLD_LABEL, address(fifsRegistrar));​ // Construct a new reverse registrar and point it at the public resolver reverseRegistrar = new ReverseRegistrar(  ens,  NameResolver(address(publicResolver)) );​ // Set up the reverse registrar ens.setSubnodeOwner(bytes32(0), REVERSE_REGISTRAR_LABEL, address(this)); ens.setSubnodeOwner(  namehash(bytes32(0), REVERSE_REGISTRAR_LABEL),  ADDR_LABEL,  address(reverseRegistrar) ); }}PreviousRegistrar Frequently Asked QuestionsNextDNS Registrar guideLast modified 1yr agoCopy linkEdit on GitHubOn this pageImporting contractsDeploy the RegistryDeploy a ResolverDeploy a RegistrarDeploy the Reverse RegistrarMigration File Examplecontracts/deps.solscript/deploy.jsDeploying ENS in a single transaction "
74,mains dapp developer guide ens libraries,"mains dapp developer guide ens libraries.   ENS Libraries - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookENS LibrariesENS support is available in many popular languages. If you know of a library that is not listed here, please send us a PR.Javascript​ensjs, maintained by the ENS developers​ethereum-ens (deprecated)​react-ens-address​​ethers.js​​web3.js​​embark.io​​waffle.io​Which Javascript library should I use?If you are already using web3.js or ethers.js, and do not require functionality such as creating subdomains, transferring ownership, or updating resolvers, use built in ENS features of these libraries.If you are using React and only need to do forward and reverse resolution of ENS names with built in UI, use react-ens-address.If you want to have ENS instance deployed into your dev environment, you may want to use embark.io or waffle.io which allows you to configure/deploy ENS registry in your Ethereum test instance.Otherwise, use ensjs.Accessing smart contracts directlyAll the ENS smart contracts are published as @ensdomains/ens-contracts npm module.​This is how you include abi into your frontend code.import { ENS, PublicResolver} from '@ensdomains/ens-contracts'`This is how you import our smartcontract within Solidity.import '@ensdomains/ens-contracts/contracts/registry/ENS.sol';Java​web3j​Kotlin​KEthereum​Python​web3.py - also see web3.py ENS docs​Go​go-ens​Command-line​ethereal​Delphi​delphereum​Next StepsOnce you've chosen a library, read Working with ENS to learn how to use your chosen ENS library in your application.Dapp Developer Guide - PreviousENS Enabling your DAppNext - Dapp Developer GuideWorking with ENSLast modified 1yr agoCopy linkEdit on GitHubOn this pageJavascriptJavaKotlinPythonGoCommand-lineDelphiNext Steps "
75,mains contract api reference subgraphdata entities#registration,"mains contract api reference subgraphdata entities#registration.   Entities - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookEntitiesEntities​Domain​​DomainEvent​​Transfer​​NewOwner​​NewResolver​​NewTTL​​Account​​Registration​​RegistrationEvent​​NameRegistered​​NameRenewed​​NameTransferred​​Resolver​​ResolverEvent​​AddrChanged​​MulticoinAddrChanged​​NameChanged​​AbiChanged​​PubKeyChanged​​TextChanged​​ContentHashChanged​​InterfaceChanged​​AuthorisationChanged​DomainDescription:FieldTypeDescriptionidID!The namehash of the namenameStringThe human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)labelNameStringThe human readable label name (imported from CSV), if knownlabelhashByteskeccak256(labelName)parentDomainThe namehash (id) of the parent namesubdomains​Domain!​Can count domains from length of arraysubdomainCountInt!The number of subdomainsresolvedAddressaccountAddress logged from current resolver, if anyownerAccount!​resolverResolver​ttlBigInt​isMigratedBoolean!​createdAtBigInt!​events​DomainEvent!​​TransferDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​NewOwnerDescription:FieldTypeDescriptionidID!​parentDomainDomain!​domainDomain!​TransactionIDBytes!​ownerAccount!​NewResolverDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​resolverResolver!​NewTTLDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​transactionIDBytes!​ttlBigInt!​AccountDescription:FieldTypeDescriptionidID!​domain​Domain!​​registration​Registration!​​RegistrationDescription:FieldTypeDescriptionidID!​domainDomain​registrationDateBigInt!​expiryDateBigInt!​costBigInt!​registrantAccount!​labelNameString​events​RegistrationEven!​​RegistrationEventDescription:FieldTypeDescriptionidID!​registrationRegistrationEvent​blockNumberInt!​transactionIDBytes!​NameRegisteredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​registrantAccount!​expiryDateBigInt!​NameRenewedDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​expiryDateBigInt!​NameTransferredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​newOwnerAccount!​ResolverDescription:FieldTypeDescriptionidID!Concatenation of resolver address and namehashdomainDomain​addressBytes!Address of resolver contractaddrAccountCurrent value of addr record (per events)contenHashBytesContent hash, in binary formattexts[String!]Set of observed text record keyscointTypes[BigInt!]Set of observed SLIP-44 coin typesevents​ResolverEvent!​​ResolverEventDescription:FieldTypeDescriptionidID!Concatenation of block number and log IDresolverResolver!Used to derive relationships to ResolversblockNumberInt!​transactionIDBytes!​AddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​addrAccount!​MulticoinAddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​coinTypeBigInt!​addrBytes!​NameChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​nameString!​AbiChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​contentTypeBigInt!​PubkeyChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​xBytes!​yBytes!​TextChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​keyString!​valueString​ContenthashChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​hashBytes!​InterfaceChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​interfacedIDBytes!​implementerBytes!​AuthorisationChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​ownerBytes!​targetBytes!​isAuthorizedBoolean!​Contract API Reference - PreviousSubgraphNextQuery ExamplesLast modified 6mo agoCopy linkEdit on GitHubOn this pageEntitiesDomainTransferNewOwnerNewResolverNewTTLAccountRegistrationRegistrationEventNameRegisteredNameRenewedNameTransferredResolverResolverEventAddrChangedMulticoinAddrChangedNameChangedAbiChangedPubkeyChangedTextChangedContenthashChangedInterfaceChangedAuthorisationChanged "
76,mains contract api reference subgraphdata entities#abichanged,"mains contract api reference subgraphdata entities#abichanged.   Entities - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookEntitiesEntities​Domain​​DomainEvent​​Transfer​​NewOwner​​NewResolver​​NewTTL​​Account​​Registration​​RegistrationEvent​​NameRegistered​​NameRenewed​​NameTransferred​​Resolver​​ResolverEvent​​AddrChanged​​MulticoinAddrChanged​​NameChanged​​AbiChanged​​PubKeyChanged​​TextChanged​​ContentHashChanged​​InterfaceChanged​​AuthorisationChanged​DomainDescription:FieldTypeDescriptionidID!The namehash of the namenameStringThe human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)labelNameStringThe human readable label name (imported from CSV), if knownlabelhashByteskeccak256(labelName)parentDomainThe namehash (id) of the parent namesubdomains​Domain!​Can count domains from length of arraysubdomainCountInt!The number of subdomainsresolvedAddressaccountAddress logged from current resolver, if anyownerAccount!​resolverResolver​ttlBigInt​isMigratedBoolean!​createdAtBigInt!​events​DomainEvent!​​TransferDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​NewOwnerDescription:FieldTypeDescriptionidID!​parentDomainDomain!​domainDomain!​TransactionIDBytes!​ownerAccount!​NewResolverDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​resolverResolver!​NewTTLDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​transactionIDBytes!​ttlBigInt!​AccountDescription:FieldTypeDescriptionidID!​domain​Domain!​​registration​Registration!​​RegistrationDescription:FieldTypeDescriptionidID!​domainDomain​registrationDateBigInt!​expiryDateBigInt!​costBigInt!​registrantAccount!​labelNameString​events​RegistrationEven!​​RegistrationEventDescription:FieldTypeDescriptionidID!​registrationRegistrationEvent​blockNumberInt!​transactionIDBytes!​NameRegisteredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​registrantAccount!​expiryDateBigInt!​NameRenewedDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​expiryDateBigInt!​NameTransferredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​newOwnerAccount!​ResolverDescription:FieldTypeDescriptionidID!Concatenation of resolver address and namehashdomainDomain​addressBytes!Address of resolver contractaddrAccountCurrent value of addr record (per events)contenHashBytesContent hash, in binary formattexts[String!]Set of observed text record keyscointTypes[BigInt!]Set of observed SLIP-44 coin typesevents​ResolverEvent!​​ResolverEventDescription:FieldTypeDescriptionidID!Concatenation of block number and log IDresolverResolver!Used to derive relationships to ResolversblockNumberInt!​transactionIDBytes!​AddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​addrAccount!​MulticoinAddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​coinTypeBigInt!​addrBytes!​NameChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​nameString!​AbiChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​contentTypeBigInt!​PubkeyChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​xBytes!​yBytes!​TextChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​keyString!​valueString​ContenthashChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​hashBytes!​InterfaceChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​interfacedIDBytes!​implementerBytes!​AuthorisationChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​ownerBytes!​targetBytes!​isAuthorizedBoolean!​Contract API Reference - PreviousSubgraphNextQuery ExamplesLast modified 6mo agoCopy linkEdit on GitHubOn this pageEntitiesDomainTransferNewOwnerNewResolverNewTTLAccountRegistrationRegistrationEventNameRegisteredNameRenewedNameTransferredResolverResolverEventAddrChangedMulticoinAddrChangedNameChangedAbiChangedPubkeyChangedTextChangedContenthashChangedInterfaceChangedAuthorisationChanged "
77,mains v governance governance proposals term 3,mains v governance governance proposals term 3.   Term 3 - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1Term 2Term 3[EP3.1.1] [Social] Q1/Q2 2023 Funding Request: ENS Ecosystem Working Group[EP3.1.2] [Social] Q1/Q2 2023 Funding Request: Meta-Governance Working Group[EP3.1.3] [Social] Q1/Q2 2023 Funding Request: Public Goods Working Group[EP3.2] [Executable] Q1/Q2 2023 Working Group Funding[EP3.3] [Executable] Sell ETH to USDC[EP3.4] [Executable] Fund the Endowment (first tranche)Powered By GitBookTerm 3January 1 2023 - June 30 2023Here are the articles in this section:[EP3.1.1] [Social] Q1/Q2 2023 Funding Request: ENS Ecosystem Working Group[EP3.1.2] [Social] Q1/Q2 2023 Funding Request: Meta-Governance Working Group[EP3.1.3] [Social] Q1/Q2 2023 Funding Request: Public Goods Working Group[EP3.2] [Executable] Q1/Q2 2023 Working Group Funding[EP3.3] [Executable] Sell ETH to USDC[EP3.4] [Executable] Fund the Endowment (first tranche)Previous[EP2.2.5] [Social] Selection of an ENS endowment fund managerNext[EP3.1.1] [Social] Q1/Q2 2023 Funding Request: ENS Ecosystem Working GroupLast modified 1mo agoCopy linkEdit on GitHub 
78,mains contract api reference .eth permanent registrar registrar#reclaim ens record,"mains contract api reference .eth permanent registrar registrar#reclaim ens record.   Registrar - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarRegistrarControllerDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookRegistrar​Source​This contract implements the core functionality of the permanent registrar, with the following features:The owner of the registrar may add and remove 'controllers'.Controllers may register new domains and extend the expiry of (renew) existing domains. They can not change the ownership or reduce the expiration time of existing domains.Name owners may transfer ownership to another address.Name owners may reclaim ownership in the ENS registry if they have lost it.Owners of names in the legacy registrar may transfer them to the new registrar, during the 1 year transition period. When they do so, their deposit is returned to them in its entirety.This section documents the parts of the registrar interface relevant to implementers of tools that interact with it. Functionality exclusive to the registrar owner or to controllers is omitted for brevity.The registrar works exclusively with label hashes - the keccak256 of the first component of the label (eg, keccak256('ens') for ens.eth). For compatibility with ERC721, these are expressed as uint256 values rather than bytes32, but can be cast backwards and forwards transparently. The namehash of a name can be derived by computing keccak256(baseNode, labelHash), where basenode is the namehash of the TLD the registrar manages - eg, namehash('eth').Registrations and renewals are handled via the controller.Names and RegistrationsAll names inside ENS have an owner. The owner of a name can transfer the name to a new owner, set a resolver, and create and reassign subdomains. This functionality is all contained in the ENS registry.Allocation of names directly under .eth (eg, second-level domains ending with .eth, such as alice.eth) is governed by the .eth Permanent Registrar, described here. While buying a name from the registrar grants ownership of it in ENS, the registrar itself keeps independent track of who owns the registration. The concept of a registrant - the owner of a registration - is unique to the .eth permanent registrar.The registrant of a name can transfer the registration to another account, and they can recover ownership of the name by calling reclaim, which resets ownership of the ENS name to the registrant's account.Separating the concept of owning a name from owning a registration makes it possible to more easily build systems that make automated updates to ENS. The registrant can transfer ownership of the name to another account or to a smart contract that manages records, subdomains, etc, while still retaining the ability to recover ownership for upgrades, or in the case of a compromise.When thinking about ownership, it's important to be clear whether you're considering ownership of the name or the registration.Read OperationsGet Name Expiryfunction nameExpires(uint256 label) external view returns(uint);Returns the unix timestamp at which a registration currently expires. Names that do not exist or are not yet migrated from the legacy registrar will return 0.Check Name Availabilityfunction available(uint256 label) public view returns(bool);Returns true if a name is available for registration. Takes into account not-yet-migrated registrations from the legacy registrar. Registrar controllers may impose more restrictions on registrations than this contract (for example, a minimum name length), so this function should not be used to check if a name can be registered by a user. To check if a name can be registered by a user, check name availability via the controller.Get Transfer Period Enduint public transferPeriodEnds;transferPeriodEnds documents the unix timestamp at which it is no longer possible to migrate over registrations from the legacy registrar, and any non-migrated registrations become available for registration by anyone.Get Controller Statusmapping(address=>bool) public controllers;controllers allows callers to check if the supplied address is authorized as a registrar controller.Check Token Approvalfunction getApproved(uint256 tokenId) public view returns (address operator);Returns the address of the approved operator for this name.This function is part of ERC721.Check All Tokens Approvalfunction isApprovedForAll(address owner, address operator) public view returns (bool);Returns true if operator is authorized to transfer all tokens for owner.This function is part of ERC721.Get Name Ownerfunction ownerOf(uint256 label) external view returns(address);ownerOf returns the address that owns the registration identified by the label hash, or reverts if the registration does not exist. Registrations that have not yet been migrated from the legacy registrar are treated the same as registrations that do not exist.This function is part of ERC721.Write OperationsTransfer a Namefunction transferFrom(address from, address to, uint256 tokenId) public;function safeTransferFrom(address from, address to, uint256 tokenId) public;function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;These functions transfer the registration.They behave as specified in ERC721.Emits the following event on a successful transfer:event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);Approve Operatorfunction approve(address to, uint256 tokenId) public;function setApprovalForAll(address operator, bool _approved) public;These functions manage approvals as documented in ERC721.Reclaim ENS Recordfunction reclaim(uint256 label) external;Sets the owner record of the name in the ENS registry to match the owner of the registration in this registry. May only be called by the owner of the registration.EventsName Migratedevent NameMigrated(uint256 indexed hash, address indexed owner, uint expires);This event is emitted when a name is migrated from the legacy registrar.Name Registeredevent NameRegistered(uint256 indexed hash, address indexed owner, uint expires);This event is emitted when a controller registers a new name.Name Renewedevent NameRenewed(uint256 indexed hash, uint expires);This event is emitted when a controller renews (extends the registration of) a name.Transferevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);This event is emitted when registration is transferred to a new owner. This is distinct from the ENS Registry's Transfer event, which records transfers of ownership of the ENS record.Contract API Reference - Previous.eth Permanent RegistrarNextControllerLast modified 1yr agoCopy linkEdit on GitHubOn this pageNames and RegistrationsRead OperationsGet Name ExpiryCheck Name AvailabilityGet Transfer Period EndGet Controller StatusCheck Token ApprovalCheck All Tokens ApprovalGet Name OwnerWrite OperationsTransfer a NameApprove OperatorReclaim ENS RecordEventsName MigratedName RegisteredName RenewedTransfer "
79,mains v governance governance proposals term 2,"mains v governance governance proposals term 2.   Term 2 - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1Term 2[EP2.1] [Executable] Funding True Names Ltd[EP2.2.1] [Executable] Q3 & Q4 2022 Meta-Governance WG Budget[EP2.2.2] [Executable] Q3 & Q4 2022 Ecosystem WG Budget[EP2.2.3] [Executable] Q3 & Q4 2022 Public Goods WG Budget[EP2.2.4] [Social] ENS Endaoment RFP[EP2.2.5] [Social] Selection of an ENS endowment fund managerTerm 3Powered By GitBookTerm 2July 1 2022 - December 31 2022Here are the articles in this section:[EP2.1] [Executable] Funding True Names Ltd[EP2.2.1] [Executable] Q3 & Q4 2022 Meta-Governance WG Budget[EP2.2.2] [Executable] Q3 & Q4 2022 Ecosystem WG Budget[EP2.2.3] [Executable] Q3 & Q4 2022 Public Goods WG Budget[EP2.2.4] [Social] ENS Endaoment RFP[EP2.2.5] [Social] Selection of an ENS endowment fund managerPrevious[EP1.9] [Executable] Fund the Protocol Guild pilot with 200,000 $ENSNext[EP2.1] [Executable] Funding True Names LtdLast modified 6mo agoCopy linkEdit on GitHub "
80,mains ens improvement proposals ensip 1 ens,"mains ens improvement proposals ensip 1 ens.   ENSIP-1: ENS - ENS Documentation    ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsENSIP-1: ENSENSIP-2: Initial Hash RegistrarENSIP-3: Reverse ResolutionENSIP-4: Support for contract ABIsENSIP-5: Text RecordsENSIP-6: DNS-in-ENSENSIP-7: Contenthash fieldENSIP-8: Interface DiscoveryENSIP-9: Multichain Address ResolutionENSIP-10: Wildcard ResolutionENSIP-11: EVM compatible Chain Address ResolutionENSIP-12: Avatar Text RecordsENSIP-13: SAFE Authentication for ENSENSIP-14: On-chain Source ParameterDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookENSIP-1: ENSDocumentation of the basic ENS protocol (formerly EIP-137).AuthorNick Johnson <[email protected]>StatusFinalCreated2016-04-04AbstractThis ENSIP describes the details of the Ethereum Name Service, a proposed protocol and ABI definition that provides flexible resolution of short, human-readable names to service and resource identifiers. This permits users and developers to refer to human-readable and easy to remember names, and permits those names to be updated as necessary when the underlying resource (contract, content-addressed data, etc) changes.The goal of domain names is to provide stable, human-readable identifiers that can be used to specify network resources. In this way, users can enter a memorable string, such as 'vitalik.wallet' or 'www.mysite.swarm', and be directed to the appropriate resource. The mapping between names and resources may change over time, so a user may change wallets, a website may change hosts, or a swarm document may be updated to a new version, without the domain name changing. Further, a domain need not specify a single resource; different record types allow the same domain to reference different resources. For instance, a browser may resolve 'mysite.swarm' to the IP address of its server by fetching its A (address) record, while a mail client may resolve the same address to a mail server by fetching its MX (mail exchanger) record.MotivationExisting specifications and implementations for name resolution in Ethereum provide basic functionality, but suffer several shortcomings that will significantly limit their long-term usefulness:A single global namespace for all names with a single 'centralised' resolver.Limited or no support for delegation and sub-names/sub-domains.Only one record type, and no support for associating multiple copies of a record with a domain.Due to a single global implementation, no support for multiple different name allocation systems.Conflation of responsibilities: Name resolution, registration, and whois information.Use-cases that these features would permit include:Support for subnames/sub-domains - eg, live.mysite.tld and forum.mysite.tld.Multiple services under a single name, such as a DApp hosted in Swarm, a Whisper address, and a mail server.Support for DNS record types, allowing blockchain hosting of 'legacy' names. This would permit an Ethereum client such as Mist to resolve the address of a traditional website, or the mail server for an email address, from a blockchain name.DNS gateways, exposing ENS domains via the Domain Name Service, providing easier means for legacy clients to resolve and connect to blockchain services.The first two use-cases, in particular, can be observed everywhere on the present-day internet under DNS, and we believe them to be fundamental features of a name service that will continue to be useful as the Ethereum platform develops and matures.The normative parts of this document does not specify an implementation of the proposed system; its purpose is to document a protocol that different resolver implementations can adhere to in order to facilitate consistent name resolution. An appendix provides sample implementations of resolver contracts and libraries, which should be treated as illustrative examples only.Likewise, this document does not attempt to specify how domains should be registered or updated, or how systems can find the owner responsible for a given domain. Registration is the responsibility of registrars, and is a governance matter that will necessarily vary between top-level domains.Updating of domain records can also be handled separately from resolution. Some systems, such as swarm, may require a well defined interface for updating domains, in which event we anticipate the development of a standard for this.SpecificationOverviewThe ENS system comprises three main parts:The ENS registryResolversRegistrarsThe registry is a single contract that provides a mapping from any registered name to the resolver responsible for it, and permits the owner of a name to set the resolver address, and to create subdomains, potentially with different owners to the parent domain.Resolvers are responsible for performing resource lookups for a name - for instance, returning a contract address, a content hash, or IP address(es) as appropriate. The resolver specification, defined here and extended in other ENSIPs, defines what methods a resolver may implement to support resolving different types of records.Registrars are responsible for allocating domain names to users of the system, and are the only entities capable of updating the ENS; the owner of a node in the ENS registry is its registrar. Registrars may be contracts or externally owned accounts, though it is expected that the root and top-level registrars, at a minimum, will be implemented as contracts.Resolving a name in ENS is a two-step process. First, the ENS registry is called with the name to resolve, after hashing it using the procedure described below. If the record exists, the registry returns the address of its resolver. Then, the resolver is called, using the method appropriate to the resource being requested. The resolver then returns the desired result.For example, suppose you wish to find the address of the token contract associated with 'beercoin.eth'. First, get the resolver:var node = namehash(""beercoin.eth"");var resolver = ens.resolver(node);Then, ask the resolver for the address for the contract:var address = resolver.addr(node);Because the namehash procedure depends only on the name itself, this can be precomputed and inserted into a contract, removing the need for string manipulation, and permitting O(1) lookup of ENS records regardless of the number of components in the raw name.Name SyntaxENS names must conform to the following syntax:<domain> ::= <label> | <domain> ""."" <label><label> ::= any valid string label per [UTS46](https://unicode.org/reports/tr46/)In short, names consist of a series of dot-separated labels. Each label must be a valid normalised label as described in UTS46 with the options transitional=false and useSTD3AsciiRules=true. For Javascript implementations, a library is available that normalises and checks names.Note that while upper and lower case letters are allowed in names, the UTS46 normalisation process case-folds labels before hashing them, so two names with different case but identical spelling will produce the same namehash.Labels and domains may be of any length, but for compatibility with legacy DNS, it is recommended that labels be restricted to no more than 64 characters each, and complete ENS names to no more than 255 characters. For the same reason, it is recommended that labels do not start or end with hyphens, or start with digits.namehash algorithmBefore being used in ENS, names are hashed using the 'namehash' algorithm. This algorithm recursively hashes components of the name, producing a unique, fixed-length string for any valid input domain. The output of namehash is referred to as a 'node'.Pseudocode for the namehash algorithm is as follows:def namehash(name): if name == '': return '\0' * 32 else: label, _, remainder = name.partition('.') return sha3(namehash(remainder) + sha3(label))Informally, the name is split into labels, each label is hashed. Then, starting with the last component, the previous output is concatenated with the label hash and hashed again. The first component is concatenated with 32 '0' bytes. Thus, 'mysite.swarm' is processed as follows:node = '\0' * 32node = sha3(node + sha3('swarm'))node = sha3(node + sha3('mysite'))Implementations should conform to the following test vectors for namehash:namehash('') = 0x0000000000000000000000000000000000000000000000000000000000000000namehash('eth') = 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4aenamehash('foo.eth') = 0xde9b09fd7c5f901e23a3f19fecc54828e9c848539801e86591bd9801b019f84fRegistry specificationThe ENS registry contract exposes the following functions:function owner(bytes32 node) constant returns (address);Returns the owner (registrar) of the specified node.function resolver(bytes32 node) constant returns (address);Returns the resolver for the specified node.function ttl(bytes32 node) constant returns (uint64);Returns the time-to-live (TTL) of the node; that is, the maximum duration for which a node's information may be cached.function setOwner(bytes32 node, address owner);Transfers ownership of a node to another registrar. This function may only be called by the current owner of node. A successful call to this function logs the event Transfer(bytes32 indexed, address).function setSubnodeOwner(bytes32 node, bytes32 label, address owner);Creates a new node, sha3(node, label) and sets its owner to owner, or updates the node with a new owner if it already exists. This function may only be called by the current owner of node. A successful call to this function logs the event NewOwner(bytes32 indexed, bytes32 indexed, address).function setResolver(bytes32 node, address resolver);Sets the resolver address for node. This function may only be called by the owner of node. A successful call to this function logs the event NewResolver(bytes32 indexed, address).function setTTL(bytes32 node, uint64 ttl);Sets the TTL for a node. A node's TTL applies to the 'owner' and 'resolver' records in the registry, as well as to any information returned by the associated resolver.Resolver specificationResolvers may implement any subset of the record types specified here. Where a record types specification requires a resolver to provide multiple functions, the resolver MUST implement either all or none of them. Resolvers MUST specify a fallback function that throws.Resolvers have one mandatory function:function supportsInterface(bytes4 interfaceID) constant returns (bool)The supportsInterface function is documented in ENSIP-165, and returns true if the resolver implements the interface specified by the provided 4 byte identifier. An interface identifier consists of the XOR of the function signature hashes of the functions provided by that interface; in the degenerate case of single-function interfaces, it is simply equal to the signature hash of that function. If a resolver returns true for supportsInterface(), it must implement the functions specified in that interface.supportsInterface must always return true for 0x01ffc9a7, which is the interface ID of supportsInterface itself.Currently standardised resolver interfaces are specified in the table below.The following interfaces are defined:Interface nameInterface hashSpecificationaddr0x3b3b57deContract addressname0x691f3431​ENSIP-3​ABI0x2203ab56​ENSIP-4​text0x59d1d43c​ENSIP-5​contenthash0xbc1c58d1​ENSIP-7​interfaceImplementer0xb8f2bbb4​ENSIP-8​addr(bytes32,uint256)0xf1cb7e06​ENSIP-9​ENSIPs may define new interfaces to be added to this registry.Contract Address InterfaceResolvers wishing to support contract address resources must provide the following function:function addr(bytes32 node) constant returns (address);If the resolver supports addr lookups but the requested node does not have an addr record, the resolver MUST return the zero address.Clients resolving the addr record MUST check for a zero return value, and treat this in the same manner as a name that does not have a resolver specified - that is, refuse to send funds to or interact with the address. Failure to do this can result in users accidentally sending funds to the 0 address.Changes to an address MUST trigger the following event:event AddrChanged(bytes32 indexed node, address a);Appendix A: Registry Implementationcontract ENS { struct Record { address owner; address resolver; uint64 ttl; }​ mapping(bytes32=>Record) records;​ event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner); event Transfer(bytes32 indexed node, address owner); event NewResolver(bytes32 indexed node, address resolver);​ modifier only_owner(bytes32 node) { if(records[node].owner != msg.sender) throw; _ }​ function ENS(address owner) {  records[0].owner = owner; }​ function owner(bytes32 node) constant returns (address) { return records[node].owner; }​ function resolver(bytes32 node) constant returns (address) { return records[node].resolver; }​ function ttl(bytes32 node) constant returns (uint64) { return records[node].ttl; }​ function setOwner(bytes32 node, address owner) only_owner(node) { Transfer(node, owner);  records[node].owner = owner; }​ function setSubnodeOwner(bytes32 node, bytes32 label, address owner) only_owner(node) { var subnode = sha3(node, label); NewOwner(node, label, owner);  records[subnode].owner = owner; }​ function setResolver(bytes32 node, address resolver) only_owner(node) { NewResolver(node, resolver);  records[node].resolver = resolver; }​ function setTTL(bytes32 node, uint64 ttl) only_owner(node) { NewTTL(node, ttl);  records[node].ttl = ttl; }}Appendix B: Sample Resolver ImplementationsBuilt-in resolverThe simplest possible resolver is a contract that acts as its own name resolver by implementing the contract address resource profile:contract DoSomethingUseful { // Other code​ function addr(bytes32 node) constant returns (address) { return this; }​ function supportsInterface(bytes4 interfaceID) constant returns (bool) { return interfaceID == 0x3b3b57de || interfaceID == 0x01ffc9a7; }​ function() { throw; }}Such a contract can be inserted directly into the ENS registry, eliminating the need for a separate resolver contract in simple use-cases. However, the requirement to 'throw' on unknown function calls may interfere with normal operation of some types of contract.Standalone resolverA basic resolver that implements the contract address profile, and allows only its owner to update records:contract Resolver { event AddrChanged(bytes32 indexed node, address a);​ address owner; mapping(bytes32=>address) addresses;​ modifier only_owner() { if(msg.sender != owner) throw; _ }​ function Resolver() {  owner = msg.sender; }​ function addr(bytes32 node) constant returns(address) { return addresses[node]; }​ function setAddr(bytes32 node, address addr) only_owner {  addresses[node] = addr; AddrChanged(node, addr); }​ function supportsInterface(bytes4 interfaceID) constant returns (bool) { return interfaceID == 0x3b3b57de || interfaceID == 0x01ffc9a7; }​ function() { throw; }}After deploying this contract, use it by updating the ENS registry to reference this contract for a name, then calling setAddr() with the same node to set the contract address it will resolve to.Public resolverSimilar to the resolver above, this contract only supports the contract address profile, but uses the ENS registry to determine who should be allowed to update entries:contract PublicResolver { event AddrChanged(bytes32 indexed node, address a); event ContentChanged(bytes32 indexed node, bytes32 hash);​ ENS ens; mapping(bytes32=>address) addresses;​ modifier only_owner(bytes32 node) { if(ens.owner(node) != msg.sender) throw; _ }​ function PublicResolver(address ensAddr) {  ens = ENS(ensAddr); }​ function addr(bytes32 node) constant returns (address ret) {  ret = addresses[node]; }​ function setAddr(bytes32 node, address addr) only_owner(node) {  addresses[node] = addr; AddrChanged(node, addr); }​ function supportsInterface(bytes4 interfaceID) constant returns (bool) { return interfaceID == 0x3b3b57de || interfaceID == 0x01ffc9a7; }​ function() { throw; }}Appendix C: Sample Registrar ImplementationThis registrar allows users to register names at no cost if they are the first to request them.contract FIFSRegistrar { ENS ens; bytes32 rootNode;​ function FIFSRegistrar(address ensAddr, bytes32 node) {  ens = ENS(ensAddr);  rootNode = node; }​ function register(bytes32 subnode, address owner) { var node = sha3(rootNode, subnode); var currentOwner = ens.owner(node); if(currentOwner != 0 && currentOwner != msg.sender) throw;​  ens.setSubnodeOwner(rootNode, subnode, owner); }}PreviousENS Improvement ProposalsNextENSIP-2: Initial Hash RegistrarLast modified 1yr agoCopy linkEdit on GitHubOn this pageAbstractMotivationSpecificationOverviewName Syntaxnamehash algorithmRegistry specificationResolver specificationAppendix A: Registry ImplementationAppendix B: Sample Resolver ImplementationsAppendix C: Sample Registrar Implementation "
81,mains ens migration february 2020 technical description,"mains ens migration february 2020 technical description.   Technical Description - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookTechnical DescriptionRecently, we were made aware of a vulnerability in the ENS registry contract. This vulnerability would make it possible for the owner of a domain to set a ‘back door’ such that they could transfer or sell the domain to another user, then, at a later time, claw back ownership of that domain without the new owner’s consent.The nature of this vulnerability is such that the attacker must at one point have had legitimate ownership of the domain in question, and they must set this ‘back door’ before they relinquished ownership of the name. As a result, this vulnerability cannot be exploited retrospectively.This vulnerability was reported via the Ethereum Foundation’s bug bounty process by Sam Sun. We have examined the ENS registry in detail, and are confident that nobody has previously exploited this vulnerability. As a result, ownership of all ENS names is secure.Due to this, ENS is migrating to a new deployment. This document describes the exact technical steps being taken, along with a brief description of their implications for DApp authors and users.This document is intended to provide a detailed description for anyone interested in the low-level details of the migration. Understanding this is not necessary for most users or developers; for a description of the vulnerability and its effect on users, see our medium post; for a description of the migration steps for developers see the guide for DApp developers.New ENS deploymentA new instance of most ENS contracts is being deployed. Several of these have changes, while others are being redeployed in order to reference the new registry instead of the old one.ENS RegistryA new version of the ENS registry has been deployed, and can be found at address 0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e Besides fixing the vulnerability, we have taken the opportunity to implement a couple of additional features that will improve ENS’s usability going forward:Addition of `setRecord` and `setSubnodeRecord` methods, which allow setting owner, resolver, and TTL in a single operation.Addition of an approval mechanism based on ERC721, that allows users to delegate control over their names to another address, without having to transfer their names.The new registry implementation has been audited by Sam Sun, as well as reviewed by Consensys Diligence; no issues were found by either auditor.In order to make the migration as smooth as possible, the new registry has a fallback configured; if a record is not found in its own storage, it will look it up in the previous ENS registry contract. This fallback works only for read operations; if a record exists in the old registry but not yet in the new one, users cannot call functions to modify that record on the new registry.This means that to migrate each name over from the previous registry, the name must be recreated as if from scratch - so, for example, if ‘foo.eth’ does not yet exist in the new registry, the owner of ‘eth’ must create it in the same fashion as if it were a new domain, by calling `setSubnodeOwner` (or the new `setSubnodeRecord`). Other top-level domain owners (eg, .luxe, .kred, .club and .art) will need to do this on behalf of their users, so those users can recover write access to their domains.As a result of this fallback, if a record has not been migrated to the new registry, users and processes can continue to update records in the old registry; when they do, those changes will be reflected in the new one. At the point where a record is migrated to the new registry, it ceases to reflect any changes made in the old one. This ensures that names operated by smart contracts continue to function until their owners can take manual action to migrate them over.Migration strategies for each class of name are outlined below:Top-level domains (.eth, .luxe, .kred, .club, .art, .xyz, and .reverse) were migrated over as part of the deployment process..eth second-level domains (eg, foo.eth) will be migrated over automatically for users - see the ‘migration contract’ section below for details.Subdomains managed by the Subdomain Registrar will also be migrated over automatically for users.Subdomains created by other means will need to be recreated by the owner of the parent domain calling `setSubnodeOwner` or `setSubnodeRecord`. The ENS dapp at app.ens.domains provides a one-click button to to do this for domains that are owned directly by users.Reverse records (.addr.reverse domains) will need to be recreated by repeating the ‘claim’ process in the ENS dapp UI..xyz records will need to be migrated by repeating the ‘claim’ process proving ownership of the corresponding DNS domain. This can be done via the ENS Manager UI..kred, .art, and .club domains will be migrated by the operators of those top-level domains.Name resolution will continue to work normally for names that have not yet been migrated to the new registry. Migration is only necessary in order for users to be able to change the name’s ownership, resolver, or TTL..ETH RegistrarA new instance of the .eth registrar (BaseRegistrarImplementation) has been deployed, and can be found at 0x57f1887a8BF19b14fC0dF6Fd9B2acc9Af147eA85. This registrar is largely unchanged, with only a couple of minor modifications made to support the migration.Migration ContractA new contract, designed specifically for the migration process, has been deployed and can be found at 0x6109DD117AA5486605FC85e040ab00163a75c662. This contract is configured as a controller for the new .eth registrar, and will be set as the owner of .eth on the old registry once the migration process begins. Functions on this contract permit migrating .eth second-level names (eg, foo.eth) over from the old registry and registrar to the new ones.Once activated, the ENS team will submit transactions to migrate over all presently registered .eth second-level domains to the new deployment. Registrations for all names will be automatically moved over to the new registrar, with the same expiry date as they had previously. Registry records will be automatically migrated over, unless they are controlled by a contract. Records controlled by contracts will not be automatically migrated in order to avoid breaking registrar contracts.If you own a name that is controlled by a smart contract (for example, you’re using a custom registrar to allocate subdomains), you will need to deploy a new version of that contract that references the new ENS registry, then manually migrate the name yourself, by using the ‘Set controller’ functionality in the ENS manager dapp.In addition, the ENS team is automatically migrating over records from the legacy (auction-based) registrar. Names on the legacy registrar that have not previously been migrated over will be automatically created in the new deployment, with their expiration dates set to their existing expiry of May 4, 2020, meaning users will no longer have to do this manually - though they will still have to send a transaction to recover their deposit, which they can do at any time. This permits the new ENS deployment to do away with legacy code for supporting this obsolete registrar.Public ResolverA new instance of the public resolver has been deployed, and can be found at 0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41. This instance references the new ENS registry, and has an additional ‘multicall’ feature implemented, which permits users to set multiple records in a single operation.Since the public resolver looks up names in the ENS registry to determine who is permitted to configure records for them, while names - migrated or otherwise - pointed at an old instance of the public resolver will continue to function, they will need to migrate to the new public resolver in order to make changes. The ENS dapp at app.ens.domains facilitates this process using the new multicall function, making it possible to migrate over all records for a name in two transactions: the first one copying all records from the old resolver to the new one, and the second one updating the registry to point to the new resolver contract..ETH Registrar ControllerAll registration requests for ENS .eth second-level names are processed via a ‘controller’ contract. Once the migration is complete and all names from the old registry and registrar have been re-registered on the new one, the ENS team will enable the standard registrar controller, which permits registrations via the standard two-transaction process. The controller contract has no changes from the previous deployment.Reverse RegistrarA new instance of the reverse registrar has been deployed to point to the new registry. There are no changes to this compared to the old version. Reverse resolution will continue to function as normal throughout the transition.DNSSEC RegistrarA new instance of the DNSSEC registrar has been deployed. The new instance retains all the functionality of the old one, while incorporating a few improvements that will make rolling DNSSEC support out to more top-level domains easier. Resolution of .xyz names will continue to function as normal, but any owners of these names wanting to make changes will have to repeat the ‘claim’ process to reclaim ownership of the name.Subdomain RegistrarA new instance of the subdomain registrar has been deployed. This instance is largely unchanged from the previous version, except insofar as it supports migrating from that version to the new one.ENS Migration (February 2020) - PreviousGuide for DApp DevelopersLast modified 1yr agoCopy linkEdit on GitHubOn this pageNew ENS deploymentENS Registry.ETH RegistrarMigration ContractPublic Resolver.ETH Registrar ControllerReverse RegistrarDNSSEC RegistrarSubdomain Registrar "
82,mains dapp developer guide resolving names,"mains dapp developer guide resolving names.   Resolving Names - ENS Documentation    ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookResolving NamesThe ENS namespace includes both .eth names (which are native to ENS) and DNS names imported into ENS. Because the DNS suffix namespace expands over time, a hardcoded list of name suffixes for recognizing ENS names will regularly be out of date, leading to your application not recognizing all valid ENS names. To remain future-proof, a correct integration of ENS treats any dot-separated name as a potential ENS name and will attempt a look-up.Looking up cryptocurrency addressesNames can have many types of data associated with them; the most common is cryptocurrency addresses. ENS supports storing and resolving the addresses of any arbitrary blockchain.Resolving a name to an Ethereum address using a library is simple:ensjsweb3.jsethjs-ensethers.jsgo-ensweb3.pyweb3jvar address = await ens.name('resolver.eth').getAddress();var address = ens.getAddress('alice.eth');var address = await ens.lookup('alice.eth');var address = await provider.resolveName('alice.eth');ethers.js also supports using ENS names anywhere you would use an address, meaning you often do not need to directly call resolveName. For example, to look up an account's balance, you can do:var balance = await provider.getBalance('alice.eth');Or, to instantiate a contract:const abi = [ ""function getValue() view returns (string value)"", ""function setValue(string value)""];const contract = new ethers.Contract('contract.alice.eth', abi, provider);address, err := ens.Resolve(client, ""alice.eth"")address = ns.address('alice.eth')String address = ens.resolve(""alice.eth"");web3j also supports using ENS names anywhere you would use an address, meaning you often do not need to directly interact with the EnsResolver object. For example, to instantiate a contract interface, you can do:YourSmartContract contract = YourSmartContract.load( ""contract.alice.eth"", web3j, credentials, GAS_PRICE, GAS_LIMIT);Resolution without a library is a three step process:1.Normalise and hash the name - see name processing for details.2.Call resolver() on the ENS registry, passing in the output of step 1. This returns the address of the resolver responsible for the name.3.Using the resolver interface, call addr() on the resolver address returned in step 2, passing in the hashed name calculated in step 1.Resolution support for the addresses of other blockchains is implemented with an additional overload on addr(). To resolve a non-Ethereum address, supply both the namehash and the SLIP44 chain ID of the cryptocurrency whose address you want to resolve. For example, to resolve a Bitcoin address, you would call addr(hash, 0). Note that the returned address will be in binary representation, and so will need decoding to a text-format address; for details, see EIP 2304.If you are resolving addr() records, you MUST treat a return value from the resolver of 0x00…00 as that record being unset. Failing to do so could result in users accidentally sending funds to the null address if they have configured a resolver in ENS, but not set the resolver record!Looking up other resourcesENS supports many types of resources besides Ethereum addresses, including other cryptocurrency addresses, content hashes (hashes for IPFS, Skynet, and Swarm, and Tor .onion addresses), contract interfaces (ABIs), and text-based metadata. The process for looking these up varies from library to library; for specific details see your chosen library's documentation.Resolving these content types without a library follows the same 3-step process detailed above; simply call the relevant method on the resolver in step 3 instead of addr().ensjsweb3.jsethjs-ensethers.jsgo-ensweb3.pyweb3j// Getting contenthashawait ens.name('abittooawesome.eth').getContent()// Setting contenthashawait ens.name('abittooawesome.eth').setContenthash(contentHash)​// Getting other coinsawait ens.name('brantly.eth').getAddress('BTC')// Setting other coinsawait ens.name('superawesome.eth').setAddress('ETC', '0x0000000000000000000000000000000000012345')// Getting textawait ens.name('resolver.eth').getText('url')// Setting textawait ens.name('superawesome.eth').setText('url', 'http://google.com')// Getting contenthashweb3.eth.ens.getContenthash('ethereum.eth').then(function (result) { console.log(result);});// Setting contenthashweb3.eth.ens.setContenthash('ethereum.eth', hash);Not supported. const resolver = await provider.getResolver('abittooawesome.eth'); const contentHash = await resolver.getContentHash(); const btcAddress = await resolver.getAddress(0); const dogeAddress = await resolver.getAddress(3); const email = await resolver.getText(""email"");// Encodingbin, err := ens.StringToContenthash(""/ipfs/QmayQq2DWCkY3d4x3xKh4suohuRPEXe2fBqMBam5xtDj3t"")// Setting contenthashresolver.SetContenthash(opts, data)// Getting contenthashresolver.Contenthash()// Decodingrepr, err := ens.ContenthashToString(bin)​// Getting MulticoinbtcAddress, err := resolver.MultiAddress(0)// Setting Multicoinresolver.SetMultiAddress(opts, address)​// Setting textresolver.SetText(opts, name, value)// Getting textresolver.Text(name)Not supported.Not supported.Encoding and decoding contenthashcontenthash is used to store IPFS and Swarm content hashes, which permit resolving ENS addresses to distributed content (eg, websites) hosted on these distributed networks. content-hash javascript library provides a convenient way to encode/decode these hashes. const contentHash = require('content-hash')const encoded = 'e3010170122029f2d17be6139079dc48696d1f582a8530eb9805b561eda517e22a892c7e3f1f'const content = contentHash.decode(encoded)// 'QmRAQB6YaCyidP37UdDnjFY5vQuiBrcqdyoW1CuDgwxkD4'​const onion = 'zqktlwi4fecvo6ri'contentHash.encode('onion', onion);// 'bc037a716b746c776934666563766f367269'​const encoded = 'e40101701b20d1de9994b4d039f6548d191eb26786769f580809256b4685ef316805265ea162'​const codec = contentHash.getCodec(encoded) // 'swarm-ns'codec === 'ipfs-ns' // falseNote for ipns: For security reasons, the encoding of ipns is only allowed for libp2p-key codec. Decoding with other formats will show a deprecation warning. Please read here for more detail.Coin type and encoding/decodingWhile some libraries allow you to query cryptocurrency addresses via their symbol (e.g.: BTC), others do not have the built-in support, and you have to call via each coin id (e.g.: 0 for BTC, 16 for `ETH). For Javascript/Typescript, we have @ensdomains/address-encoder library that allows you to convertimport { formatsByName, formatsByCoinType } from '@ensdomains/address-encoder';​formatsByName['BTC']// {// coinType: 0,// decoder: [Function (anonymous)],// encoder: [Function (anonymous)],// name: 'BTC'// }To save storage space as well as prevent users from setting wrong token address, the library has encoder and decoderconst data = formatsByName['BTC'].decoder('1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa');console.log(data.toString('hex')); // 76a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1888acconst addr = formatsByCoinType[0].encoder(data);console.log(addr); // 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNaListing cryptocurrency addresses and text recordsFor cryptocurrency addresses and text records, you need to know the coin type or key names to get the value. If you want to list down all the cryptocurrency addresses and text records the user has set, you have to either retrieve the information from Event or query via ENS subgraph.For example{ domains(where:{name:""vitalik.eth""}) { id name resolver{  texts  coinTypes } }}will return the following result{ ""data"": { ""domains"": [ { ""id"": ""0xee6c4522aab0003e8d14cd40a6af439055fd2577951148c14b6cea9a53475835"", ""name"": ""vitalik.eth"", ""resolver"": { ""coinTypes"": [ 60 ], ""texts"": [ ""url"" ] } } ] }}Reverse ResolutionWhile 'regular' resolution involves mapping from a name to an address, reverse resolution maps from an address back to a name. ENS supports reverse resolution to allow applications to display ENS names in place of hexadecimal addresses.Reverse resolution is accomplished via the special purpose domain addr.reverse and the resolver function name(). addr.reverse is owned by a special purpose registrar contract that allocates subdomains to the owner of the matching address - for instance, the address 0x314159265dd8dbb310642f98f50c066173c1259b may claim the name 314159265dd8dbb310642f98f50c066173c1259b.addr.reverse, and configure a resolver and records on it. The resolver in turn supports the name() function, which returns the name associated with that address.ENS does not enforce the accuracy of reverse records - for instance, anyone may claim that the name for their address is 'alice.eth'. To be certain that the claim is accurate, you must always perform a forward resolution for the returned name and check it matches the original address.Most libraries provide functionality for doing reverse resolution:ensjsweb3.jsethjs-ensethers.jsgo-ensweb3.pyweb3jconst address = '0x1234...';let ensName = null;({ name: ensName } = await ens.getName(address))// Check to be sure the reverse record is correct. skip check if the name is nullif(ensName == null || address != await ens.name(ensName).getAddress()) { ensName = null;}Not supported.var address = '0x1234...';var name = await ens.reverse(address);// Check to be sure the reverse record is correct.if(address != await ens.lookup(name)) { name = null;}var address = '0x1234...';var name = await provider.lookupAddress(address);// ethers.js automatically checks that the forward resolution matches.name, err := ens.ReverseResolve(client, common.HexToAddress(""0x1234..."")address = '0x1234...'name = ns.reverse(address)# Check to be sure the reverse record is correct.if address != ns.address(name): name = NoneString address = ""0x1234..."";String name = ens.reverseResolve(address);// Check to be sure the reverse record is correct.if(address != ens.resolve(name)) { name = null;}Reverse resolution without a library follows the same pattern as forward resolution: Get the resolver for 1234....addr.reverse(where 1234... is the address you want to reverse-resolve), and call the name() function on that resolver. Then, perform a forward resolution to verify the record is accurate.If you need to process many addresses (eg: showing reverse record of transaction histories), resolving both reverse and forward resolution for each item may not be practical. We have a seperate smart contract called ReverseRecords which allows you to lookup multiple names in one function call.const namehash = require('eth-ens-namehash');const allnames = await ReverseRecords.getNames(['0x123','0x124'])const validNames = allnames.filter((n) => namehash.normalize(n) === n )Make sure to compare that the returned names match with the normalised names to prevent from homograph attack as well as people simply using capital letters.Dapp Developer Guide - PreviousWorking with ENSNext - Dapp Developer GuideManaging NamesLast modified 6mo agoCopy linkEdit on GitHubOn this pageLooking up cryptocurrency addressesLooking up other resourcesEncoding and decoding contenthashCoin type and encoding/decodingListing cryptocurrency addresses and text recordsReverse Resolution "
83,mains v governance governance proposals term 0,mains v governance governance proposals term 0.   Term 0 - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0[EP0.1] [Social] Proposal: Transfer ENS Treasury and Contract Ownership[EP0.2] [Executable] Retrospective airdrop for accounts that owned another account’s primary ENS 1[EP0.3] [Social] Amend airdrop proposal to include accidentally returned funds[EP0.4] [Social] Proposal: Creation of Foundational Working Groups and Working Group RulesTerm 1Term 2Term 3Powered By GitBookTerm 0Term 0 covers the period of time from the DAO's formation on November 4 2022 to the first official term starting January 1 2022.Here are the articles in this section:[EP0.1] [Social] Proposal: Transfer ENS Treasury and Contract Ownership[EP0.2] [Executable] Retrospective airdrop for accounts that owned another account’s primary ENS 1[EP0.3] [Social] Amend airdrop proposal to include accidentally returned funds[EP0.4] [Social] Proposal: Creation of Foundational Working Groups and Working Group RulesPreviousGovernance ProposalsNext[EP0.1] [Social] Proposal: Transfer ENS Treasury and Contract OwnershipLast modified 6mo agoCopy linkEdit on GitHub 
84,mains dapp developer guide resolving names#reverse resolution,"mains dapp developer guide resolving names#reverse resolution.   Resolving Names - ENS Documentation    ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookResolving NamesThe ENS namespace includes both .eth names (which are native to ENS) and DNS names imported into ENS. Because the DNS suffix namespace expands over time, a hardcoded list of name suffixes for recognizing ENS names will regularly be out of date, leading to your application not recognizing all valid ENS names. To remain future-proof, a correct integration of ENS treats any dot-separated name as a potential ENS name and will attempt a look-up.Looking up cryptocurrency addressesNames can have many types of data associated with them; the most common is cryptocurrency addresses. ENS supports storing and resolving the addresses of any arbitrary blockchain.Resolving a name to an Ethereum address using a library is simple:ensjsweb3.jsethjs-ensethers.jsgo-ensweb3.pyweb3jvar address = await ens.name('resolver.eth').getAddress();var address = ens.getAddress('alice.eth');var address = await ens.lookup('alice.eth');var address = await provider.resolveName('alice.eth');ethers.js also supports using ENS names anywhere you would use an address, meaning you often do not need to directly call resolveName. For example, to look up an account's balance, you can do:var balance = await provider.getBalance('alice.eth');Or, to instantiate a contract:const abi = [ ""function getValue() view returns (string value)"", ""function setValue(string value)""];const contract = new ethers.Contract('contract.alice.eth', abi, provider);address, err := ens.Resolve(client, ""alice.eth"")address = ns.address('alice.eth')String address = ens.resolve(""alice.eth"");web3j also supports using ENS names anywhere you would use an address, meaning you often do not need to directly interact with the EnsResolver object. For example, to instantiate a contract interface, you can do:YourSmartContract contract = YourSmartContract.load( ""contract.alice.eth"", web3j, credentials, GAS_PRICE, GAS_LIMIT);Resolution without a library is a three step process:1.Normalise and hash the name - see name processing for details.2.Call resolver() on the ENS registry, passing in the output of step 1. This returns the address of the resolver responsible for the name.3.Using the resolver interface, call addr() on the resolver address returned in step 2, passing in the hashed name calculated in step 1.Resolution support for the addresses of other blockchains is implemented with an additional overload on addr(). To resolve a non-Ethereum address, supply both the namehash and the SLIP44 chain ID of the cryptocurrency whose address you want to resolve. For example, to resolve a Bitcoin address, you would call addr(hash, 0). Note that the returned address will be in binary representation, and so will need decoding to a text-format address; for details, see EIP 2304.If you are resolving addr() records, you MUST treat a return value from the resolver of 0x00…00 as that record being unset. Failing to do so could result in users accidentally sending funds to the null address if they have configured a resolver in ENS, but not set the resolver record!Looking up other resourcesENS supports many types of resources besides Ethereum addresses, including other cryptocurrency addresses, content hashes (hashes for IPFS, Skynet, and Swarm, and Tor .onion addresses), contract interfaces (ABIs), and text-based metadata. The process for looking these up varies from library to library; for specific details see your chosen library's documentation.Resolving these content types without a library follows the same 3-step process detailed above; simply call the relevant method on the resolver in step 3 instead of addr().ensjsweb3.jsethjs-ensethers.jsgo-ensweb3.pyweb3j// Getting contenthashawait ens.name('abittooawesome.eth').getContent()// Setting contenthashawait ens.name('abittooawesome.eth').setContenthash(contentHash)​// Getting other coinsawait ens.name('brantly.eth').getAddress('BTC')// Setting other coinsawait ens.name('superawesome.eth').setAddress('ETC', '0x0000000000000000000000000000000000012345')// Getting textawait ens.name('resolver.eth').getText('url')// Setting textawait ens.name('superawesome.eth').setText('url', 'http://google.com')// Getting contenthashweb3.eth.ens.getContenthash('ethereum.eth').then(function (result) { console.log(result);});// Setting contenthashweb3.eth.ens.setContenthash('ethereum.eth', hash);Not supported. const resolver = await provider.getResolver('abittooawesome.eth'); const contentHash = await resolver.getContentHash(); const btcAddress = await resolver.getAddress(0); const dogeAddress = await resolver.getAddress(3); const email = await resolver.getText(""email"");// Encodingbin, err := ens.StringToContenthash(""/ipfs/QmayQq2DWCkY3d4x3xKh4suohuRPEXe2fBqMBam5xtDj3t"")// Setting contenthashresolver.SetContenthash(opts, data)// Getting contenthashresolver.Contenthash()// Decodingrepr, err := ens.ContenthashToString(bin)​// Getting MulticoinbtcAddress, err := resolver.MultiAddress(0)// Setting Multicoinresolver.SetMultiAddress(opts, address)​// Setting textresolver.SetText(opts, name, value)// Getting textresolver.Text(name)Not supported.Not supported.Encoding and decoding contenthashcontenthash is used to store IPFS and Swarm content hashes, which permit resolving ENS addresses to distributed content (eg, websites) hosted on these distributed networks. content-hash javascript library provides a convenient way to encode/decode these hashes. const contentHash = require('content-hash')const encoded = 'e3010170122029f2d17be6139079dc48696d1f582a8530eb9805b561eda517e22a892c7e3f1f'const content = contentHash.decode(encoded)// 'QmRAQB6YaCyidP37UdDnjFY5vQuiBrcqdyoW1CuDgwxkD4'​const onion = 'zqktlwi4fecvo6ri'contentHash.encode('onion', onion);// 'bc037a716b746c776934666563766f367269'​const encoded = 'e40101701b20d1de9994b4d039f6548d191eb26786769f580809256b4685ef316805265ea162'​const codec = contentHash.getCodec(encoded) // 'swarm-ns'codec === 'ipfs-ns' // falseNote for ipns: For security reasons, the encoding of ipns is only allowed for libp2p-key codec. Decoding with other formats will show a deprecation warning. Please read here for more detail.Coin type and encoding/decodingWhile some libraries allow you to query cryptocurrency addresses via their symbol (e.g.: BTC), others do not have the built-in support, and you have to call via each coin id (e.g.: 0 for BTC, 16 for `ETH). For Javascript/Typescript, we have @ensdomains/address-encoder library that allows you to convertimport { formatsByName, formatsByCoinType } from '@ensdomains/address-encoder';​formatsByName['BTC']// {// coinType: 0,// decoder: [Function (anonymous)],// encoder: [Function (anonymous)],// name: 'BTC'// }To save storage space as well as prevent users from setting wrong token address, the library has encoder and decoderconst data = formatsByName['BTC'].decoder('1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa');console.log(data.toString('hex')); // 76a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1888acconst addr = formatsByCoinType[0].encoder(data);console.log(addr); // 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNaListing cryptocurrency addresses and text recordsFor cryptocurrency addresses and text records, you need to know the coin type or key names to get the value. If you want to list down all the cryptocurrency addresses and text records the user has set, you have to either retrieve the information from Event or query via ENS subgraph.For example{ domains(where:{name:""vitalik.eth""}) { id name resolver{  texts  coinTypes } }}will return the following result{ ""data"": { ""domains"": [ { ""id"": ""0xee6c4522aab0003e8d14cd40a6af439055fd2577951148c14b6cea9a53475835"", ""name"": ""vitalik.eth"", ""resolver"": { ""coinTypes"": [ 60 ], ""texts"": [ ""url"" ] } } ] }}Reverse ResolutionWhile 'regular' resolution involves mapping from a name to an address, reverse resolution maps from an address back to a name. ENS supports reverse resolution to allow applications to display ENS names in place of hexadecimal addresses.Reverse resolution is accomplished via the special purpose domain addr.reverse and the resolver function name(). addr.reverse is owned by a special purpose registrar contract that allocates subdomains to the owner of the matching address - for instance, the address 0x314159265dd8dbb310642f98f50c066173c1259b may claim the name 314159265dd8dbb310642f98f50c066173c1259b.addr.reverse, and configure a resolver and records on it. The resolver in turn supports the name() function, which returns the name associated with that address.ENS does not enforce the accuracy of reverse records - for instance, anyone may claim that the name for their address is 'alice.eth'. To be certain that the claim is accurate, you must always perform a forward resolution for the returned name and check it matches the original address.Most libraries provide functionality for doing reverse resolution:ensjsweb3.jsethjs-ensethers.jsgo-ensweb3.pyweb3jconst address = '0x1234...';let ensName = null;({ name: ensName } = await ens.getName(address))// Check to be sure the reverse record is correct. skip check if the name is nullif(ensName == null || address != await ens.name(ensName).getAddress()) { ensName = null;}Not supported.var address = '0x1234...';var name = await ens.reverse(address);// Check to be sure the reverse record is correct.if(address != await ens.lookup(name)) { name = null;}var address = '0x1234...';var name = await provider.lookupAddress(address);// ethers.js automatically checks that the forward resolution matches.name, err := ens.ReverseResolve(client, common.HexToAddress(""0x1234..."")address = '0x1234...'name = ns.reverse(address)# Check to be sure the reverse record is correct.if address != ns.address(name): name = NoneString address = ""0x1234..."";String name = ens.reverseResolve(address);// Check to be sure the reverse record is correct.if(address != ens.resolve(name)) { name = null;}Reverse resolution without a library follows the same pattern as forward resolution: Get the resolver for 1234....addr.reverse(where 1234... is the address you want to reverse-resolve), and call the name() function on that resolver. Then, perform a forward resolution to verify the record is accurate.If you need to process many addresses (eg: showing reverse record of transaction histories), resolving both reverse and forward resolution for each item may not be practical. We have a seperate smart contract called ReverseRecords which allows you to lookup multiple names in one function call.const namehash = require('eth-ens-namehash');const allnames = await ReverseRecords.getNames(['0x123','0x124'])const validNames = allnames.filter((n) => namehash.normalize(n) === n )Make sure to compare that the returned names match with the normalised names to prevent from homograph attack as well as people simply using capital letters.Dapp Developer Guide - PreviousWorking with ENSNext - Dapp Developer GuideManaging NamesLast modified 6mo agoCopy linkEdit on GitHubOn this pageLooking up cryptocurrency addressesLooking up other resourcesEncoding and decoding contenthashCoin type and encoding/decodingListing cryptocurrency addresses and text recordsReverse Resolution "
85,mains v governance governance proposals term 1 ep7.2 executable q1 and q2 2022 ens ecosystem wg budget,"mains v governance governance proposals term 1 ep7.2 executable q1 and q2 2022 ens ecosystem wg budget.   [EP1.3.2] [Executable] Q1 & Q2 2022 ENS Ecosystem WG Budget - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1[EP1.1] [Executable] Set the temporary premium start price to $100,000[EP1.2.1] [Social] Removal of Brantly Millegan as Director of the ENS Foundation[EP1.2.2] [Social] Election of a new Director of The ENS Foundation[EP1.3.1] [Executable] Q1 & Q2 2022 Meta-Governance WG Budget[EP1.3.2] [Executable] Q1 & Q2 2022 ENS Ecosystem WG Budget[EP1.3.3] [Executable] Q1 & Q2 2022 Community WG Budget[EP1.3.4] [Executable] Q1 & Q2 2022 Public Goods WG Budget[EP1.4] [Executable] Reimburse True Names for expenses and tax obligations incurred for the DAO[EP1.5][Executable] Change to Exponential Premium Price Oracle[EP1.6] [Executable] A DAO-Governed Identity Server[EP1.7] [Executable] End the $ENS and EP2 airdrops[EP1.8] [Social] Working Group Rules[EP1.9] [Executable] Fund the Protocol Guild pilot with 200,000 $ENSTerm 2Term 3Powered By GitBook[EP1.3.2] [Executable] Q1 & Q2 2022 ENS Ecosystem WG BudgetStatusExecutedDiscussion Thread​Discourse​Votes​Snapshot, passed March 6th 2022 Onchain, passed March 29th 2022Note: This was previously numbered EP7.2.SummaryThe Ecosystem WG is requesting funding to start the Q1/Q2 2022 term. The initial request is made up of three components:1.Elected steward compensation: $27,500 in USDC/DAI2.Bounties for the Bug Bounty program: $50,000 in USDC/DAI3.Ecosystem WG operational budget: $50,000 in USDC/DAI, 6 ETH, and 6,500 $ENSBug BountyThe ENS Bounty Program provides bounties for bugs. This program has been running since 2017 and historically has been funded by True Names Limited (TNL). With the creation of the DAO, the DAO is now able to manage and fund the bug bounty. Details of the program can be found here. The $50,000 will be awarded to developers outside of TNL who find vulnerabilities in the ENS protocol. As well as funding for white hat coding in response to system vulnerabilities which arise.Operational BudgetThe operational budget supports ecosystem subgroups with the following allocations:Subgroup NameDescriptionUSDC/DAIETH$ENSHackathonsBounties, judging, and facilitating and managing ENS’s hackathon participation.$10,000​​IntegrationsBounties for ecosystem integration support$10,000500​3rd Party ProjectsSupport projects that improve the ENS ecosystem, through proactive and retroactive grants.$10,00061,000Bug BountyAdminister the bug bounty program$5,000​​WG Unallocated FundsFunds to be allocated to the above subgroups or facilitate the funding of new subgroups as the council of stewards deem necessary$15,0005,000​Total$50,000 USDC/DAI6 ETH6,500 $ENS​Elected Steward CompensationProvide compensation for the stewarding and the coordination efforts of active elected stewards.DescriptionCompensationMonths #Stewards #TotalBase Compensation$1,000/month5.53$16,500Supplement compensation*$2,000/month5.5N/A$11,000Total​$27,500 USDC/DAI​​*Supplement compensation is allocated to the steward who supports coordination or who has greater involvement in DAO activities above what is expected of a steward. The steward council determines how the supplemental compensation is split between the stewards based on contributions of each steward.It should be noted that the ecosystem working group has three elected stewards (@slobo.eth, @Ginge.eth, @bobjiang) and two appointed stewards (@nick.eth, @jefflau.eth). The appointed stewards are not compensated via this request.Previous[EP1.3.1] [Executable] Q1 & Q2 2022 Meta-Governance WG BudgetNext[EP1.3.3] [Executable] Q1 & Q2 2022 Community WG BudgetLast modified 6mo agoCopy linkEdit on GitHub "
86,mains v governance governance proposals term 0 ep3 social amend airdrop proposal to include accidentally returned funds,"mains v governance governance proposals term 0 ep3 social amend airdrop proposal to include accidentally returned funds.   [EP0.3] [Social] Amend airdrop proposal to include accidentally returned funds - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0[EP0.1] [Social] Proposal: Transfer ENS Treasury and Contract Ownership[EP0.2] [Executable] Retrospective airdrop for accounts that owned another account’s primary ENS 1[EP0.3] [Social] Amend airdrop proposal to include accidentally returned funds[EP0.4] [Social] Proposal: Creation of Foundational Working Groups and Working Group RulesTerm 1Term 2Term 3Powered By GitBook[EP0.3] [Social] Amend airdrop proposal to include accidentally returned fundsAmend EP2 to include funds accidentally sent back to the $ENS token contract.StatusPassedDiscussion thread​Discuss​Votes​Snapshot passed on 2021-12-12Note: This was previously numbered EP3.AbstractA number of users have accidentally sent $ENS tokens back to the token contract. As of December 6, this amounted to some 6,246 tokens in 49 separate transactions.These funds are held in the same account as is used for new airdrop claims, and on May 4, 2022 when the airdrop expires, the DAO will be able to claim them back to its own account.​EP2 sends approximately 200k tokens to users who owned ENS names that were used as primary names but did not already benefit from the 2x multiplier.This proposal suggests that EP2 be amended to include returning the mistakenly sent funds as part of the same airdrop. This minimises overhead, as the DAO will not incur transaction fees or have to set a separate system up, and enables users to get their mistakenly sent funds back promptly.SpecificationAmend EP2 as follows:-This logic is implemented by [this series of BigQuery queries](https://gist.github.com/Arachnid/667178e854945abaecb6dfd3b6c0c279/1182eea3145394181affe4bb799d6b7858f9eb58), and shows that 1,969 accounts meet these criteria but did not qualify for the multiplier under the original criteria. The sum of the tokens these accounts would be entitled to comes to ~213,049 ENS tokens. +This logic is implemented by [this series of BigQuery queries](https://gist.github.com/Arachnid/667178e854945abaecb6dfd3b6c0c279/106d9bc156988cf96786c71f6448f13fb11599fc), and shows that 1,969 accounts meet these criteria but did not qualify for the multiplier under the original criteria. The sum of the tokens these accounts would be entitled to comes to ~213,049 ENS tokens.-A list of affected accounts and balances is [here](https://gist.github.com/Arachnid/d6495f57ac6a5b17cf28e01b646e99a8). +A list of affected accounts and balances is [here](https://gist.github.com/Arachnid/e8b1a18fc19818fb00f51fbb8d90e429).-This proposal, if executed, will transfer 213,049 ENS tokens to [a new merkle airdrop contract ](https://github.com/ensdomains/governance/pull/9) allowing affected users to claim them. +Further, a number of users have accidentally transferred their ENS tokens to the token contract, totalling 6,246 contracts across 49 transfers. These tokens should be returned to their previous owners. +This proposal, if executed, will transfer 219,295 ENS tokens to [a new merkle airdrop contract ](https://github.com/ensdomains/governance/pull/9) allowing affected users to claim them.-3. Authorise the contract deployed in (1) to spend 213049736662531485206636 base ENS tokens from the ENS DAO account. +3. Authorise the contract deployed in (1) to spend 219295650978169915391391 base ENS tokens from the ENS DAO account.-const tx = await token.populateTransaction.approve(airdropAddress, '213049736662531485206636'); +const tx = await token.populateTransaction.approve(airdropAddress, '219295650978169915391391');Previous[EP0.2] [Executable] Retrospective airdrop for accounts that owned another account’s primary ENS 1Next[EP0.4] [Social] Proposal: Creation of Foundational Working Groups and Working Group RulesLast modified 6mo agoCopy linkEdit on GitHubOn this pageAbstractSpecification "
87,mains v governance governance proposals term 1,"mains v governance governance proposals term 1.   Term 1 - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1[EP1.1] [Executable] Set the temporary premium start price to $100,000[EP1.2.1] [Social] Removal of Brantly Millegan as Director of the ENS Foundation[EP1.2.2] [Social] Election of a new Director of The ENS Foundation[EP1.3.1] [Executable] Q1 & Q2 2022 Meta-Governance WG Budget[EP1.3.2] [Executable] Q1 & Q2 2022 ENS Ecosystem WG Budget[EP1.3.3] [Executable] Q1 & Q2 2022 Community WG Budget[EP1.3.4] [Executable] Q1 & Q2 2022 Public Goods WG Budget[EP1.4] [Executable] Reimburse True Names for expenses and tax obligations incurred for the DAO[EP1.5][Executable] Change to Exponential Premium Price Oracle[EP1.6] [Executable] A DAO-Governed Identity Server[EP1.7] [Executable] End the $ENS and EP2 airdrops[EP1.8] [Social] Working Group Rules[EP1.9] [Executable] Fund the Protocol Guild pilot with 200,000 $ENSTerm 2Term 3Powered By GitBookTerm 1November 4 2021 - June 31 2022Here are the articles in this section:[EP1.1] [Executable] Set the temporary premium start price to $100,000[EP1.2.1] [Social] Removal of Brantly Millegan as Director of the ENS Foundation[EP1.2.2] [Social] Election of a new Director of The ENS Foundation[EP1.3.1] [Executable] Q1 & Q2 2022 Meta-Governance WG Budget[EP1.3.2] [Executable] Q1 & Q2 2022 ENS Ecosystem WG Budget[EP1.3.3] [Executable] Q1 & Q2 2022 Community WG Budget[EP1.3.4] [Executable] Q1 & Q2 2022 Public Goods WG Budget[EP1.4] [Executable] Reimburse True Names for expenses and tax obligations incurred for the DAO[EP1.5][Executable] Change to Exponential Premium Price Oracle[EP1.6] [Executable] A DAO-Governed Identity Server[EP1.7] [Executable] End the $ENS and EP2 airdrops[EP1.8] [Social] Working Group Rules[EP1.9] [Executable] Fund the Protocol Guild pilot with 200,000 $ENSPrevious[EP0.4] [Social] Proposal: Creation of Foundational Working Groups and Working Group RulesNext[EP1.1] [Executable] Set the temporary premium start price to $100,000Last modified 6mo agoCopy linkEdit on GitHub "
88,mains ens improvement proposals ensip 10 wildcard resolution,"mains ens improvement proposals ensip 10 wildcard resolution.   ENSIP-10: Wildcard Resolution - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsENSIP-1: ENSENSIP-2: Initial Hash RegistrarENSIP-3: Reverse ResolutionENSIP-4: Support for contract ABIsENSIP-5: Text RecordsENSIP-6: DNS-in-ENSENSIP-7: Contenthash fieldENSIP-8: Interface DiscoveryENSIP-9: Multichain Address ResolutionENSIP-10: Wildcard ResolutionENSIP-11: EVM compatible Chain Address ResolutionENSIP-12: Avatar Text RecordsENSIP-13: SAFE Authentication for ENSENSIP-14: On-chain Source ParameterDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookENSIP-10: Wildcard ResolutionProvides a mechanism to support wildcard resolution of ENS names (formerly EIP-2544).AuthorNick Johnson <[email protected]>, 0age (@0age)StatusDraftSubmitted2020-02-28AbstractThe Ethereum Name Service Specification (ENSIP-1) establishes a two-step name resolution process. First, an ENS client performs the namehash algorithm on the name to determine the associated ""node"", and supplies that node to the ENS Registry contract to determine the resolver. Then, if a resolver has been set on the Registry, the client supplies that same node to the resolver contract, which will return the associated address or other record.As currently specified, this process terminates if a resolver is not set on the ENS Registry for a given node. This ENSIP changes the name resolution process by adding an additional step if a resolver is not set for a domain. This step strips out the leftmost label from the name, derives the node of the new fragment, and supplies that node to the ENS Registry. If a resolver is located for that node, the client supplies the original, complete node to that resolver contract to derive the relevant records. This step is repeated until a node with a resolver is found.Further, this specification defines a new way for resolvers to resolve names, using a unified resolve() method that permits more flexible handling of name resolution.MotivationMany applications such as wallet providers, exchanges, and dapps have expressed a desire to issue ENS names for their users via custom subdomains on a shared parent domain. However, the cost of doing so is currently prohibitive for large user bases, as a distinct record must be set on the ENS Registry for each subdomain.Furthermore, users cannot immediately utilize these subdomains upon account creation, as the transaction to assign a resolver for the node of the subdomain must first be submitted and mined on-chain. This adds unnecessary friction when onboarding new users, who coincidentally would often benefit greatly from the usability improvements afforded by an ENS name.Enabling wildcard support allows for the design of more advanced resolvers that deterministically generate addresses and other records for unassigned subdomains. The generated addresses could map to counterfactual contract deployment addresses (i.e. CREATE2 addresses), to designated ""fallback"" addresses, or other schemes. Additionally, individual resolvers would still be assignable to any given subdomain, which would supersede the wildcard resolution using the parent resolver.Another critical motivation with this standard is to enable wildcard resolution in a backwards-compatible fashion. It does not require modifying the current ENS Registry contract or any existing resolvers, and continues to support existing ENS records — legacy ENS clients would simply fail to resolve wildcard records.SpecificationThe key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.Let:namehash be the algorithm defined in ENSIP-1.dnsencode be the process for encoding DNS names specified in section 3.1 of RFC1035, with the exception that there is no limit on the total length of the encoded name. The empty string is encoded identically to the name '.', as a single 0-octet.parent be a function that removes the first label from a name (eg, parent('foo.eth') = 'eth'). parent('tld') is defined as the empty string ''.ens is the ENS registry contract for the current network.ENSIP-10-compliant ENS resolvers MAY implement the following function interface:interface ExtendedResolver { function resolve(bytes calldata name, bytes calldata data) external view returns(bytes);}If a resolver implements this function, it MUST return true when supportsInterface() is called on it with the interface's ID, 0x9061b923.ENS clients will call resolve with the DNS-encoded name to resolve and the encoded calldata for a resolver function (as specified in ENSIP-1 and elsewhere); the function MUST either return valid return data for that function, or revert if it is not supported.ENSIP-10-compliant ENS clients MUST perform the following procedure when determining the resolver for a given name:1.Set currentname = name2.Set resolver = ens.resolver(namehash(currentname))3.If resolver is not the zero address, halt and return resolver.4.If currentname is the empty name ('' or '.'), halt and return null.5.Otherwise, set currentname = parent(currentname) and go to 2.If the procedure above returns null, name resolution MUST terminate unsuccessfully. Otherwise, ENSIP-10-compliant ENS clients MUST perform the following procedure when resolving a record:1.Set calldata to the ABI-encoded call data for the resolution function required - for example, the ABI encoding of addr(namehash(name)) when resolving the addr record.2.Set supportsENSIP10 = resolver.supportsInterface('0x9061b923').3.If supportsENSIP10 is true, set result = resolver.resolve(dnsencode(name), calldata)4.If supportsENSIP10 is false and name == currentname, set result to the result of calling resolver with calldata.5.If neither 3 nor 4 are true, terminate unsuccessfully.6.Return result after decoding it using the return data ABI of the corresponding resolution function (eg, for addr(), ABI-decode the result of resolver.resolve() as an address).Note that in all cases the resolution function (addr() etc) and the resolve function are supplied the original name, not the currentname found in the first stage of resolution.Also note that when wildcard resolution is in use (eg, name != currentname), clients MUST NOT call legacy methods such as addr to resolve the name. These methods may only be called on resolvers set on an exact match for name.Pseudocodefunction getResolver(name) { for(let currentname = name; currentname !== ''; currentname = parent(currentname)) {  const node = namehash(currentname);  const resolver = ens.resolver(node);  if(resolver != '0x0000000000000000000000000000000000000000') {   return [resolver, currentname];  } } return [null, ''];}​function resolve(name, func, ...args) { const [resolver, resolverName] = getResolver(name); if(resolver === null) {  return null; } const supportsENSIP10 = resolver.supportsInterface('0x9061b923'); if(supportsENSIP10) {  const calldata = resolver[func].encodeFunctionCall(namehash(name), ...args);  const result = resolver.resolve(dnsencode(name), calldata);  return resolver[func].decodeReturnData(result); } else if(name == resolverName) {  return resolver[func](...args); } else {  return null; }}RationaleThe proposed implementation supports wildcard resolution in a manner that minimizes the impact to existing systems. It also reuses existing algorithms and procedures to the greatest possible extent, thereby easing the burden placed on authors and maintainers of various ENS clients.It also recognizes an existing consensus concerning the desirability of wildcard resolution for ENS, enabling more widespread adoption of the original specification by solving for a key scalability obstacle.While introducing an optional resolve function for resolvers, taking the unhashed name and calldata for a resolution function increases implementation complexity, it provides a means for resolvers to obtain plaintext labels and act accordingly, which enables many wildcard-related use-cases that would otherwise not be possible - for example, a wildcard resolver could resolve id.nifty.eth to the owner of the NFT with id id in some collection. With only namehashes to work with, this is not possible.The DNS wire format is used for encoding names as it permits quick and gas-efficient hashing of names, as well as other common operations such as fetching or removing individual labels; in contrast, dot-separated names require iterating over every character in the name to find the delimiter.Backwards CompatibilityExisting ENS clients that are compliant with ENSIP-1 will fail to resolve wildcard records and refuse to interact with them, while those compliant with ENSIP-10 will continue to correctly resolve, or reject, existing ENS records. Resolvers wishing to implement the new resolve function for non-wildcard use-cases (eg, where the resolver is set directly on the name being resolved) should consider what to return to legacy clients that call the individual resolution functions for maximum compatibility.Requiring clients to avoid calling existing resolution functions (eg, addr etc) on wildcard resolvers prevents inadvertant backwards compatiability issues with resolvers that answer queries for all names.Security ConsiderationsWhile compliant ENS clients will continue to refuse to resolve records without a resolver, there is still the risk that an improperly-configured client will refer to an incorrect resolver, or will not reject interactions with the null address when a resolver cannot be located.Additionally, resolvers supporting completely arbitrary wildcard subdomain resolution will increase the likelihood of funds being sent to unintended recipients as a result of typos. Applications that implement such resolvers should consider making additional name validation available to clients depending on the context, or implementing features that support recoverability of funds.There is also the possibility that some applications might require that no resolver be set for certain subdomains. For this to be problematic, the parent domain would need to successfully resolve the given subdomain node — to the knowledge of the authors, no application currently supports this feature or expects that subdomains should not resolve to a record.CopyrightCopyright and related rights waived via CC0.PreviousENSIP-9: Multichain Address ResolutionNextENSIP-11: EVM compatible Chain Address ResolutionLast modified 1yr agoCopy linkEdit on GitHubOn this pageAbstractMotivationSpecificationRationaleBackwards CompatibilitySecurity ConsiderationsCopyright "
89,mains ens improvement proposals ensip 12 avatar text records,"mains ens improvement proposals ensip 12 avatar text records.   ENSIP-12: Avatar Text Records - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsENSIP-1: ENSENSIP-2: Initial Hash RegistrarENSIP-3: Reverse ResolutionENSIP-4: Support for contract ABIsENSIP-5: Text RecordsENSIP-6: DNS-in-ENSENSIP-7: Contenthash fieldENSIP-8: Interface DiscoveryENSIP-9: Multichain Address ResolutionENSIP-10: Wildcard ResolutionENSIP-11: EVM compatible Chain Address ResolutionENSIP-12: Avatar Text RecordsENSIP-13: SAFE Authentication for ENSENSIP-14: On-chain Source ParameterDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookENSIP-12: Avatar Text RecordsA standard for storage of the avatar text record in ENS.AuthorNick Johnson <[email protected]>, Makoto Inoue <[email protected]>StatusDraftSubmitted2022-01-18AbstractThis ENSIP defines a process for retrieving avatar URIs from ENS, several URI schemes for the ENS 'avatar' text field, and how they should be interpreted by clients wishing to display a user's avatar image.MotivationENS primary name (formerly known as reverse record) has been widely integrated as a de facto web3 user name across many Ethereum based applications. As multiple apps started specifying avatar profile image as well as let users pick NFT as pfp (profile image), it became obvious to store such information within ENS so that the avatar information can be shared across different applications.This specification standardises a way to store and retrieve this information using ENSIP-5: Avatar Text Records​SpecificationRetrieving the avatar URIThe process for retrieving the avatar URI depends on whether the client has an Ethereum address or an ENS name to start with.ENS NameTo determine the avatar URI for an ENS name, the client MUST first look up the resolver for the name and call .text(namehash(name), 'avatar') on it to retrieve the avatar URI for the name.The client MUST treat the absence of a resolver, an revert when calling the addr method on the resolver, or an empty string returned by the resolver identically, as a failure to find a valid avatar URI.Ethereum AddressTo determine the avatar URI for an Ethereum address, the client MUST reverse-resolve the address by querying the ENS registry for the resolver of <address>.addr.reverse, where <address> is the lowercase hex-encoded Ethereum address, without leading '0x'. Then, the client calls .text(namehash('<address>.addr.reverse'), 'avatar') to retrieve the avatar URI for the address.If a resolver is returned for the reverse record, but calling text causes a revert or returns an empty string, the client MUST call .name(namehash('<address>.addr.reverse')). If this method returns a valid ENS name, the client MUST:1.Validate that the reverse record is valid, by resolving the returned name and calling addr on the resolver, checking it matches the original Ethereum address.2.Perform the process described under 'ENS Name' to look for a valid avatar URI on the name.A failure at any step of this process MUST be treated by the client identically as a failure to find a valid avatar URI.General FormatThe 'avatar' text field MUST be formatted as a URI. Clients MUST ignore URI types they do not recognise, treating them the same as if no value was set for the field.Image TypesClients MUST support images with mime types of image/jpeg, image/png, and image/svg+xml. Clients MAY support additional image types.URI TypesAll clients SHOULD support the URI schemes defined below. They MAY implement additional schemes not defined in this specification.httpsIf an https URI is provided, it MUST resolve to an avatar image directly. https URLs MUST NOT resolve to HTML pages, metadata, or other content containing the avatar image.ipfsIf an ipfs URI is provided, it MUST resolve to an avatar image directly. Clients without built-in IPFS support MAY rewrite the URI to an https URL referencing an IPFS gateway as described in this document before resolving it as an https URL.dataIf a data URL is provided, it MUST resolve to an avatar image directly.NFTsA reference to an NFT may be used as an avatar URI, following the standards defined in CAIP-22 and CAIP-29.Clients MUST support at least ERC721 and ERC1155 type NFTs, and MAY support additional types of NFT.To resolve an NFT URI, a client follows this process:1.Retrieve the metadata URI for the token specified in the avatar field URI.2.Resolve the metadata URI, fetching the ERC721 or ERC1155 metadata.3.Extract the image URL specified in the NFT metadata.4.Resolve the image URL and use it as the avatar.Clients MUST support at least https and ipfs URIs for resolving the metadata URI and the avatar image, and MAY support additional schemes. Clients MAY implement ifps scheme support by rewriting the URI to an HTTPS URL referencing an IPFS gateway as described above.Clients SHOULD additionally take the following verification steps:1.Where the avatar URI was retrieved via forward resolution (starting from an ENS name), call the addr function on the same resolver and for the same name to retrieve the Ethereum address to which the name resolves. Otherwise, if the avatar URI was retrieved via reverse resolution (starting from an Ethereum address), use that address.2.Verify that the address from step 1 is an owner of the NFT specified in the URI. If it is not, the client MUST treat the URI as invalid and behave in the same manner as they would if no avatar URI was specified.Clients MAY support NFT URIs by rewriting them to https URIs for a service that provides NFT avatar image resolution support.ExamplesThe following examples all resolve to the same avatar image:eip155:1/erc721:0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d/0 # BAYC token 0ipfs://QmRRPWG96cmgTn2qSzjwr2qvfNEuhunv6FNeMFGa9bx6mQ # IPFS hash for BAYC token 0 imagehttps://ipfs.io/ipfs/QmRRPWG96cmgTn2qSzjwr2qvfNEuhunv6FNeMFGa9bx6mQ # HTTPS URL to IPFS gateway for BAYC token 0 imageBackwards CompatibilityNot applicable.Security ConsiderationsNone.CopyrightCopyright and related rights waived via CC0.PreviousENSIP-11: EVM compatible Chain Address ResolutionNextENSIP-13: SAFE Authentication for ENSLast modified 11mo agoCopy linkEdit on GitHubOn this pageAbstractMotivationSpecificationExamplesBackwards CompatibilitySecurity ConsiderationsCopyright "
90,mains v governance governance proposals term 1 ep10 executable a dao governed identity server,"mains v governance governance proposals term 1 ep10 executable a dao governed identity server.   [EP1.6] [Executable] A DAO-Governed Identity Server - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1[EP1.1] [Executable] Set the temporary premium start price to $100,000[EP1.2.1] [Social] Removal of Brantly Millegan as Director of the ENS Foundation[EP1.2.2] [Social] Election of a new Director of The ENS Foundation[EP1.3.1] [Executable] Q1 & Q2 2022 Meta-Governance WG Budget[EP1.3.2] [Executable] Q1 & Q2 2022 ENS Ecosystem WG Budget[EP1.3.3] [Executable] Q1 & Q2 2022 Community WG Budget[EP1.3.4] [Executable] Q1 & Q2 2022 Public Goods WG Budget[EP1.4] [Executable] Reimburse True Names for expenses and tax obligations incurred for the DAO[EP1.5][Executable] Change to Exponential Premium Price Oracle[EP1.6] [Executable] A DAO-Governed Identity Server[EP1.7] [Executable] End the $ENS and EP2 airdrops[EP1.8] [Social] Working Group Rules[EP1.9] [Executable] Fund the Protocol Guild pilot with 200,000 $ENSTerm 2Term 3Powered By GitBook[EP1.6] [Executable] A DAO-Governed Identity ServerThis proposal is for the funding and establishment of a community-run OIDC Identity Provider Server for Sign-In with Ethereum, maintained by Spruce.​StatusExecutedVotes​Snapshot, passed March 21, 2022 Onchain, passed March 31, 2022Authors​Gregory Rocco, Wayne Chang​Note: This was previously numbered EP10.AbstractIn our research, we found that many services wanted to integrate the Sign-In with Ethereum workflow but did not have the ability to add new passwordless authentication methods to their installations.We also learned that most services already support OpenID Connect, and were open to adding a new Identity Provider that supported the SIWE workflow. By meeting those services where they are today, we can provide a pragmatic stepping stone towards true decentralization, with an upgrade path to direct authentication.To ensure adherence to the vision, it's critical that we collaborate with the ENS DAO on hosting and maintenance of this identity server, ensuring the identity server's governance ultimately resides with the community, whom we believe will always put users first. This would be the world’s first DAO-hosted, transparent identity server.RationaleThe ENS service and community would benefit from increased adoption of Sign-In with Ethereum due to the enablement of organizations to use ENS as a core touchpoint for a user’s basic identity and information (via ENS profiles).Additionally, we believe that a community server could be governed by a credibly neutral party that Ethereum users accept as an intermediary. We think a non-profit or DAO are the right structures to help govern such a server, which is why we would like to collaborate with the ENS DAO on hosting and maintenance.Specification and Proposal RequestEstablish a Subgroup in the Ecosystem Working Group: Community Managed Identity Server$250,000 allocated from the DAO to the Ecosystem WG to fund this Subgroup.$75,000 from the allocated budget will be in place for community contributions related to the Subgroup, including grants for development, evangelism, and retroactive rewards for SIWE-related efforts.$175,000 from the allocated budget will go towards Spruce's maintenance contract (see below). Paid 25% upon execution, and then an additional 25% every 3 months.This Subgroup will support the administration and maintenance of a DAO-run Identity Server for Sign-In with Ethereum. This subgroup will also serve as a support system to help onboard organizations, and evangelize Sign-In with Ethereum to allow users to control their identifiers and use ENS profiles as a base identity.An important part of duties this group will include creating training, onboarding, and maintenance materials for managing the server on a specified cloud account.Additionally, the group will be responsible for providing updates to the broader community on the health of the server.Initial lead: Rocco from Spruce, while continuing to add interested parties to the group for good governance.A 12-month maintenance contract awarded to Spruce for the continuous monitoring, maintaining, and improving of the deployed Identity Server.Spruce will help host a siwe-oidc implementation in a lightweight fashion, using a well-known infrastructure provider ultimately administered by the Subgroup.Spruce will also be responsible for the deployment, and continuous monitoring, maintenance, and improvements on the server throughout the duration of the contract.If the DAO votes to end the contract funding will be returned against the remaining days of the year and we will provide sufficient training for administrators to transfer those duties to a new organization.The server is expected to be live within 60 days of this proposal being accepted, assuming that access to the necessary systems and people is provided on a timely basis.The 1-year contract begins when this proposal is accepted, and there will not be additional setup fees even if there are increased coordination costs to get the service running.Previous[EP1.5][Executable] Change to Exponential Premium Price OracleNext[EP1.7] [Executable] End the $ENS and EP2 airdropsLast modified 6mo agoCopy linkEdit on GitHubOn this pageAbstractRationaleSpecification and Proposal Request "
91,mains contract api reference subgraphdata entities#textchanged,"mains contract api reference subgraphdata entities#textchanged.   Entities - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookEntitiesEntities​Domain​​DomainEvent​​Transfer​​NewOwner​​NewResolver​​NewTTL​​Account​​Registration​​RegistrationEvent​​NameRegistered​​NameRenewed​​NameTransferred​​Resolver​​ResolverEvent​​AddrChanged​​MulticoinAddrChanged​​NameChanged​​AbiChanged​​PubKeyChanged​​TextChanged​​ContentHashChanged​​InterfaceChanged​​AuthorisationChanged​DomainDescription:FieldTypeDescriptionidID!The namehash of the namenameStringThe human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)labelNameStringThe human readable label name (imported from CSV), if knownlabelhashByteskeccak256(labelName)parentDomainThe namehash (id) of the parent namesubdomains​Domain!​Can count domains from length of arraysubdomainCountInt!The number of subdomainsresolvedAddressaccountAddress logged from current resolver, if anyownerAccount!​resolverResolver​ttlBigInt​isMigratedBoolean!​createdAtBigInt!​events​DomainEvent!​​TransferDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​NewOwnerDescription:FieldTypeDescriptionidID!​parentDomainDomain!​domainDomain!​TransactionIDBytes!​ownerAccount!​NewResolverDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​resolverResolver!​NewTTLDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​transactionIDBytes!​ttlBigInt!​AccountDescription:FieldTypeDescriptionidID!​domain​Domain!​​registration​Registration!​​RegistrationDescription:FieldTypeDescriptionidID!​domainDomain​registrationDateBigInt!​expiryDateBigInt!​costBigInt!​registrantAccount!​labelNameString​events​RegistrationEven!​​RegistrationEventDescription:FieldTypeDescriptionidID!​registrationRegistrationEvent​blockNumberInt!​transactionIDBytes!​NameRegisteredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​registrantAccount!​expiryDateBigInt!​NameRenewedDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​expiryDateBigInt!​NameTransferredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​newOwnerAccount!​ResolverDescription:FieldTypeDescriptionidID!Concatenation of resolver address and namehashdomainDomain​addressBytes!Address of resolver contractaddrAccountCurrent value of addr record (per events)contenHashBytesContent hash, in binary formattexts[String!]Set of observed text record keyscointTypes[BigInt!]Set of observed SLIP-44 coin typesevents​ResolverEvent!​​ResolverEventDescription:FieldTypeDescriptionidID!Concatenation of block number and log IDresolverResolver!Used to derive relationships to ResolversblockNumberInt!​transactionIDBytes!​AddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​addrAccount!​MulticoinAddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​coinTypeBigInt!​addrBytes!​NameChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​nameString!​AbiChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​contentTypeBigInt!​PubkeyChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​xBytes!​yBytes!​TextChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​keyString!​valueString​ContenthashChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​hashBytes!​InterfaceChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​interfacedIDBytes!​implementerBytes!​AuthorisationChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​ownerBytes!​targetBytes!​isAuthorizedBoolean!​Contract API Reference - PreviousSubgraphNextQuery ExamplesLast modified 6mo agoCopy linkEdit on GitHubOn this pageEntitiesDomainTransferNewOwnerNewResolverNewTTLAccountRegistrationRegistrationEventNameRegisteredNameRenewedNameTransferredResolverResolverEventAddrChangedMulticoinAddrChangedNameChangedAbiChangedPubkeyChangedTextChangedContenthashChangedInterfaceChangedAuthorisationChanged "
92,mains frequently asked questions,"mains frequently asked questions.   Frequently Asked Questions - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookFrequently Asked QuestionsAbout the ENS RegistryWhy are names registered as hashes?Hashes provide a fixed length identifier that can easily be passed around between contracts with fixed overhead and no issues passing around variable-length strings.Which wallets and dapps support ENS so far?A partial list can be seen on our homepage.Once I own a name, can I create my own subdomains?Yes. You can create whatever subdomains you wish and assign ownership of them to other people if you desire. You can even set up your own registrar for your domain.Can I change the address my name points to after I’ve bought it?Yes, you can update the addresses and other resources pointed to by your name at any time.Can I register a TLD of my own in the ENS?No. We consider ENS to be part of the 'global namespace' inhabited by DNS, and so we do our best not to pollute that namespace. ENS-specific TLDs are restricted to only .eth (on mainnet), or .eth and .test (on Ropsten), plus any special purpose TLDs such as those required to permit reverse lookups.In addition to that, we are deploying support for importing DNS domains from the majority of DNS top-level domains using an integration that relies on DNSSEC. For details on those plans, please read this post.Who owns the ENS rootnode? What powers does that grant them?The root node is presently owned by a multisig contract, with keys held by trustworthy individuals in the Ethereum community. We expect that this will be hands-off, with the root ownership only used to effect administrative changes, such as the introduction of a new TLD, or to recover from an emergency such as a critical vulnerability in a TLD registrar.The keyholders are drawn from respected members of the community, and with the exception of Nick Johnson, founder of ENS, are unaffiliated with ENS. We ask and expect them to exercise their individual judgement acting in the interests of the ENS community, rather than rubber-stamping requests made to them by ENS developers.Since the owner of a node can change ownership of a subnode (unless they have otherwise locked it from their control), the owner of the root can change any node in the ENS tree. This means that the keyholders can replace the contracts that govern issuing and managing domains, giving them ultimate control over the structure of the ENS system and the names registered in it. However, the root key holders have locked control of the .eth registrar contract, which means that even keyholders cannot affect the ownership of .eth domains.The keyholders are still capable of doing the followings:Control allocation and replacement of TLDs other than .eth - this is required to implement DNSSEC integration.Enable and disable controllers for the .eth registrar, which affect registration and renewal policies for .eth names.Update the pricing for .eth names.Receive and manage registration revenue.Over time, we plan to reduce and decentralise human control over the system. Powers still held by the ENS root, such as those to set pricing and renewal conditions for domains, will be decentralised as robust systems become available to permit doing so.What about foreign characters? What about upper case letters? Is any unicode character valid?Since the ENS contracts only deal with hashes, they have no direct way to enforce limits on what can be registered; character length restrictions are implemented by allowing users to challenge a short name by providing its preimage to prove it’s too short.This means that you can in theory register both ‘foo.eth’ and ‘FOO.eth’, or even <picture of my cat>.eth. However, resolvers such as browsers and wallets should apply the nameprep algorithm to any names users enter before resolving; as a result, names that are not valid outputs of nameprep will not be resolvable by standard resolvers, making them effectively useless. Dapps that assist users with registering names should prevent users from registering unresolvable names by using nameprep to preprocess names being requested for registration.Nameprep isn ’t enforced in the ENS system. Is this a security/spoofing/phishing concern?It’s not enforced by the ENS contracts, but, as described above, resolvers are expected to use it before resolving names. This means that non-nameprep names will not be resolvable.What are the differences between ENS and other naming services such as Namecoin and Handshake?ENS complements and extends the usefulness of DNS with decentralised, trustworthy name resolution for web3 resources such as blockchain addresses and distributed content, while Namecoin and Handshake are efforts to replace all or part of DNS with a blockchain-based alternative.About the .eth Permanent RegistrarHow do the ENS Manager App and the Twitter bot know what names people are buying?The ENS Manager App and the Twitter bot have built-in lists of common names, drawn from an English dictionary and Alexa’s list of top 1 million Internet domain names. They use these lists to show you when common names are bought or renewed. We do this because if the app didn’t reveal these names, anyone with a little technical skill could find them out anyway, giving them an advantage over those who don’t have the capacity to build their own list and code to check names against it.What does it cost to register a .eth domain?Currently, registration costs are set at the following prices:5+ character .eth names: $5 in ETH per year.4 character .eth names: $160 in ETH per year.3 character .eth names $640 in ETH per year.3 and 4 character names have higher pricing to reflect the small number of these names available.What happens if I forget to extend the registration of a name?After your name expires, there is a 90 day grace period in which the owner can't edit the records but can still re-register the name. After the grace period, the name is released for registration by anyone with a temporary premium which decreases over a 21 days period. The released name continues to resolve your ETH address until the new owner overwrites it.What kinds of behaviours are likely to result in losing ownership of a name?The .eth registrar is structured such that names, once issued, cannot be revoked so long as an active registration is maintained.PreviousTerminologyNextENS DeploymentsLast modified 6mo agoCopy linkEdit on GitHubOn this pageAbout the ENS RegistryWhy are names registered as hashes?Which wallets and dapps support ENS so far?Once I own a name, can I create my own subdomains?Can I change the address my name points to after I’ve bought it?Can I register a TLD of my own in the ENS?Who owns the ENS rootnode? What powers does that grant them?What about foreign characters? What about upper case letters? Is any unicode character valid?Nameprep isn’t enforced in the ENS system. Is this a security/spoofing/phishing concern?What are the differences between ENS and other naming services such as Namecoin and Handshake?About the .eth Permanent RegistrarHow do the ENS Manager App and the Twitter bot know what names people are buying?What does it cost to register a .eth domain?What happens if I forget to extend the registration of a name?What kinds of behaviours are likely to result in losing ownership of a name? "
93,mains contract api reference .eth permanent registrar registrar#name registered,"mains contract api reference .eth permanent registrar registrar#name registered.   Registrar - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarRegistrarControllerDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookRegistrar​Source​This contract implements the core functionality of the permanent registrar, with the following features:The owner of the registrar may add and remove 'controllers'.Controllers may register new domains and extend the expiry of (renew) existing domains. They can not change the ownership or reduce the expiration time of existing domains.Name owners may transfer ownership to another address.Name owners may reclaim ownership in the ENS registry if they have lost it.Owners of names in the legacy registrar may transfer them to the new registrar, during the 1 year transition period. When they do so, their deposit is returned to them in its entirety.This section documents the parts of the registrar interface relevant to implementers of tools that interact with it. Functionality exclusive to the registrar owner or to controllers is omitted for brevity.The registrar works exclusively with label hashes - the keccak256 of the first component of the label (eg, keccak256('ens') for ens.eth). For compatibility with ERC721, these are expressed as uint256 values rather than bytes32, but can be cast backwards and forwards transparently. The namehash of a name can be derived by computing keccak256(baseNode, labelHash), where basenode is the namehash of the TLD the registrar manages - eg, namehash('eth').Registrations and renewals are handled via the controller.Names and RegistrationsAll names inside ENS have an owner. The owner of a name can transfer the name to a new owner, set a resolver, and create and reassign subdomains. This functionality is all contained in the ENS registry.Allocation of names directly under .eth (eg, second-level domains ending with .eth, such as alice.eth) is governed by the .eth Permanent Registrar, described here. While buying a name from the registrar grants ownership of it in ENS, the registrar itself keeps independent track of who owns the registration. The concept of a registrant - the owner of a registration - is unique to the .eth permanent registrar.The registrant of a name can transfer the registration to another account, and they can recover ownership of the name by calling reclaim, which resets ownership of the ENS name to the registrant's account.Separating the concept of owning a name from owning a registration makes it possible to more easily build systems that make automated updates to ENS. The registrant can transfer ownership of the name to another account or to a smart contract that manages records, subdomains, etc, while still retaining the ability to recover ownership for upgrades, or in the case of a compromise.When thinking about ownership, it's important to be clear whether you're considering ownership of the name or the registration.Read OperationsGet Name Expiryfunction nameExpires(uint256 label) external view returns(uint);Returns the unix timestamp at which a registration currently expires. Names that do not exist or are not yet migrated from the legacy registrar will return 0.Check Name Availabilityfunction available(uint256 label) public view returns(bool);Returns true if a name is available for registration. Takes into account not-yet-migrated registrations from the legacy registrar. Registrar controllers may impose more restrictions on registrations than this contract (for example, a minimum name length), so this function should not be used to check if a name can be registered by a user. To check if a name can be registered by a user, check name availability via the controller.Get Transfer Period Enduint public transferPeriodEnds;transferPeriodEnds documents the unix timestamp at which it is no longer possible to migrate over registrations from the legacy registrar, and any non-migrated registrations become available for registration by anyone.Get Controller Statusmapping(address=>bool) public controllers;controllers allows callers to check if the supplied address is authorized as a registrar controller.Check Token Approvalfunction getApproved(uint256 tokenId) public view returns (address operator);Returns the address of the approved operator for this name.This function is part of ERC721.Check All Tokens Approvalfunction isApprovedForAll(address owner, address operator) public view returns (bool);Returns true if operator is authorized to transfer all tokens for owner.This function is part of ERC721.Get Name Ownerfunction ownerOf(uint256 label) external view returns(address);ownerOf returns the address that owns the registration identified by the label hash, or reverts if the registration does not exist. Registrations that have not yet been migrated from the legacy registrar are treated the same as registrations that do not exist.This function is part of ERC721.Write OperationsTransfer a Namefunction transferFrom(address from, address to, uint256 tokenId) public;function safeTransferFrom(address from, address to, uint256 tokenId) public;function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;These functions transfer the registration.They behave as specified in ERC721.Emits the following event on a successful transfer:event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);Approve Operatorfunction approve(address to, uint256 tokenId) public;function setApprovalForAll(address operator, bool _approved) public;These functions manage approvals as documented in ERC721.Reclaim ENS Recordfunction reclaim(uint256 label) external;Sets the owner record of the name in the ENS registry to match the owner of the registration in this registry. May only be called by the owner of the registration.EventsName Migratedevent NameMigrated(uint256 indexed hash, address indexed owner, uint expires);This event is emitted when a name is migrated from the legacy registrar.Name Registeredevent NameRegistered(uint256 indexed hash, address indexed owner, uint expires);This event is emitted when a controller registers a new name.Name Renewedevent NameRenewed(uint256 indexed hash, uint expires);This event is emitted when a controller renews (extends the registration of) a name.Transferevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);This event is emitted when registration is transferred to a new owner. This is distinct from the ENS Registry's Transfer event, which records transfers of ownership of the ENS record.Contract API Reference - Previous.eth Permanent RegistrarNextControllerLast modified 1yr agoCopy linkEdit on GitHubOn this pageNames and RegistrationsRead OperationsGet Name ExpiryCheck Name AvailabilityGet Transfer Period EndGet Controller StatusCheck Token ApprovalCheck All Tokens ApprovalGet Name OwnerWrite OperationsTransfer a NameApprove OperatorReclaim ENS RecordEventsName MigratedName RegisteredName RenewedTransfer "
94,mains,"mains.   Introduction - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookIntroductionThe Ethereum Name Service (ENS) is a distributed, open, and extensible naming system based on the Ethereum blockchain.ENS’s job is to map human-readable names like ‘alice.eth’ to machine-readable identifiers such as Ethereum addresses, other cryptocurrency addresses, content hashes, and metadata. ENS also supports ‘reverse resolution’, making it possible to associate metadata such as canonical names or interface descriptions with Ethereum addresses.ENS has similar goals to DNS, the Internet’s Domain Name Service, but has significantly different architecture due to the capabilities and constraints provided by the Ethereum blockchain. Like DNS, ENS operates on a system of dot-separated hierarchical names called domains, with the owner of a domain having full control over subdomains.Top-level domains, like ‘.eth’ and ‘.test’, are owned by smart contracts called registrars, which specify rules governing the allocation of their subdomains. Anyone may, by following the rules imposed by these registrar contracts, obtain ownership of a domain for their own use. ENS also supports importing in DNS names already owned by the user for use on ENS.Because of the hierarchal nature of ENS, anyone who owns a domain at any level may configure subdomains - for themselves or others - as desired. For instance, if Alice owns 'alice.eth', she can create 'pay.alice.eth' and configure it as she wishes.ENS is deployed on the Ethereum main network and on several test networks. If you use a library such as the ensjs Javascript library, or an end-user application, it will automatically detect the network you are interacting with and use the ENS deployment on that network.You can try ENS out for yourself now by using the ENS Manager App, or by using any of the many ENS enabled applications on our homepage.ENS ArchitectureENS has two principal components: the registry, and resolvers.The ENS registry consists of a single smart contract that maintains a list of all domains and subdomains, and stores three critical pieces of information about each:The owner of the domainThe resolver for the domainThe caching time-to-live for all records under the domainThe owner of a domain may be either an external account (a user) or a smart contract. A registrar is simply a smart contract that owns a domain and issues subdomains of that domain to users that follow some set of rules defined in the contract.Owners of domains in the ENS registry may:Set the resolver and TTL for the domainTransfer ownership of the domain to another addressChange the ownership of subdomainsThe ENS registry is deliberately straightforward and exists only to map from a name to the resolver responsible for it.Resolvers are responsible for the actual process of translating names into addresses. Any contract that implements the relevant standards may act as a resolver in ENS. General-purpose resolver implementations are offered for users whose requirements are straightforward, such as serving an infrequently changed address for a name.Each record type - cryptocurrency address, IPFS content hash, and so forth - defines a method or methods that a resolver must implement in order to provide records of that kind. New record types may be defined at any time via the EIP standardization process, with no need to make changes to the ENS registry or to existing resolvers in order to support them.Resolving a name in ENS is a two-step process: First, ask the registry what resolver is responsible for the name, and second, ask that resolver for the answer to your query.In the above example, we're trying to find the Ethereum address pointed to by 'foo.eth'. First, we ask the registry which resolver is responsible for 'foo.eth'. Then, we query that resolver for the address of 'foo.eth'.NamehashResource constraints in smart contracts make interacting directly with human-readable names inefficient, so ENS works purely with fixed length 256-bit cryptographic hashes. In order to derive the hash from a name while still preserving its hierarchal properties, a process called Namehash is used. For example, the namehash of 'alice.eth' is 0x787192fc5378cc32aa956ddfdedbf26b24e8d78e40109add0eea2c1a012c3dec; this is the representation of names that is used exclusively inside ENS.Namehash is a recursive process that can generate a unique hash for any valid domain name. Starting with the namehash of any domain - for example, 'alice.eth' - it's possible to derive the namehash of any subdomain - for example 'iam.alice.eth' - without having to know or handle the original human-readable name. It is this property that makes it possible for ENS to provide a hierarchal system, without having to deal with human-readable text strings internally.Before being hashed with namehash, names are first normalized, using a process called UTS-46 normalization. This ensures that upper- and lower-case names are treated equivalently, and that invalid characters are prohibited. Anything that hashes and resolves a name must first normalize it, to ensure that all users get a consistent view of ENS.For details on how namehash and normalization works, see the developer documentation on name processing.Getting StartedENS has documentation for a variety of audiences, including dapp developers and contract developers, as well as reference documentation.I'm a dapp developer and want to add ENS support to my dappCheck out the dapp developer guide, starting with ENS Enabling your Dapp. You'll want to choose one of the many available ENS Libraries to get started working with ENS.I'm a contract developer and want to interact with ENS from my contract codeCheck out the Contract Developer Guide, starting with Resolving Names On-chain. You can also write your own resolver (to customise the process of looking up names), or your own registrar (to customise the process of registering new names).I want reference documentation for the ENS smart contractsCheck out the Contract API Reference. We have reference documentation for ENS's core contract, the registry, for resolvers, and for commonly-used registrars such as the Test registrar, reverse registrar, and the .eth registrar.NextTerminologyLast modified 1yr agoCopy linkEdit on GitHubOn this pageENS ArchitectureNamehashGetting Started "
95,mains ens migration february 2020 guide for dapp developers,"mains ens migration february 2020 guide for dapp developers.   Guide for DApp Developers - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookGuide for DApp DevelopersIf you maintain a DApp, wallet, or library that depends on ENS, you will need to take action to ensure no disruption occurs for your users during and after the migration period. This document describes what you will need to do in order to update your app.What you need to doWallets, libraries, and DApps that resolve namesYou should update the ENS registry address in your code to the new address of 0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e as soon as possible. This new address is functional now, and will return the same results as the old one. Switching now ensures your users will not experience any disruption or interruption of service.If you do not update the registry address by the time the migration process begins on February 3rd, your users will begin to see out-of-date results: Names registered or updated after the migration will not resolve correctly for your users.If you maintain a library, you should release a new version with the updated address, and notify users that they should update as soon as possible. You may wish to consider publishing instructions for ‘monkeypatching’ the new address, in situations where users cannot easily upgrade to the latest version.All ENS deployments across mainnet and all testnets now use the same addresses.Wallets, libraries, and DApps that register or update namesIf your DApp or library allows users to register names, or to make changes to existing names, you have two options:1.Simply switch over to the new registry address as soon as possible. When you do, users will be temporarily unable to make changes to their names using your app until their name is migrated between the 3rd and 5th of February.2.When making a change to a name, call the `recordExists` function on the new registry. If it returns `true`, send the modification transaction to the new registry; otherwise, send it to the old one. If you take this option, you should still prohibit transfers of .ETH ERC721 tokens; a transfer that happens as the name is migrated could result in confusing results for users.The migration process will automatically transfer .ETH second-level domains (eg, foo.eth) to the new registry and registrar. Subdomains (eg, bar.foo.eth) and other top-level domains (eg, foo.xyz) will need to be migrated by their owners. For more details on this process, see our documentation, or reach out to us for help.ENS Secondary MarketplacesIf you operate a marketplace that trades ENS names, you should immediately stop trading them. Although this vulnerability has not been exploited so far, once its existence is publicised we expect that attackers will reverse-engineer it and exploit it. Halting trading on the current registrar will prevent your users being affected by this.After a name has been migrated, tokens on the old registrar at 0xfac7bea255a6990f749363002136af6556b31e04 no longer correspond to ENS names, and are worthless; as a result you must disable trading of these before February 3rd 00:00UTC at the very latest.You can immediately enable trading of names on the new registrar, at address 0x57f1887a8BF19b14fC0dF6Fd9B2acc9Af147eA85. When names are migrated to this contract starting on February 3rd 00:00 UTC, domain owners will automatically have new ERC721 tokens created on this new registrar, with the same ID as those on the current registrar.Contract Developer Guide - PreviousWriting a RegistrarNext - ENS Migration (February 2020)Technical DescriptionLast modified 1yr agoCopy linkEdit on GitHubOn this pageWhat you need to doWallets, libraries, and DApps that resolve namesWallets, libraries, and DApps that register or update namesENS Secondary Marketplaces "
96,mains contract api reference subgraphdata entities#resistrationevent,"mains contract api reference subgraphdata entities#resistrationevent.   Entities - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookEntitiesEntities​Domain​​DomainEvent​​Transfer​​NewOwner​​NewResolver​​NewTTL​​Account​​Registration​​RegistrationEvent​​NameRegistered​​NameRenewed​​NameTransferred​​Resolver​​ResolverEvent​​AddrChanged​​MulticoinAddrChanged​​NameChanged​​AbiChanged​​PubKeyChanged​​TextChanged​​ContentHashChanged​​InterfaceChanged​​AuthorisationChanged​DomainDescription:FieldTypeDescriptionidID!The namehash of the namenameStringThe human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)labelNameStringThe human readable label name (imported from CSV), if knownlabelhashByteskeccak256(labelName)parentDomainThe namehash (id) of the parent namesubdomains​Domain!​Can count domains from length of arraysubdomainCountInt!The number of subdomainsresolvedAddressaccountAddress logged from current resolver, if anyownerAccount!​resolverResolver​ttlBigInt​isMigratedBoolean!​createdAtBigInt!​events​DomainEvent!​​TransferDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​NewOwnerDescription:FieldTypeDescriptionidID!​parentDomainDomain!​domainDomain!​TransactionIDBytes!​ownerAccount!​NewResolverDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​resolverResolver!​NewTTLDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​transactionIDBytes!​ttlBigInt!​AccountDescription:FieldTypeDescriptionidID!​domain​Domain!​​registration​Registration!​​RegistrationDescription:FieldTypeDescriptionidID!​domainDomain​registrationDateBigInt!​expiryDateBigInt!​costBigInt!​registrantAccount!​labelNameString​events​RegistrationEven!​​RegistrationEventDescription:FieldTypeDescriptionidID!​registrationRegistrationEvent​blockNumberInt!​transactionIDBytes!​NameRegisteredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​registrantAccount!​expiryDateBigInt!​NameRenewedDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​expiryDateBigInt!​NameTransferredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​newOwnerAccount!​ResolverDescription:FieldTypeDescriptionidID!Concatenation of resolver address and namehashdomainDomain​addressBytes!Address of resolver contractaddrAccountCurrent value of addr record (per events)contenHashBytesContent hash, in binary formattexts[String!]Set of observed text record keyscointTypes[BigInt!]Set of observed SLIP-44 coin typesevents​ResolverEvent!​​ResolverEventDescription:FieldTypeDescriptionidID!Concatenation of block number and log IDresolverResolver!Used to derive relationships to ResolversblockNumberInt!​transactionIDBytes!​AddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​addrAccount!​MulticoinAddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​coinTypeBigInt!​addrBytes!​NameChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​nameString!​AbiChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​contentTypeBigInt!​PubkeyChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​xBytes!​yBytes!​TextChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​keyString!​valueString​ContenthashChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​hashBytes!​InterfaceChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​interfacedIDBytes!​implementerBytes!​AuthorisationChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​ownerBytes!​targetBytes!​isAuthorizedBoolean!​Contract API Reference - PreviousSubgraphNextQuery ExamplesLast modified 6mo agoCopy linkEdit on GitHubOn this pageEntitiesDomainTransferNewOwnerNewResolverNewTTLAccountRegistrationRegistrationEventNameRegisteredNameRenewedNameTransferredResolverResolverEventAddrChangedMulticoinAddrChangedNameChangedAbiChangedPubkeyChangedTextChangedContenthashChangedInterfaceChangedAuthorisationChanged "
97,mains ens improvement proposals ensip 3 reverse resolution,"mains ens improvement proposals ensip 3 reverse resolution.   ENSIP-3: Reverse Resolution - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsENSIP-1: ENSENSIP-2: Initial Hash RegistrarENSIP-3: Reverse ResolutionENSIP-4: Support for contract ABIsENSIP-5: Text RecordsENSIP-6: DNS-in-ENSENSIP-7: Contenthash fieldENSIP-8: Interface DiscoveryENSIP-9: Multichain Address ResolutionENSIP-10: Wildcard ResolutionENSIP-11: EVM compatible Chain Address ResolutionENSIP-12: Avatar Text RecordsENSIP-13: SAFE Authentication for ENSENSIP-14: On-chain Source ParameterDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookENSIP-3: Reverse ResolutionSpecifies a TLD, registrar, and resolver interface for reverse resolution of Ethereum addresses using ENS (formerly EIP-181).AuthorNick Johnson <[email protected]>StatusFinalSubmitted2016-12-01AbstractThis ENSIP specifies a TLD, registrar, and resolver interface for reverse resolution of Ethereum addresses using ENS. This permits associating a human-readable name with any Ethereum blockchain address. Resolvers can be certain that the reverse record was published by the owner of the Ethereum address in question.MotivationWhile name services are mostly used for forward resolution - going from human-readable identifiers to machine-readable ones - there are many use-cases in which reverse resolution is useful as well:Applications that allow users to monitor accounts benefit from showing the name of an account instead of its address, even if it was originally added by address.Attaching metadata such as descriptive information to an address allows retrieving this information regardless of how the address was originally discovered.Anyone can configure a name to resolve to an address, regardless of ownership of that address. Reverse records allow the owner of an address to claim a name as authoritative for that address.SpecificationReverse ENS records are stored in the ENS hierarchy in the same fashion as regular records, under a reserved domain, addr.reverse. To generate the ENS name for a given account's reverse records, convert the account to hexadecimal representation in lower-case, and append addr.reverse. For instance, the ENS registry's address at 0x112234455c3a32fd11230c42e7bccd4a84e02010 has any reverse records stored at 112234455c3a32fd11230c42e7bccd4a84e02010.addr.reverse.Note that this means that contracts wanting to do dynamic reverse resolution of addresses will need to perform hex encoding in the contract.RegistrarThe owner of the addr.reverse domain will be a registrar that permits the caller to take ownership of the reverse record for their own address. It provides the following methods:function claim(address owner) returns (bytes32 node)When called by account x, instructs the ENS registry to transfer ownership of the name hex(x) + '.addr.reverse' to the provided address, and return the namehash of the ENS record thus transferred.Allowing the caller to specify an owner other than themselves for the relevant node facilitates contracts that need accurate reverse ENS entries delegating this to their creators with a minimum of code inside their constructor:reverseRegistrar.claim(msg.sender)function claimWithResolver(address owner, address resolver) returns (bytes32 node)When called by account x, instructs the ENS registry to set the resolver of the name hex(x) + '.addr.reverse' to the specified resolver, then transfer ownership of the name to the provided address, and return the namehash of the ENS record thus transferred. This method facilitates setting up a custom resolver and owner in fewer transactions than would be required if calling claim.function setName(string name) returns (bytes32 node)When called by account x, sets the resolver for the name hex(x) + '.addr.reverse' to a default resolver, and sets the name record on that name to the specified name. This method facilitates setting up simple reverse records for users in a single transaction.Resolver interfaceA new resolver interface is defined, consisting of the following method:function name(bytes32 node) constant returns (string);Resolvers that implement this interface must return a valid ENS name for the requested node, or the empty string if no name is defined for the requested node.The interface ID of this interface is 0x691f3431.Future ENSIPs may specify more record types appropriate to reverse ENS records.Appendix 1: Registrar implementationThis registrar, written in Solidity, implements the specifications outlined above.pragma solidity ^0.4.10;​import ""./AbstractENS.sol"";​contract Resolver { function setName(bytes32 node, string name) public;}​/** * @dev Provides a default implementation of a resolver for reverse records, * which permits only the owner to update it. */contract DefaultReverseResolver is Resolver { AbstractENS public ens; mapping(bytes32=>string) public name;​ /**  * @dev Constructor  * @param ensAddr The address of the ENS registry.  */ function DefaultReverseResolver(AbstractENS ensAddr) {  ens = ensAddr; }​ /**  * @dev Only permits calls by the reverse registrar.  * @param node The node permission is required for.  */ modifier owner_only(bytes32 node) {  require(msg.sender == ens.owner(node));  _; }​ /**  * @dev Sets the name for a node.  * @param node The node to update.  * @param _name The name to set.  */ function setName(bytes32 node, string _name) public owner_only(node) {  name[node] = _name; }}​contract ReverseRegistrar { // namehash('addr.reverse') bytes32 constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;​ AbstractENS public ens; Resolver public defaultResolver;​ /**  * @dev Constructor  * @param ensAddr The address of the ENS registry.  * @param resolverAddr The address of the default reverse resolver.  */ function ReverseRegistrar(AbstractENS ensAddr, Resolver resolverAddr) {  ens = ensAddr;  defaultResolver = resolverAddr; }​ /**  * @dev Transfers ownership of the reverse ENS record associated with the  *  calling account.  * @param owner The address to set as the owner of the reverse record in ENS.  * @return The ENS node hash of the reverse record.  */ function claim(address owner) returns (bytes32 node) {  return claimWithResolver(owner, 0); }​ /**  * @dev Transfers ownership of the reverse ENS record associated with the  *  calling account.  * @param owner The address to set as the owner of the reverse record in ENS.  * @param resolver The address of the resolver to set; 0 to leave unchanged.  * @return The ENS node hash of the reverse record.  */ function claimWithResolver(address owner, address resolver) returns (bytes32 node) {  var label = sha3HexAddress(msg.sender);  node = sha3(ADDR_REVERSE_NODE, label);  var currentOwner = ens.owner(node);​  // Update the resolver if required  if(resolver != 0 && resolver != ens.resolver(node)) {   // Transfer the name to us first if it's not already   if(currentOwner != address(this)) {    ens.setSubnodeOwner(ADDR_REVERSE_NODE, label, this);    currentOwner = address(this);   }   ens.setResolver(node, resolver);  }​  // Update the owner if required  if(currentOwner != owner) {   ens.setSubnodeOwner(ADDR_REVERSE_NODE, label, owner);  }​  return node; }​ /**  * @dev Sets the `name()` record for the reverse ENS record associated with  * the calling account. First updates the resolver to the default reverse  * resolver if necessary.  * @param name The name to set for this address.  * @return The ENS node hash of the reverse record.  */ function setName(string name) returns (bytes32 node) {  node = claimWithResolver(this, defaultResolver);  defaultResolver.setName(node, name);  return node; }​ /**  * @dev Returns the node hash for a given account's reverse records.  * @param addr The address to hash  * @return The ENS node hash.  */ function node(address addr) constant returns (bytes32 ret) {  return sha3(ADDR_REVERSE_NODE, sha3HexAddress(addr)); }​ /**  * @dev An optimised function to compute the sha3 of the lower-case  *  hexadecimal representation of an Ethereum address.  * @param addr The address to hash  * @return The SHA3 hash of the lower-case hexadecimal encoding of the  *   input address.  */ function sha3HexAddress(address addr) private returns (bytes32 ret) {  addr; ret; // Stop warning us about unused variables  assembly {   let lookup := 0x3031323334353637383961626364656600000000000000000000000000000000   let i := 40  loop:   i := sub(i, 1)   mstore8(i, byte(and(addr, 0xf), lookup))   addr := div(addr, 0x10)   i := sub(i, 1)   mstore8(i, byte(and(addr, 0xf), lookup))   addr := div(addr, 0x10)   jumpi(loop, i)   ret := sha3(0, 40)  } }}CopyrightCopyright and related rights waived via CC0.PreviousENSIP-2: Initial Hash RegistrarNextENSIP-4: Support for contract ABIsLast modified 1yr agoCopy linkEdit on GitHubOn this pageAbstractMotivationSpecificationRegistrarResolver interfaceAppendix 1: Registrar implementationCopyright "
98,mains deploying ens on a private chain#deploy a registrar,"mains deploying ens on a private chain#deploy a registrar.   Deploying ENS on a Private Chain - ENS Documentation    ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookDeploying ENS on a Private ChainIf you’d like to deploy ENS on your own network, or deploy your own copy of ENS on a public network, this guide shows you how. If you want to use an existing ENS deployment, see Resolving Names, Managing Names, and Registering & Renewing Names instead.On this page we will use Javascript, Web3, and Hardhat with npm for simplicity. You will find a complete migration file example at the bottom of this page.Please be aware that existing frameworks such as waffle and embark have support for local ENS deployment as well.Importing contractsThe essential smart contracts are published as npm modules. You can install them in your npm project with npm install @ensdomains/ens-contracts. Now, you can require them in a migration script as follows (see the Truffle Documentation on working with contract artifacts and npm for details)import { ENS, ENSRegistry, PublicResolver} from '@ensdomains/ens-contracts'Including them within your smart contract is as followsimport '@ensdomains/ens-contracts/contracts/registry/ENS.sol'ENS contains only an interface while ENSRegistry includes the actual implementation.Deploy the RegistryThe registry is ENS’s central component and stores, among other things, who owns which domain. This is the example using ethers and hardhat.const ENSRegistry = await ethers.getContractFactory(""ENSRegistry"")await ENSRegistry.deploy()Once deployed, you will have a fresh ENS registry, whose root node is owned by the account that submitted the transaction. This account has total control over the ENS registry - it can create and replace any node in the entire tree.From here, it's possible to create and manage names by directly interacting with the registry, as described in Managing Names. However, you will probably want to deploy a resolver, and you may want to deploy a registrar so other users can register names.Deploy a ResolverRecords in the registry can point to resolver contracts which store additional domain information. The most common use-case is to store an address for a domain, but storing a contract ABI or text is also possible. For most purposes on private networks it's convenient to have an unrestricted general-purpose resolver available. Deploying one is straightforward:const ZERO_ADDRESS = ""0x0000000000000000000000000000000000000000"";const ENSRegistry = await ethers.getContractFactory(""ENSRegistry"")const registry = await ENSRegistry.deploy()await registry.deployed()const PublicResolver = await ethers.getContractFactory(""PublicResolver"")const resolver = await PublicResolver.deploy(registry.address, ZERO_ADDRESS);await resolver.deployed()The PublicResolver looks up ownership in the registry, which is why the registry's address is required at deployment.For ease of use, we can give this resolver a name:const ethers = require('ethers');const utils = ethers.utils;const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label))const namehash = require('eth-ens-namehash');​async function setupResolver(ens, resolver, accounts) { const resolverNode = namehash.hash(""resolver""); const resolverLabel = labelhash(""resolver"");​ await ens.setSubnodeOwner(""0x0000000000000000000000000000000000000000"", resolverLabel, accounts[0]); await ens.setResolver(resolverNode, resolver.address); await resolver.setAddr(resolverNode, resolver.address);}Above, we first create a new top-level domain, ""resolver"", then set its resolver address to our newly deployed public resolver. Finally, we set up an address record for ""resolver"", pointing back to the resolver address. In effect, the resolver is answering queries about its own address. After this, anyone can find the public resolver at the special ENS name ""resolver"". We call this function after deploying the public resolver in a .then() block as we did with the resolver.Deploy a RegistrarSo far, domains can only be registered manually by the owner of the registry's root node. Fortunately, contracts can also own nodes. This means we can set up a registrar contract as the owner of a node, e.g. ""test"", in the registry which enables it to distribute subdomains such as ""mycontract.test"". It allows us to have custom, on-chain logic which governs domain allocation. Once we own a (sub-)node we are free to repeat this process and set up another registrar. If you are part of the ""myorg"" organisation you could register ""myorg.test"" and let it point to your custom registrar which only allows certified members of your organisation to claim subdomains such as ""bob.myorg.test"". For our private network, we'll use the simple 'first come, first served' FIFSRegistrar, and set it as the owner of the top-level domain ""test"" in our migration script:... const registrar = await FIFSRegistrar.deploy(ens.address, namehash.hash(""test"")); await registrar.deployed(); await ens.setSubnodeOwner(""0x0000000000000000000000000000000000000000"", sha3(""test""), registrar.address);})...Deploy the Reverse RegistrarSimilarly, if you wish to enable reverse resolution on your deployment, you will need to deploy the reverse registrar:...const reverseRegistrar = await ReverseRegistrar.deploy(ens.address, resolver.address);await reverseRegistrar.deployed();setupReverseRegistrar(ens, resolver, reverseRegistrar, accounts);...​async function setupReverseRegistrar(ens, resolver, reverseRegistrar, accounts) { await ens.setSubnodeOwner(""0x0000000000000000000000000000000000000000"", utils.sha3(""reverse""), accounts[0]); await ens.setSubnodeOwner(namehash.hash(""reverse""), utils.sha3(""addr""), reverseRegistrar.address);}Migration File ExampleWe can combine the steps above in a single hardhat migration file. This allows us to deploy ENS in one go:contracts/deps.sol//SPDX-License-Identifier: MIT// These imports are here to force Hardhat to compile contracts we depend on in our tests but don't need anywhere else.import ""@ensdomains/ens-contracts/contracts/registry/ENSRegistry.sol"";import ""@ensdomains/ens-contracts/contracts/registry/FIFSRegistrar.sol"";import ""@ensdomains/ens-contracts/contracts/resolvers/PublicResolver.sol"";script/deploy.jsconst hre = require(""hardhat"");const namehash = require('eth-ens-namehash');const tld = ""test"";const ethers = hre.ethers;const utils = ethers.utils;const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label))const ZERO_ADDRESS = ""0x0000000000000000000000000000000000000000"";const ZERO_HASH = ""0x0000000000000000000000000000000000000000000000000000000000000000"";async function main() { const ENSRegistry = await ethers.getContractFactory(""ENSRegistry"") const FIFSRegistrar = await ethers.getContractFactory(""FIFSRegistrar"") const ReverseRegistrar = await ethers.getContractFactory(""ReverseRegistrar"") const PublicResolver = await ethers.getContractFactory(""PublicResolver"") const signers = await ethers.getSigners(); const accounts = signers.map(s => s.address)​ const ens = await ENSRegistry.deploy() await ens.deployed() const resolver = await PublicResolver.deploy(ens.address, ZERO_ADDRESS); await resolver.deployed() await setupResolver(ens, resolver, accounts) const registrar = await FIFSRegistrar.deploy(ens.address, namehash.hash(tld)); await registrar.deployed() await setupRegistrar(ens, registrar); const reverseRegistrar = await ReverseRegistrar.deploy(ens.address, resolver.address); await reverseRegistrar.deployed() await setupReverseRegistrar(ens, registrar, reverseRegistrar, accounts);};​async function setupResolver(ens, resolver, accounts) { const resolverNode = namehash.hash(""resolver""); const resolverLabel = labelhash(""resolver""); await ens.setSubnodeOwner(ZERO_HASH, resolverLabel, accounts[0]); await ens.setResolver(resolverNode, resolver.address); await resolver['setAddr(bytes32,address)'](resolverNode, resolver.address);}​async function setupRegistrar(ens, registrar) { await ens.setSubnodeOwner(ZERO_HASH, labelhash(tld), registrar.address);}​async function setupReverseRegistrar(ens, registrar, reverseRegistrar, accounts) { await ens.setSubnodeOwner(ZERO_HASH, labelhash(""reverse""), accounts[0]); await ens.setSubnodeOwner(namehash.hash(""reverse""), labelhash(""addr""), reverseRegistrar.address);}​// We recommend this pattern to be able to use async/await everywhere// and properly handle errors.main() .then(() => process.exit(0)) .catch((error) => { console.error(error); process.exit(1); });To execute the migration file on hardhat, run the following command line.npx hardhat run scripts/deploy.jsDeploying ENS in a single transactionAlternately you may wish to deploy a test registrar and its dependencies with a single transaction. This is useful for example in unit tests where you wish to start from a clean slate in each test. In many cases it will also be faster than sending a series of separate transactions.This can be done by deploying a new contract that creates and sets up all the other contracts in its constructor. The below code creates all the ENS contracts and assigns the eth TLD to the FIFS Registrar so that any eth domain may be registered in the unit tests.pragma solidity >=0.8.4;import {INameWrapper, PublicResolver} from '@ensdomains/ens-contracts/contracts/resolvers/PublicResolver.sol';import '@ensdomains/ens-contracts/contracts/registry/ENSRegistry.sol';import '@ensdomains/ens-contracts/contracts/registry/FIFSRegistrar.sol';import {NameResolver, ReverseRegistrar} from '@ensdomains/ens-contracts/contracts/registry/ReverseRegistrar.sol';​// Construct a set of test ENS contracts.contract ENSDeployer { bytes32 public constant TLD_LABEL = keccak256('eth'); bytes32 public constant RESOLVER_LABEL = keccak256('resolver'); bytes32 public constant REVERSE_REGISTRAR_LABEL = keccak256('reverse'); bytes32 public constant ADDR_LABEL = keccak256('addr');​ ENSRegistry public ens; FIFSRegistrar public fifsRegistrar; ReverseRegistrar public reverseRegistrar; PublicResolver public publicResolver;​ function namehash(bytes32 node, bytes32 label) public pure returns (bytes32) { return keccak256(abi.encodePacked(node, label)); }​ constructor() public { ens = new ENSRegistry(); publicResolver = new PublicResolver(ens, INameWrapper(address(0)));​ // Set up the resolver bytes32 resolverNode = namehash(bytes32(0), RESOLVER_LABEL);​ ens.setSubnodeOwner(bytes32(0), RESOLVER_LABEL, address(this)); ens.setResolver(resolverNode, address(publicResolver)); publicResolver.setAddr(resolverNode, address(publicResolver));​ // Create a FIFS registrar for the TLD fifsRegistrar = new FIFSRegistrar(ens, namehash(bytes32(0), TLD_LABEL));​ ens.setSubnodeOwner(bytes32(0), TLD_LABEL, address(fifsRegistrar));​ // Construct a new reverse registrar and point it at the public resolver reverseRegistrar = new ReverseRegistrar(  ens,  NameResolver(address(publicResolver)) );​ // Set up the reverse registrar ens.setSubnodeOwner(bytes32(0), REVERSE_REGISTRAR_LABEL, address(this)); ens.setSubnodeOwner(  namehash(bytes32(0), REVERSE_REGISTRAR_LABEL),  ADDR_LABEL,  address(reverseRegistrar) ); }}PreviousRegistrar Frequently Asked QuestionsNextDNS Registrar guideLast modified 1yr agoCopy linkEdit on GitHubOn this pageImporting contractsDeploy the RegistryDeploy a ResolverDeploy a RegistrarDeploy the Reverse RegistrarMigration File Examplecontracts/deps.solscript/deploy.jsDeploying ENS in a single transaction "
99,mains v governance governance proposals term 2 ep16.3 executable q3 and q4 2022 public goods wg budget,"mains v governance governance proposals term 2 ep16.3 executable q3 and q4 2022 public goods wg budget.   [EP2.2.3] [Executable] Q3 & Q4 2022 Public Goods WG Budget - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1Term 2[EP2.1] [Executable] Funding True Names Ltd[EP2.2.1] [Executable] Q3 & Q4 2022 Meta-Governance WG Budget[EP2.2.2] [Executable] Q3 & Q4 2022 Ecosystem WG Budget[EP2.2.3] [Executable] Q3 & Q4 2022 Public Goods WG Budget[EP2.2.4] [Social] ENS Endaoment RFP[EP2.2.5] [Social] Selection of an ENS endowment fund managerTerm 3Powered By GitBook[EP2.2.3] [Executable] Q3 & Q4 2022 Public Goods WG BudgetStatusExecutedDiscussion Thread​Discourse​Votes​Snapshot - Passed​Onchain - ExecutedNote: This was previously numbered EP16.3.SummaryThe Public Goods Working Group is requesting funding of 430,650 USD equivalent for the second term. The budget has five categories. All figures are presented in USD equivalent.Screen Shot 2022-07-19 at 6.17.05 PM|690x254, 50%July 19, 2022. ETH = 1500 USD and ENS = 11.00 USD.Multisigs / Subgroups: $431k USD ValueFunding for each category is associated with a multisig wallet that has a clearly defined mandate. These multisigs been approved by current stewards of the ENS Public Goods working group.BudgetScreen Shot 2022-07-19 at 6.18.49 PM|690x119DescriptionThe breakdown of each Multisig/Subgroup is the following. The PG Pod is the main multisig for the Public Goods Working Group.Screen Shot 2022-07-19 at 6.00.42 PM|690x158Grants: $173K USD ValueFunding in this category supports grants that will be distributed through two mechanisms for this term. Rapid Grants will be distributed through the ENS DAO small grants platform, adopting the Nouns Prop.House model. Grants may also be funded for retro-active value provided by web3 Public Goods, with Steward approval.BudgetScreen Shot 2022-07-19 at 5.11.33 PM|690x65Bounties: $113K USD ValueFunding for projects that accomplish certain goals that will be set out in a list of available bounties. Bounties will relate to initiatives and projects for which there is a need that benefits the broader web3 community.BudgetScreen Shot 2022-07-19 at 5.11.44 PM|690x40Gitcoin GR15 & GR16: $100K USD ValueFunding in this category relates to matching funds provided for the main Gitcoin Grants Rounds over the next six months, GR15 and GR16. This amount is not related to the funding for the ENS Ecosystem Round, which is funded by the Ecosystem Working Group.BudgetScreen Shot 2022-07-19 at 5.11.53 PM|690x39Unallocated: $45K USDThe funds in this category are reserved for unforeseen grants and unexpected expenses for the term.BudgetScreen Shot 2022-07-19 at 6.34.24 PM|690x64Previous[EP2.2.2] [Executable] Q3 & Q4 2022 Ecosystem WG BudgetNext[EP2.2.4] [Social] ENS Endaoment RFPLast modified 6mo agoCopy linkEdit on GitHubOn this pageSummaryMultisigs / Subgroups: $431k USD ValueGrants: $173K USD ValueBounties: $113K USD ValueGitcoin GR15 & GR16: $100K USD ValueUnallocated: $45K USD "
100,mains v governance governance proposals term 1 ep8 executable reimburse true names for expenses and tax obligations incurred for the dao,"mains v governance governance proposals term 1 ep8 executable reimburse true names for expenses and tax obligations incurred for the dao.   [EP1.4] [Executable] Reimburse True Names for expenses and tax obligations incurred for the DAO - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1[EP1.1] [Executable] Set the temporary premium start price to $100,000[EP1.2.1] [Social] Removal of Brantly Millegan as Director of the ENS Foundation[EP1.2.2] [Social] Election of a new Director of The ENS Foundation[EP1.3.1] [Executable] Q1 & Q2 2022 Meta-Governance WG Budget[EP1.3.2] [Executable] Q1 & Q2 2022 ENS Ecosystem WG Budget[EP1.3.3] [Executable] Q1 & Q2 2022 Community WG Budget[EP1.3.4] [Executable] Q1 & Q2 2022 Public Goods WG Budget[EP1.4] [Executable] Reimburse True Names for expenses and tax obligations incurred for the DAO[EP1.5][Executable] Change to Exponential Premium Price Oracle[EP1.6] [Executable] A DAO-Governed Identity Server[EP1.7] [Executable] End the $ENS and EP2 airdrops[EP1.8] [Social] Working Group Rules[EP1.9] [Executable] Fund the Protocol Guild pilot with 200,000 $ENSTerm 2Term 3Powered By GitBook[EP1.4] [Executable] Reimburse True Names for expenses and tax obligations incurred for the DAOProposes to reimburse True Names Limited for expenses incurred on behalf of ENS and the DAO.StatusExecutedDiscussion Thread​Discourse​Votes​Snapshot, passed March 6th 2022 Onchain, passed March 30th 2022Note: This was previously numbered EP8.AbstractSince ENS started allowing registrations using the annual-fee model, revenue from this has accrued to the ENS root multisig, which is controlled by seven individuals drawn from the Ethereum community. In order to shield them from individual tax liability, True Names Limited, the development company responsible for ENS development, historically identified itself as the beneficial owner of these funds, which obliged True Names to pay tax on any income to the multisig.In past years True Names has covered this tax bill from its own reserves - primarily out of funds that were collected during the Short Name auction - but in 2021 revenue rose to a level that meant that was no longer sustainable. Accordingly, True Names requested funds from the multisig to cover the anticipated tax, and the multisig agreed.The calculation used to determine the tax owing used the actual income to October 20th, plus a 1/12th buffer to cover the anticipated income between the launch of the DAO and its potential request for control of the funds from the keyholders. This total came to $2,163,921 USDC.However, this failed to take into account the enormous uptick in interest that the announcement of the DAO produced, and so falls significantly short of True Names' actual tax obligations for FY 2021. This proposal requests that the DAO sends True Names the remainder of the funds required to cover the multisig's income during the period that True Names was the beneficial owner.Further, True Names has incurred the following expenses on behalf of the DAO in January 2022:Screenshot from 2022-01-28 09-27-45|617x500We additionally request the DAO reimburse True Names for these expenses in the total of $48,637.RevenueRevenue to the multisig came exclusively from ENS name registrations and renewals, and can be calculated from onchain data using this BigQuery query, producing the following results:MonthETHUSDJan 2021411.6875498484.22Feb 2021383.5613643985.05Mar 2021453.5619776834.28Apr 2021429.0654955345.36May 2021243.0624740165.91Jun 2021422.2419993899.95Jul 2021384.6863811202.23Aug 2021849.98902563121.38Sep 2021728.78252490699.18Oct 2021500.37531863125.83Nov 20211699.46607643673.03Total6506.479319980536.41TaxSingapore's company tax rate is 17%, meaning that the tax owing on $19,980,536 comes to $3,396,691. After deducting the $2,163,921 USDC already sent by the multisig, this leaves a shortfall of $1,232,770.SpecificationWe request that the DAO send $1,281,407 USDC to coldwallet.ens.eth.Previous[EP1.3.4] [Executable] Q1 & Q2 2022 Public Goods WG BudgetNext[EP1.5][Executable] Change to Exponential Premium Price OracleLast modified 6mo agoCopy linkEdit on GitHubOn this pageAbstractRevenueTaxSpecification "
101,mains v governance governance proposals term 3 ep3.1.1 social q1 q2 2023 funding request ens ecosystem working group,"mains v governance governance proposals term 3 ep3.1.1 social q1 q2 2023 funding request ens ecosystem working group.   [EP3.1.1] [Social] Q1/Q2 2023 Funding Request: ENS Ecosystem Working Group - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1Term 2Term 3[EP3.1.1] [Social] Q1/Q2 2023 Funding Request: ENS Ecosystem Working Group[EP3.1.2] [Social] Q1/Q2 2023 Funding Request: Meta-Governance Working Group[EP3.1.3] [Social] Q1/Q2 2023 Funding Request: Public Goods Working Group[EP3.2] [Executable] Q1/Q2 2023 Working Group Funding[EP3.3] [Executable] Sell ETH to USDC[EP3.4] [Executable] Fund the Endowment (first tranche)Powered By GitBook[EP3.1.1] [Social] Q1/Q2 2023 Funding Request: ENS Ecosystem Working GroupThis is a proposal to request funding for the ENS Ecosystem Working Group for Q1/Q2 2023.StatusPassedDiscussion Thread​Discuss​Votes​Snapshot​Author​Slobo.eth​AbstractThe ENS Ecosystem Working Group requests funding of 935,000 USDC and 254 ETH from the ENS DAO for Q1/Q2 2023.The ENS Ecosystem Working Group is responsible for growing and improving the ENS Ecosystem by funding people and projects that are ENS-specific or ENS-centric. In line with Article III of the ENS DAO Constitution, the requested funds will be used to support projects and builders contributing to the development and improvement of the ENS protocol and the ENS ecosystem.This social proposal is submitted to satisfy the requirements set out in Rule 10.1.1 of the Working Group Rules (EP 1.8). If this proposal is passed, the funding request will be included in a collective executable proposal put forward by all three Working Groups.SpecificationTextUSDCETH$ENSENS Ecosystem Multisig935,000254-DescriptionENS Ecosystem Multisig BalanceThe ENS Ecosystem Working Group is requesting 935,000 USDC, 254 ETH, and 0 $ENS.The ENS Ecosystem Working Group currently has 879,982 USDC, 110 ETH, and 40,936 $ENS in its multisigs.If this funding request is approved, the ENS Ecosystem Working Group multisigs will have a total of 1,814,982 USDC, 364 ETH, and 40,936 $ENS.TextUSDCETHENSCarried Forward (from Q3/Q4 2022)879,98211040,936Requested (for Q1/Q2 2023)935,0002540Total Balance1,814,98236440,936ENS Ecosystem Multisig Allocations for Q1/Q2 2023 (with funding request approved)The table below shows the total allocations for the ENS Ecosystem Working Group multisig, and related multisigs, with funds carried forward from last term (Q3/Q4 2022) along with funds requested in this proposal for this term (Q1/Q2 2023). USDCETH$ENSHackathons235,00020-Support178,000201,250Grants220,58030-Builders250,000392,000IRL84,256101,000Merch50,9675500ENS Fairy50,000174-ENS Fellowship60,000--Layer 2150,000--Normalization50,000--ETH.Limo85,00010-Bug Bounty**240,000--Discretionary161,1795636,186**Total Balance1,814,98236440,936** The USDC in the Bug Bounty and the $ENS held by the ENS Ecosystem Working Group multisig is available if needed and will likely be carried forward into future terms.Allocation of Requested FundsThe 935,000 USDC, 254 ETH, and 0 $ENS of funds requested in this proposal will be allocated to the following initiatives/outcomes. USDCETH$ENSHackathons230,00010-Support90,0005-Grants105,00030-Builders100,00015-IRL45,0005-Merch40,0005-ENS Fairy50,000174-ENS Fellowship60,000--Layer 2105,000--Normalization40,000--ETH.Limo70,00010-Total Requested Funds935,000254-Description of Initiatives/PodsInitiative/PodDescriptionMultisig Signer or Lead SingerHackathonsSponsorship costs and prize money for hackathons and conferencesluc.computerSupportSupport mods for social platforms, technical and non-technical educational and archival contentvalidator.ethGrantsSmall grants funding for ENS proposals on ensgrants.xyz + evergreen integration bountiesEcosystem stewardsBuildersSupport for builders shipping code that improves ENSEcosystem stewardsIRLFunding In Real Life events that coincide with the existing Ethereum event schedule + funding IRL community meetupslimes.ethMerchSubsidizing the cost of creating and shipping physical ENS merchandise including shirts, hats, and pinsEcosystem stewardsENS FairyFunds continued development of ensfairy.xyz + acquisition by validator.eth of names on temporary premium that can be utilized to grow ENS adoption + funding the ENS fairy registration bot to gift .eth names to IRL community members and buildersvalidator.ethENS FellowshipSupports exceptional developers actively creating and contributing to the ENS ecosystem with a 6 month FellowshipEcosystem stewardsLayer 2Development of ENS Layer 2 solutionsEcosystem stewardsDiscretionaryFunds in the Ecosystem Working Group multisig that are utilized at the discretion of stewardsEcosystem stewardsThis proposal was prepared by Slobo.eth, lead steward of the ENS Ecosystem Working Group.PreviousTerm 3Next[EP3.1.2] [Social] Q1/Q2 2023 Funding Request: Meta-Governance Working GroupLast modified 1mo agoCopy linkEdit on GitHubOn this pageAbstractSpecificationDescription "
102,mains ens improvement proposals ensip 2 initial hash registrar,"mains ens improvement proposals ensip 2 initial hash registrar.   ENSIP-2: Initial Hash Registrar - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsENSIP-1: ENSENSIP-2: Initial Hash RegistrarENSIP-3: Reverse ResolutionENSIP-4: Support for contract ABIsENSIP-5: Text RecordsENSIP-6: DNS-in-ENSENSIP-7: Contenthash fieldENSIP-8: Interface DiscoveryENSIP-9: Multichain Address ResolutionENSIP-10: Wildcard ResolutionENSIP-11: EVM compatible Chain Address ResolutionENSIP-12: Avatar Text RecordsENSIP-13: SAFE Authentication for ENSENSIP-14: On-chain Source ParameterDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookENSIP-2: Initial Hash RegistrarDescribes the hash registrar initially used to register ENS .eth domains (formerly EIP-162).AuthorMaurelian, Nick Johnson [email protected], Alex Van de Sande [email protected]​StatusObsoleteCreated2016-10-25AbstractThis ERC describes the implementation, as deployed to the main ethereum network on 2017-05-04, of a registrar contract to govern the allocation of names in the Ethereum Name Service (ENS). The corresponding source code is here.For more background, refer to ENSIP-1.Registrars are responsible for allocating domain names to users of the system, and are the only entities capable of updating the ENS; the owner of a node in the ENS registry is its registrar. Registrars may be contracts or externally owned accounts, though it is expected that the root and top-level registrars, at a minimum, will be implemented as contracts.- ENSIP-1A well designed and governed registrar is essential to the success of the ENS described in ENSIP-1, but is described separately in this document as it is external to the core ENS protocol.In order to maximize utility and adoption of a new namespace, the registrar should mitigate speculation and ""name squatting"", however the best approach for mitigation is unclear. Thus an ""initial"" registrar is proposed, which implements a simple approach to name allocation. During the initial period, the available namespace will be significantly restricted to the .eth top level domain, and subdomain shorter than 7 characters in length disallowed. This specification largely describes @alexvandesande and @arachnid's hash registrar implementation in order to facilitate discussion.The intent is to replace the Initial Registrar contract with a permanent registrar contract. The Permanent Registrar will increase the available namespace, and incorporate lessons learned from the performance of the Initial Registrar. This upgrade is expected to take place within approximately 2 years of initial deployment.MotivationsThe following factors should be considered in order to optimize for adoption of the ENS, and good governance of the Initial Registrar's namespace.Upgradability: The Initial Registrar should be safely upgradeable, so that knowledge gained during its deployment can be used to replace it with an improved and permanent registrar.Effective allocation: Newly released namespaces often create a land grab situation, resulting in many potentially valuable names being purchased but unused, with the hope of re-selling at a profit. This reduces the availability of the most useful names, in turn decreasing the utility of the name service to end users.Achieving an effective allocation may or may not require human intervention for dispute resolution and other forms of curation. The Initial Registrar should not aim to create to most effective possible allocation, but instead limit the cost of misallocation in the long term.Security: The registrar will hold a balance of ether without an explicit limit. It must be designed securely.Simplicity: The ENS specification itself emphasizes a separation of concerns, allowing the most essential element, the registry to be as simple as possible. The interim registrar in turn should be as simple as possible while still meeting its other design goals.Adoption: Successful standards become more successful due to network effects. The registrar should consider what strategies will encourage the adoption of the ENS in general, and the namespace it controls in particular.SpecificationInitial restrictionsThe Initial Registrar is expected to be in service for approximately two years, prior to upgrading. This should be sufficient time to learn, observe, and design an updated system.During the initial two year period, the available name space will be restricted to the .eth TLD.This restriction is enforced by the owner of the ENS root node who should not assign any nodes other than .eth to the Initial Registrar. The ENS's root node should be controlled by multiple parties using a multisig contract.The Initial Registrar will also prohibit registration of names 6 characters or less in length.Name format for hash registrationNames submitted to the initial registrar must be hashed using Ethereum's sha3 function. Note that the hashes submitted to the registrar are the hash of the subdomain label being registered, not the namehash as defined in ENSIP-1.For example, in order to register abcdefg.eth, one should submit sha3('abcdefg'), not sha3(sha3(0, 'eth'), 'abcdefg').Auctioning namesThe registrar will allocate the available names through a Vickrey auction:A Vickrey auction is a type of sealed-bid auction. Bidders submit written bids without knowing the bid of the other people in the auction. The highest bidder wins but the price paid is the second-highest bid. This type of auction... gives bidders an incentive to bid their true value.- Vickrey Auction, Wikipedia​The auction lifecycle of a name has 5 possible states, or Modes.1.Not-yet-available: The majority of names will be initially unavailable for auction, and will become available some time during the 8 weeks after launch.2.Open: The earliest availability for a name is determined by the most significant byte of its sha3 hash. 0x00 would become available immediately, 0xFF would become available after 8 weeks, and the availability of other names is distributed accordingly. Once a name is available, it is possible to start an auction on it.3.Auction: Once the auction for a name has begun, there is a 72 hour bidding period. Bidders must submit a payment of ether, along with sealed bids as a hash of sha3(bytes32 hash, address owner, uint value, bytes32 salt). The bidder may obfuscate the true bid value by sending a greater amount of ether.4.Reveal: After the bidding period, a 48 hour reveal period commences. During this time, bidders must reveal the true parameters of their sealed bid. As bids are revealed, ether payments are returned according to the schedule of ""refund ratios"" outlined in the table below. If no bids are revealed, the name will return to the Open state.5.Owned: After the reveal period has finished, the winning bidder must submit a transaction to finalize the auction, which then calls the ENS's setSubnodeOwner function, recording the winning bidder's address as the owner of the hash of the name.The following table outlines important parameters which define the Registrar's auction mechanism.Registrar ParametersNameDescriptionValuetotalAuctionLengthThe full time period from start of auction to end of the reveal period.5 daysrevealPeriodThe length of the time period during which bidding is no longer allowed, and bids must be revealed.48 hourslaunchLengthThe time period during which all names will become available for auction.8 weeksminPriceThe minimum amount of ether which must be locked up in exchange for ownership of a name.0.01 etherDeedsThe Initial Registrar contract does not hold a balance itself. All ether sent to the Registrar will be held in a separate Deed contracts. A deed contract is first created and funded when a sealed bid is submitted. After an auction is completed and a hash is registered, the deed for the winning bid is held in exchange for ownership of the hash. Non-winning bids are refunded.A deed for an owned name may be transferred to another account by its owner, thus transferring ownership and control of the name.After 1 year of registration, the owner of a hash may choose to relinquish ownership and have the value of the deed returned to them.Deeds for non-winning bids can be closed by various methods, at which time any ether held will either be returned to the bidder, burnt, or sent to someone else as a reward for actions which help the registrar.The following table outlines what portion of the balance held in a deed contract will be returned upon closure, and to whom. The remaining balance will be burnt.Refund scheduleReason for Deed closureRefund RecipientRefund PercentageA valid non-winning bid is revealed.Bidder99.5%A bid submitted after the auction period is revealed.Bidder99.5%An otherwise valid bid is revealed on an owned name. 1Bidder0.5%An expired sealed bid is cancelled. 2Canceler0.5%A registered hash is reported as invalid. 3Reporter50%A registered hash is reported as invalid. 3Owner50%Notes:1.This incentivizes all bids to be revealed in time. If bids could be revealed late, an extortion attack on the current highest bidder could be made by threatening to reveal a new second highest bid.2.A bid which remains sealed after more than 2 weeks and 5 days may be cancelled by anyone to collect a small reward.3.Since names are hashed before auctioning and registration, the Initial Registrar is unable to enforce character length restrictions independently. A reward is therefore provided for reporting invalid names.Deployment and Upgrade processThe Initial Registrar requires the ENS's address as a constructor, and should be deployed after the ENS. The multisig account owning the root node in the ENS should then set the Initial Registrar's address as owner of the eth node.The Initial Registrar is expected to be replaced by a Permanent Registrar approximately 2 years after deployment. The following process should be used for the upgrade:1.The Permanent Registrar contract will be deployed.2.The multisig account owning the root node in the ENS will assign ownership of the .eth node to the Permanent Registrar.3.Owners of hashes in the Initial Registrar will be responsible for registering their deeds to the Permanent Registrar. A couple options are considered here:1.Require owners to transfer their ownership prior to a cutoff date in order to maintain ownership and/or continue name resolution services.2.Have the Permanent Registrar query the Initial Registrar for ownership if it is lacking an entry.Planned deactivationIn order to limit dependence on the Initial Registrar, new auctions will stop after 4 years, and all ether held in deeds after 8 years will become unreachable.Registrar Interfacefunction state(bytes32 _hash) constant returns (Mode)Implements a state machine returning the current state of a namefunction entries(bytes32 _hash) constant returns (Mode, address, uint, uint, uint)Returns the following information regarding a registered name:statedeed addressregistration datebalance of the deedhighest value bid at auctionfunction getAllowedTime(bytes32 _hash) constant returns (uint timestamp)Returns the time at which the hash will no longer be in the initial not-yet-available state.function isAllowed(bytes32 _hash, uint _timestamp) constant returns (bool allowed)Takes a hash and a time, returns true if and only if it has passed the initial not-yet-available state.function startAuction(bytes32 _hash);Moves the state of a hash from Open to Auction. Throws if state is not Open.function startAuctions(bytes32[] _hashes);Starts multiple auctions on an array of hashes. This enables someone to open up an auction for a number of dummy hashes when they are only really interested in bidding for one. This will increase the cost for an attacker to simply bid blindly on all new auctions. Dummy auctions that are open but not bid on are closed after a week.function shaBid(bytes32 hash, address owner, uint value, bytes32 salt) constant returns (bytes32 sealedBid);Takes the parameters of a bid, and returns the sealedBid hash value required to participate in the bidding for an auction. This obfuscates the parameters in order to mimic the mechanics of placing a bid in an envelope.function newBid(bytes32 sealedBid);Bids are sent by sending a message to the main contract with a sealedBid hash and an amount of ether. The hash contains information about the bid, including the bidded name hash, the bid value, and a random salt. Bids are not tied to any one auction until they are revealed. The value of the bid itself can be masqueraded by sending more than the value of your actual bid. This is followed by a 48h reveal period. Bids revealed after this period will be burned and the ether unrecoverable. Since this is an auction, it is expected that most public hashes, like known domains and common dictionary words, will have multiple bidders pushing the price up.function startAuctionsAndBid(bytes32[] hashes, bytes32 sealedBid)A utility function allowing a call to startAuctions followed by newBid in a single transaction.function unsealBid(bytes32 _hash, address _owner, uint _value, bytes32 _salt);Once the bidding period is completed, there is a reveal period during with the properties of a bid are submitted to reveal them. The registrar hashes these properties using the shaBid() function above to verify that they match a pre-existing sealed bid. If the unsealedBid is the new best bid, the old best bid is returned to its bidder.function cancelBid(bytes32 seal);Cancels an unrevealed bid according to the rules described in the notes on the refund schedule above.function finalizeAuction(bytes32 _hash);After the registration date has passed, this function can be called to finalize the auction, which then calls the ENS function setSubnodeOwner() updating the ENS record to set the winning bidder as owner of the node.function transfer(bytes32 _hash, address newOwner);Update the owner of the ENS node corresponding to the submitted hash to a new owner. This function must be callable only by the current owner.function releaseDeed(bytes32 _hash);After some time, the owner can release the property and get their ether back.function invalidateName(string unhashedName);Since registration is done on the hash of a name, the registrar itself cannot validate names. This function can be used to report a name which is 6 characters long or less. If it has been registered, the submitter will earn 10% of the deed value. We are purposefully handicapping the simplified registrar as a way to force it into being restructured in a few years.function eraseNode(bytes32[] labels)Allows anyone to delete the owner and resolver records for a subdomain of a name that is not currently owned in the registrar. For instance, to zero foo.bar.eth on a registrar that owns .eth, pass an array containing [sha3('foo'), sha3('bar')].function transferRegistrars(bytes32 _hash) onlyOwner(_hash);Used during the upgrade process to a permanent registrar. If this registrar is no longer the owner of the root node in the ENS, this function will transfer the deed to the current owner, which should be a new registrar. This function throws if this registrar still owns its root node.RationaleStarting with a temporary registrarAnticipating and designing for all the potential issues of name allocation names is unlikely to succeed. This approach chooses not to be concerned with getting it perfect, but allows us to observe and learn with training wheels on, and implement improvements before expanding the available namespace to shorter names or another TLD.Valid names >= 7 charactersPreserving the shortest, and often most valuable, domain names for the upgraded registrar provides the opportunity to implement processes for dispute resolution (assuming they are found to be necessary).Delayed release of namesA slower release allows for extra time to identify, and address any issues which may arise after launch.Restricting TLD to .ethChoosing a single TLD helps to maximize network effects by focusing on one namespace.A three letter TLD is a pattern made familiar by it's common usage in internet domain names. This familiarity significantly increases the potential of the ENS to be integrated into pre-existing DNS systems, and reserved as a special-use domain name. A recent precedent for this is the reservation of the .onion domain.Holding ether as collateralThis approach is simpler than the familiar model of requiring owners to make recurring payments to retain ownership of a domain name. It also makes the initial registrar a revenue neutral service.Prior workThis document borrows heavily from several sources:ENSIP-1 outlines the initial implementation of the Registry Contract (ENS.sol) and associated Resolver contracts.​ERC-26 was the first ERC to propose a name service at the contract layer@alexvandesande's current implementation of the HashRegistrar​Edits:2016-10-26 Added link Alex's design in abstract2016-11-01 change 'Planned deactivation' to h3'2017-03-13 Update timelines for bidding and reveal periodsCopyrightCopyright and related rights waived via CC0.PreviousENSIP-1: ENSNextENSIP-3: Reverse ResolutionLast modified 1yr agoCopy linkEdit on GitHubOn this pageAbstractMotivationsSpecificationRationalePrior workCopyright "
103,mains deploying ens on a private chain#deploy a resolver,"mains deploying ens on a private chain#deploy a resolver.   Deploying ENS on a Private Chain - ENS Documentation    ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookDeploying ENS on a Private ChainIf you’d like to deploy ENS on your own network, or deploy your own copy of ENS on a public network, this guide shows you how. If you want to use an existing ENS deployment, see Resolving Names, Managing Names, and Registering & Renewing Names instead.On this page we will use Javascript, Web3, and Hardhat with npm for simplicity. You will find a complete migration file example at the bottom of this page.Please be aware that existing frameworks such as waffle and embark have support for local ENS deployment as well.Importing contractsThe essential smart contracts are published as npm modules. You can install them in your npm project with npm install @ensdomains/ens-contracts. Now, you can require them in a migration script as follows (see the Truffle Documentation on working with contract artifacts and npm for details)import { ENS, ENSRegistry, PublicResolver} from '@ensdomains/ens-contracts'Including them within your smart contract is as followsimport '@ensdomains/ens-contracts/contracts/registry/ENS.sol'ENS contains only an interface while ENSRegistry includes the actual implementation.Deploy the RegistryThe registry is ENS’s central component and stores, among other things, who owns which domain. This is the example using ethers and hardhat.const ENSRegistry = await ethers.getContractFactory(""ENSRegistry"")await ENSRegistry.deploy()Once deployed, you will have a fresh ENS registry, whose root node is owned by the account that submitted the transaction. This account has total control over the ENS registry - it can create and replace any node in the entire tree.From here, it's possible to create and manage names by directly interacting with the registry, as described in Managing Names. However, you will probably want to deploy a resolver, and you may want to deploy a registrar so other users can register names.Deploy a ResolverRecords in the registry can point to resolver contracts which store additional domain information. The most common use-case is to store an address for a domain, but storing a contract ABI or text is also possible. For most purposes on private networks it's convenient to have an unrestricted general-purpose resolver available. Deploying one is straightforward:const ZERO_ADDRESS = ""0x0000000000000000000000000000000000000000"";const ENSRegistry = await ethers.getContractFactory(""ENSRegistry"")const registry = await ENSRegistry.deploy()await registry.deployed()const PublicResolver = await ethers.getContractFactory(""PublicResolver"")const resolver = await PublicResolver.deploy(registry.address, ZERO_ADDRESS);await resolver.deployed()The PublicResolver looks up ownership in the registry, which is why the registry's address is required at deployment.For ease of use, we can give this resolver a name:const ethers = require('ethers');const utils = ethers.utils;const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label))const namehash = require('eth-ens-namehash');​async function setupResolver(ens, resolver, accounts) { const resolverNode = namehash.hash(""resolver""); const resolverLabel = labelhash(""resolver"");​ await ens.setSubnodeOwner(""0x0000000000000000000000000000000000000000"", resolverLabel, accounts[0]); await ens.setResolver(resolverNode, resolver.address); await resolver.setAddr(resolverNode, resolver.address);}Above, we first create a new top-level domain, ""resolver"", then set its resolver address to our newly deployed public resolver. Finally, we set up an address record for ""resolver"", pointing back to the resolver address. In effect, the resolver is answering queries about its own address. After this, anyone can find the public resolver at the special ENS name ""resolver"". We call this function after deploying the public resolver in a .then() block as we did with the resolver.Deploy a RegistrarSo far, domains can only be registered manually by the owner of the registry's root node. Fortunately, contracts can also own nodes. This means we can set up a registrar contract as the owner of a node, e.g. ""test"", in the registry which enables it to distribute subdomains such as ""mycontract.test"". It allows us to have custom, on-chain logic which governs domain allocation. Once we own a (sub-)node we are free to repeat this process and set up another registrar. If you are part of the ""myorg"" organisation you could register ""myorg.test"" and let it point to your custom registrar which only allows certified members of your organisation to claim subdomains such as ""bob.myorg.test"". For our private network, we'll use the simple 'first come, first served' FIFSRegistrar, and set it as the owner of the top-level domain ""test"" in our migration script:... const registrar = await FIFSRegistrar.deploy(ens.address, namehash.hash(""test"")); await registrar.deployed(); await ens.setSubnodeOwner(""0x0000000000000000000000000000000000000000"", sha3(""test""), registrar.address);})...Deploy the Reverse RegistrarSimilarly, if you wish to enable reverse resolution on your deployment, you will need to deploy the reverse registrar:...const reverseRegistrar = await ReverseRegistrar.deploy(ens.address, resolver.address);await reverseRegistrar.deployed();setupReverseRegistrar(ens, resolver, reverseRegistrar, accounts);...​async function setupReverseRegistrar(ens, resolver, reverseRegistrar, accounts) { await ens.setSubnodeOwner(""0x0000000000000000000000000000000000000000"", utils.sha3(""reverse""), accounts[0]); await ens.setSubnodeOwner(namehash.hash(""reverse""), utils.sha3(""addr""), reverseRegistrar.address);}Migration File ExampleWe can combine the steps above in a single hardhat migration file. This allows us to deploy ENS in one go:contracts/deps.sol//SPDX-License-Identifier: MIT// These imports are here to force Hardhat to compile contracts we depend on in our tests but don't need anywhere else.import ""@ensdomains/ens-contracts/contracts/registry/ENSRegistry.sol"";import ""@ensdomains/ens-contracts/contracts/registry/FIFSRegistrar.sol"";import ""@ensdomains/ens-contracts/contracts/resolvers/PublicResolver.sol"";script/deploy.jsconst hre = require(""hardhat"");const namehash = require('eth-ens-namehash');const tld = ""test"";const ethers = hre.ethers;const utils = ethers.utils;const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label))const ZERO_ADDRESS = ""0x0000000000000000000000000000000000000000"";const ZERO_HASH = ""0x0000000000000000000000000000000000000000000000000000000000000000"";async function main() { const ENSRegistry = await ethers.getContractFactory(""ENSRegistry"") const FIFSRegistrar = await ethers.getContractFactory(""FIFSRegistrar"") const ReverseRegistrar = await ethers.getContractFactory(""ReverseRegistrar"") const PublicResolver = await ethers.getContractFactory(""PublicResolver"") const signers = await ethers.getSigners(); const accounts = signers.map(s => s.address)​ const ens = await ENSRegistry.deploy() await ens.deployed() const resolver = await PublicResolver.deploy(ens.address, ZERO_ADDRESS); await resolver.deployed() await setupResolver(ens, resolver, accounts) const registrar = await FIFSRegistrar.deploy(ens.address, namehash.hash(tld)); await registrar.deployed() await setupRegistrar(ens, registrar); const reverseRegistrar = await ReverseRegistrar.deploy(ens.address, resolver.address); await reverseRegistrar.deployed() await setupReverseRegistrar(ens, registrar, reverseRegistrar, accounts);};​async function setupResolver(ens, resolver, accounts) { const resolverNode = namehash.hash(""resolver""); const resolverLabel = labelhash(""resolver""); await ens.setSubnodeOwner(ZERO_HASH, resolverLabel, accounts[0]); await ens.setResolver(resolverNode, resolver.address); await resolver['setAddr(bytes32,address)'](resolverNode, resolver.address);}​async function setupRegistrar(ens, registrar) { await ens.setSubnodeOwner(ZERO_HASH, labelhash(tld), registrar.address);}​async function setupReverseRegistrar(ens, registrar, reverseRegistrar, accounts) { await ens.setSubnodeOwner(ZERO_HASH, labelhash(""reverse""), accounts[0]); await ens.setSubnodeOwner(namehash.hash(""reverse""), labelhash(""addr""), reverseRegistrar.address);}​// We recommend this pattern to be able to use async/await everywhere// and properly handle errors.main() .then(() => process.exit(0)) .catch((error) => { console.error(error); process.exit(1); });To execute the migration file on hardhat, run the following command line.npx hardhat run scripts/deploy.jsDeploying ENS in a single transactionAlternately you may wish to deploy a test registrar and its dependencies with a single transaction. This is useful for example in unit tests where you wish to start from a clean slate in each test. In many cases it will also be faster than sending a series of separate transactions.This can be done by deploying a new contract that creates and sets up all the other contracts in its constructor. The below code creates all the ENS contracts and assigns the eth TLD to the FIFS Registrar so that any eth domain may be registered in the unit tests.pragma solidity >=0.8.4;import {INameWrapper, PublicResolver} from '@ensdomains/ens-contracts/contracts/resolvers/PublicResolver.sol';import '@ensdomains/ens-contracts/contracts/registry/ENSRegistry.sol';import '@ensdomains/ens-contracts/contracts/registry/FIFSRegistrar.sol';import {NameResolver, ReverseRegistrar} from '@ensdomains/ens-contracts/contracts/registry/ReverseRegistrar.sol';​// Construct a set of test ENS contracts.contract ENSDeployer { bytes32 public constant TLD_LABEL = keccak256('eth'); bytes32 public constant RESOLVER_LABEL = keccak256('resolver'); bytes32 public constant REVERSE_REGISTRAR_LABEL = keccak256('reverse'); bytes32 public constant ADDR_LABEL = keccak256('addr');​ ENSRegistry public ens; FIFSRegistrar public fifsRegistrar; ReverseRegistrar public reverseRegistrar; PublicResolver public publicResolver;​ function namehash(bytes32 node, bytes32 label) public pure returns (bytes32) { return keccak256(abi.encodePacked(node, label)); }​ constructor() public { ens = new ENSRegistry(); publicResolver = new PublicResolver(ens, INameWrapper(address(0)));​ // Set up the resolver bytes32 resolverNode = namehash(bytes32(0), RESOLVER_LABEL);​ ens.setSubnodeOwner(bytes32(0), RESOLVER_LABEL, address(this)); ens.setResolver(resolverNode, address(publicResolver)); publicResolver.setAddr(resolverNode, address(publicResolver));​ // Create a FIFS registrar for the TLD fifsRegistrar = new FIFSRegistrar(ens, namehash(bytes32(0), TLD_LABEL));​ ens.setSubnodeOwner(bytes32(0), TLD_LABEL, address(fifsRegistrar));​ // Construct a new reverse registrar and point it at the public resolver reverseRegistrar = new ReverseRegistrar(  ens,  NameResolver(address(publicResolver)) );​ // Set up the reverse registrar ens.setSubnodeOwner(bytes32(0), REVERSE_REGISTRAR_LABEL, address(this)); ens.setSubnodeOwner(  namehash(bytes32(0), REVERSE_REGISTRAR_LABEL),  ADDR_LABEL,  address(reverseRegistrar) ); }}PreviousRegistrar Frequently Asked QuestionsNextDNS Registrar guideLast modified 1yr agoCopy linkEdit on GitHubOn this pageImporting contractsDeploy the RegistryDeploy a ResolverDeploy a RegistrarDeploy the Reverse RegistrarMigration File Examplecontracts/deps.solscript/deploy.jsDeploying ENS in a single transaction "
104,mains deploying ens on a private chain#migration file example,"mains deploying ens on a private chain#migration file example.   Deploying ENS on a Private Chain - ENS Documentation    ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookDeploying ENS on a Private ChainIf you’d like to deploy ENS on your own network, or deploy your own copy of ENS on a public network, this guide shows you how. If you want to use an existing ENS deployment, see Resolving Names, Managing Names, and Registering & Renewing Names instead.On this page we will use Javascript, Web3, and Hardhat with npm for simplicity. You will find a complete migration file example at the bottom of this page.Please be aware that existing frameworks such as waffle and embark have support for local ENS deployment as well.Importing contractsThe essential smart contracts are published as npm modules. You can install them in your npm project with npm install @ensdomains/ens-contracts. Now, you can require them in a migration script as follows (see the Truffle Documentation on working with contract artifacts and npm for details)import { ENS, ENSRegistry, PublicResolver} from '@ensdomains/ens-contracts'Including them within your smart contract is as followsimport '@ensdomains/ens-contracts/contracts/registry/ENS.sol'ENS contains only an interface while ENSRegistry includes the actual implementation.Deploy the RegistryThe registry is ENS’s central component and stores, among other things, who owns which domain. This is the example using ethers and hardhat.const ENSRegistry = await ethers.getContractFactory(""ENSRegistry"")await ENSRegistry.deploy()Once deployed, you will have a fresh ENS registry, whose root node is owned by the account that submitted the transaction. This account has total control over the ENS registry - it can create and replace any node in the entire tree.From here, it's possible to create and manage names by directly interacting with the registry, as described in Managing Names. However, you will probably want to deploy a resolver, and you may want to deploy a registrar so other users can register names.Deploy a ResolverRecords in the registry can point to resolver contracts which store additional domain information. The most common use-case is to store an address for a domain, but storing a contract ABI or text is also possible. For most purposes on private networks it's convenient to have an unrestricted general-purpose resolver available. Deploying one is straightforward:const ZERO_ADDRESS = ""0x0000000000000000000000000000000000000000"";const ENSRegistry = await ethers.getContractFactory(""ENSRegistry"")const registry = await ENSRegistry.deploy()await registry.deployed()const PublicResolver = await ethers.getContractFactory(""PublicResolver"")const resolver = await PublicResolver.deploy(registry.address, ZERO_ADDRESS);await resolver.deployed()The PublicResolver looks up ownership in the registry, which is why the registry's address is required at deployment.For ease of use, we can give this resolver a name:const ethers = require('ethers');const utils = ethers.utils;const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label))const namehash = require('eth-ens-namehash');​async function setupResolver(ens, resolver, accounts) { const resolverNode = namehash.hash(""resolver""); const resolverLabel = labelhash(""resolver"");​ await ens.setSubnodeOwner(""0x0000000000000000000000000000000000000000"", resolverLabel, accounts[0]); await ens.setResolver(resolverNode, resolver.address); await resolver.setAddr(resolverNode, resolver.address);}Above, we first create a new top-level domain, ""resolver"", then set its resolver address to our newly deployed public resolver. Finally, we set up an address record for ""resolver"", pointing back to the resolver address. In effect, the resolver is answering queries about its own address. After this, anyone can find the public resolver at the special ENS name ""resolver"". We call this function after deploying the public resolver in a .then() block as we did with the resolver.Deploy a RegistrarSo far, domains can only be registered manually by the owner of the registry's root node. Fortunately, contracts can also own nodes. This means we can set up a registrar contract as the owner of a node, e.g. ""test"", in the registry which enables it to distribute subdomains such as ""mycontract.test"". It allows us to have custom, on-chain logic which governs domain allocation. Once we own a (sub-)node we are free to repeat this process and set up another registrar. If you are part of the ""myorg"" organisation you could register ""myorg.test"" and let it point to your custom registrar which only allows certified members of your organisation to claim subdomains such as ""bob.myorg.test"". For our private network, we'll use the simple 'first come, first served' FIFSRegistrar, and set it as the owner of the top-level domain ""test"" in our migration script:... const registrar = await FIFSRegistrar.deploy(ens.address, namehash.hash(""test"")); await registrar.deployed(); await ens.setSubnodeOwner(""0x0000000000000000000000000000000000000000"", sha3(""test""), registrar.address);})...Deploy the Reverse RegistrarSimilarly, if you wish to enable reverse resolution on your deployment, you will need to deploy the reverse registrar:...const reverseRegistrar = await ReverseRegistrar.deploy(ens.address, resolver.address);await reverseRegistrar.deployed();setupReverseRegistrar(ens, resolver, reverseRegistrar, accounts);...​async function setupReverseRegistrar(ens, resolver, reverseRegistrar, accounts) { await ens.setSubnodeOwner(""0x0000000000000000000000000000000000000000"", utils.sha3(""reverse""), accounts[0]); await ens.setSubnodeOwner(namehash.hash(""reverse""), utils.sha3(""addr""), reverseRegistrar.address);}Migration File ExampleWe can combine the steps above in a single hardhat migration file. This allows us to deploy ENS in one go:contracts/deps.sol//SPDX-License-Identifier: MIT// These imports are here to force Hardhat to compile contracts we depend on in our tests but don't need anywhere else.import ""@ensdomains/ens-contracts/contracts/registry/ENSRegistry.sol"";import ""@ensdomains/ens-contracts/contracts/registry/FIFSRegistrar.sol"";import ""@ensdomains/ens-contracts/contracts/resolvers/PublicResolver.sol"";script/deploy.jsconst hre = require(""hardhat"");const namehash = require('eth-ens-namehash');const tld = ""test"";const ethers = hre.ethers;const utils = ethers.utils;const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label))const ZERO_ADDRESS = ""0x0000000000000000000000000000000000000000"";const ZERO_HASH = ""0x0000000000000000000000000000000000000000000000000000000000000000"";async function main() { const ENSRegistry = await ethers.getContractFactory(""ENSRegistry"") const FIFSRegistrar = await ethers.getContractFactory(""FIFSRegistrar"") const ReverseRegistrar = await ethers.getContractFactory(""ReverseRegistrar"") const PublicResolver = await ethers.getContractFactory(""PublicResolver"") const signers = await ethers.getSigners(); const accounts = signers.map(s => s.address)​ const ens = await ENSRegistry.deploy() await ens.deployed() const resolver = await PublicResolver.deploy(ens.address, ZERO_ADDRESS); await resolver.deployed() await setupResolver(ens, resolver, accounts) const registrar = await FIFSRegistrar.deploy(ens.address, namehash.hash(tld)); await registrar.deployed() await setupRegistrar(ens, registrar); const reverseRegistrar = await ReverseRegistrar.deploy(ens.address, resolver.address); await reverseRegistrar.deployed() await setupReverseRegistrar(ens, registrar, reverseRegistrar, accounts);};​async function setupResolver(ens, resolver, accounts) { const resolverNode = namehash.hash(""resolver""); const resolverLabel = labelhash(""resolver""); await ens.setSubnodeOwner(ZERO_HASH, resolverLabel, accounts[0]); await ens.setResolver(resolverNode, resolver.address); await resolver['setAddr(bytes32,address)'](resolverNode, resolver.address);}​async function setupRegistrar(ens, registrar) { await ens.setSubnodeOwner(ZERO_HASH, labelhash(tld), registrar.address);}​async function setupReverseRegistrar(ens, registrar, reverseRegistrar, accounts) { await ens.setSubnodeOwner(ZERO_HASH, labelhash(""reverse""), accounts[0]); await ens.setSubnodeOwner(namehash.hash(""reverse""), labelhash(""addr""), reverseRegistrar.address);}​// We recommend this pattern to be able to use async/await everywhere// and properly handle errors.main() .then(() => process.exit(0)) .catch((error) => { console.error(error); process.exit(1); });To execute the migration file on hardhat, run the following command line.npx hardhat run scripts/deploy.jsDeploying ENS in a single transactionAlternately you may wish to deploy a test registrar and its dependencies with a single transaction. This is useful for example in unit tests where you wish to start from a clean slate in each test. In many cases it will also be faster than sending a series of separate transactions.This can be done by deploying a new contract that creates and sets up all the other contracts in its constructor. The below code creates all the ENS contracts and assigns the eth TLD to the FIFS Registrar so that any eth domain may be registered in the unit tests.pragma solidity >=0.8.4;import {INameWrapper, PublicResolver} from '@ensdomains/ens-contracts/contracts/resolvers/PublicResolver.sol';import '@ensdomains/ens-contracts/contracts/registry/ENSRegistry.sol';import '@ensdomains/ens-contracts/contracts/registry/FIFSRegistrar.sol';import {NameResolver, ReverseRegistrar} from '@ensdomains/ens-contracts/contracts/registry/ReverseRegistrar.sol';​// Construct a set of test ENS contracts.contract ENSDeployer { bytes32 public constant TLD_LABEL = keccak256('eth'); bytes32 public constant RESOLVER_LABEL = keccak256('resolver'); bytes32 public constant REVERSE_REGISTRAR_LABEL = keccak256('reverse'); bytes32 public constant ADDR_LABEL = keccak256('addr');​ ENSRegistry public ens; FIFSRegistrar public fifsRegistrar; ReverseRegistrar public reverseRegistrar; PublicResolver public publicResolver;​ function namehash(bytes32 node, bytes32 label) public pure returns (bytes32) { return keccak256(abi.encodePacked(node, label)); }​ constructor() public { ens = new ENSRegistry(); publicResolver = new PublicResolver(ens, INameWrapper(address(0)));​ // Set up the resolver bytes32 resolverNode = namehash(bytes32(0), RESOLVER_LABEL);​ ens.setSubnodeOwner(bytes32(0), RESOLVER_LABEL, address(this)); ens.setResolver(resolverNode, address(publicResolver)); publicResolver.setAddr(resolverNode, address(publicResolver));​ // Create a FIFS registrar for the TLD fifsRegistrar = new FIFSRegistrar(ens, namehash(bytes32(0), TLD_LABEL));​ ens.setSubnodeOwner(bytes32(0), TLD_LABEL, address(fifsRegistrar));​ // Construct a new reverse registrar and point it at the public resolver reverseRegistrar = new ReverseRegistrar(  ens,  NameResolver(address(publicResolver)) );​ // Set up the reverse registrar ens.setSubnodeOwner(bytes32(0), REVERSE_REGISTRAR_LABEL, address(this)); ens.setSubnodeOwner(  namehash(bytes32(0), REVERSE_REGISTRAR_LABEL),  ADDR_LABEL,  address(reverseRegistrar) ); }}PreviousRegistrar Frequently Asked QuestionsNextDNS Registrar guideLast modified 1yr agoCopy linkEdit on GitHubOn this pageImporting contractsDeploy the RegistryDeploy a ResolverDeploy a RegistrarDeploy the Reverse RegistrarMigration File Examplecontracts/deps.solscript/deploy.jsDeploying ENS in a single transaction "
105,mains v governance governance proposals term 1 ep6.2 social election of a new director of the ens foundation,"mains v governance governance proposals term 1 ep6.2 social election of a new director of the ens foundation.   [EP1.2.2] [Social] Election of a new Director of The ENS Foundation - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1[EP1.1] [Executable] Set the temporary premium start price to $100,000[EP1.2.1] [Social] Removal of Brantly Millegan as Director of the ENS Foundation[EP1.2.2] [Social] Election of a new Director of The ENS Foundation[EP1.3.1] [Executable] Q1 & Q2 2022 Meta-Governance WG Budget[EP1.3.2] [Executable] Q1 & Q2 2022 ENS Ecosystem WG Budget[EP1.3.3] [Executable] Q1 & Q2 2022 Community WG Budget[EP1.3.4] [Executable] Q1 & Q2 2022 Public Goods WG Budget[EP1.4] [Executable] Reimburse True Names for expenses and tax obligations incurred for the DAO[EP1.5][Executable] Change to Exponential Premium Price Oracle[EP1.6] [Executable] A DAO-Governed Identity Server[EP1.7] [Executable] End the $ENS and EP2 airdrops[EP1.8] [Social] Working Group Rules[EP1.9] [Executable] Fund the Protocol Guild pilot with 200,000 $ENSTerm 2Term 3Powered By GitBook[EP1.2.2] [Social] Election of a new Director of The ENS FoundationThis proposal is for the election of a new Director of the ENS Foundation.StatusFailedDiscussion Thread​Discourse​Votes​Snapshot, opened March 1st 2022Note: This was previously numbered EP6.2.AbstractThis social proposal puts forth a vote for the election of a new Director of the ENS foundation.This is a contingent proposal that will only be ratified if [EP6.1] [Social] Removal of Brantly Millegan as Director of The ENS Foundation determines that Brantly Millegan shall be removed from the directorship of the Foundation Company.Contingency: If majority ""No"" is voted on [EP6.1] [Social] Removal of Brantly Millegan as Director of The ENS Foundation, this proposal shall be null and void.MotivationBy a vote of the council, Brantly Millegan was removed as a director of the Foundation Company., the DAO shall decide whether Brantly Millegan is deemed capable, or otherwise, of continuing his role as the Director of the Ethereum Foundation, and to appoint a suitable replacement if he is deems incapable.A timeline of events that led to this proposal has been posted by Community WG Stewards in another post here and quoted below:In May 2016, Brantly Millegan tweeted that, “Homosexual acts are evil. Transgenderism doesn’t exist. Abortion is murder. Contraception is a perversion. So is masturbation and porn.”On February 5th, 2022, brantly.eth, well-known as a prominent representative of the ENS protocol, defended these views in a publicly held Twitter space.Irrespective of one’s personal beliefs, we, as ENS DAO Community Stewards, must set the example for inclusivity and must not divide our community.Propagating rhetoric that is viewed as hateful and discriminatory is not conduct conducive to the role as a Community Steward. This conduct will not be tolerated despite one’s contributions to the protocol.SpecificationThe appointment of the incoming Director will be held by a ranked choice Snapshot vote from a list of pre-determined nominees. Additionally, there shall be an option for voters to select ""None of the above"" or abstain from this vote.Draft Ranked Choice Snapshot VoteWho should be elected as the new Director of the ENS Foundation? Choice 1: avsa.eth Choice 2: daylon.eth Choice 3: healingvisions.eth Choice 4: None of the above. Choice 5: Abstain.Note: *This list was randomized by @berrios.eth.The nomination process for this appointment can be found here, and a summary of Director's roles, responsibilities, compensation and liabilities can be found here.Notice to The ENS FoundationIn line with this proposal, a formal notice is served to the ENS Foundation as follows:""Pursuant to Article 15 of the Articles of Association, the council, hereby, gives notice to the Foundation Company of the appointment of a director of the Foundation Company, to serve pursuant to the terms of its Articles.Whereas, the council undertook a vote, via Snapshot, to remove Brantly Millegan,Whereas, the majority of votes cast was to remove Brantly MIllegan and formal Notice given to the Foundation Company of such result,Whereas, the council undertook a second vote, via Snapshot, from among nominees of the council, to appoint a new director of the Foundation Company;Wherefore, the person, if any, with the highest number of votes cast is hereby appointed a director of the Foundation Company.The results to be formally noted in the council records and the name of such person, if there be one, shall be promptly communicated to the Foundation Company without further process.""You may view each candidates delegate application here and comments in on nominees for directorship here.Previous[EP1.2.1] [Social] Removal of Brantly Millegan as Director of the ENS FoundationNext[EP1.3.1] [Executable] Q1 & Q2 2022 Meta-Governance WG BudgetLast modified 6mo agoCopy linkEdit on GitHubOn this pageAbstractMotivationSpecificationNotice to The ENS Foundation "
106,mains v governance,"mains v governance.   Welcome to ENS DAO - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsPowered By GitBookWelcome to ENS DAOThe ENS DAO is a DAO that governs the ENS protocol. Here you will find important links and resources related to understanding and participating in the governance of ENS.Context for ENS​ENS homepage: Where you can register and manage ENS names. Twitter: The official ENS Twitter account Discord: Where the users can get support and the community can hang out. Newsletter: Where we catch up on what's been happening in the ENS community.$ENS Governance Token Airdrop​Airdrop Claim Site: Check your eligibility and claim your $ENS airdrop. Call for Delegates post: Announcement of the DAO and call for Delegates $ENS Token Allocation post: Breakdown of the $ENS token allocation $ENS Claiming post: Overview of the process to claim your $ENS Governance tokensContext for Governance​Discourse Forum: For discussion on governance proposals and working group discussions. Snapshot: For off-chain voting on proposals. Tally: View ENS DAO information on proposals, Delegates, and delegate your voting power. Sybil: For on-chain voting and viewing Delegates.Onboarding & Participation​Participation Request Form: To request access for write-access for restricted categories of the Discourse Forum and Governance channels within the Discord Server, please fill in this form.NextGovernance ProcessLast modified 1yr agoCopy linkEdit on GitHubOn this pageContext for ENS$ENS Governance Token AirdropContext for GovernanceOnboarding & Participation "
107,mains v governance the ens foundation,"mains v governance the ens foundation.   The ENS Foundation - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsPowered By GitBookThe ENS FoundationThe ENS DAO is represented in the real world by a Cayman Islands Foundation. This page describes why this is useful, how the foundation is structured, and what powers the DAO has over the Foundation.Why have a legal entity?Having a legal entity that represents the DAO in the ""real world"" is valuable for a number of reasons:It provides limited liability to DAO participants for the actions of the DAO. Without a legal entity, participants may be individually held liable for anything the DAO as a whole does.It is capable of complying with taxation requirements - without a legal entity, DAO participants may be held liable for a proportion of the DAO's income, even if they are not able to access these funds.It is capable of entering into contracts with other ""real world"" entities, of holding assets (including IP rights), and so forth.For a more detailed discussion of this topic, see this excellent blog post.What is The ENS Foundation?The ENS Foundation is a Foundation Company Limited By Guarantee, incorporated in the Cayman Islands. Foundation companies are nonprofits; The ENS Foundation has no shareholders and cannot pay out dividends to its directors or members. For more details on how foundations work, see this article.The ENS Foundation has three directors: Nick Johnson, Brantly Millegan, and Kevin Gaspar, all ENS core team members. Directors are in charge of the day-to-day running of the foundation.The ENS Foundation has one supervisor. The supervisor is an administrative role whose job is to make sure that the directors are doing their jobs in accordance with Cayman Islands law. The position of supervisor is filled by a Cayman Islands firm, DS Limited.The ENS Foundation's Articles of Incorporation give significant powers to the ENS DAO (referred to as ""The Council"" in the Articles). The DAO may vote to:Appoint or remove a director, member, or supervisor.Prohibit admitting any members in future.Instruct the directors to wind up the foundation, and specify what charity or other foundation should receive the foundation's assets.Though not specified directly in the Articles, the DAO may also instruct the directors to take action on behalf of the Foundation - such as signing a contract, engaging a company for a service the DAO requires, or delegating some of the directors' powers to a DAO working group.Foundation ExpensesRunning a Foundation is not free, and comes with some real-world costs. An incomplete list of anticipated expenses includes:Registered Office & Secretary Services: $10,000 USD p/aSupervisory Services: $30,000 USD p/aAgent for service of process: $1,200 USD p/aCompanies Register Fees: $850 USD p/aThe Directors may ask the DAO for reimbursement of these fees when they are incurred so that the Foundation can continue to operate.DocumentsFor transparency, important documents relating to the Foundation can be found below. Meeting minutes, resolutions, accounts, and other documentation will be uploaded here as it is made available to the directors.M&A - Incorp - The ENS Foundation - 26 October 2021.pdf1MBPDFCertificate of Incorporation - The ENS Foundation - 26 October 2021.pdf601KBPDFDir Res - Stage 2 - The ENS Foundation (27.10.21).pdf297KBPDFPreviousENS DAO ConstitutionNextGovernance ProposalsLast modified 1yr agoCopy linkEdit on GitHubOn this pageWhy have a legal entity?What is The ENS Foundation?Foundation ExpensesDocuments "
108,mains contract developer guide writing a resolver,"mains contract developer guide writing a resolver.   Writing a Resolver - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookWriting a ResolverResolvers are specified in EIP137. A resolver must implement the following method:function supportsInterface(bytes4 interfaceID) constant returns (bool);supportsInterface is defined in EIP165, and allows callers to determine if a resolver supports a particular record type. Record types are specified as a set of one or more methods that a resolver must implement together. Currently defined record types include:Record typeFunction(s)Interface IDDefined inEthereum addressaddr0x3b3b57de​EIP137​ENS Namename0x691f3431​EIP181​ABI specificationABI0x2203ab56​EIP205​Public keypubkey0xc8690233​EIP619​Text recordstext0x59d1d43c​EIP634​Content hashcontenthash0xbc1c58d1​supportsInterface must also return true for the interfaceID value 0x01ffc9a7, which is the interface ID of supportsInterface itself.Additionally, the content interface was used as a defacto standard for Swarm hashes, and has an interface ID of 0xd8389dc5. New implementations should use contenthash instead.Example ResolverA simple resolver that supports only the addr type might look something like this:contract SimpleResolver { function supportsInterface(bytes4 interfaceID) constant returns (bool) {  return interfaceID == 0x3b3b57de; }​ function addr(bytes32 nodeID) constant returns (address) {  return address(this); }}This trivial resolver always returns its own address as answer to all queries. Practical resolvers may use any mechanism they wish to determine what results to return, though they should be constant, and should minimise gas usage wherever possible.Contract Developer Guide - PreviousResolving Names On-chainNext - Contract Developer GuideWriting a RegistrarLast modified 1yr agoCopy linkEdit on GitHub "
109,mains contract api reference subgraphdata entities#nameregistered,"mains contract api reference subgraphdata entities#nameregistered.   Entities - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookEntitiesEntities​Domain​​DomainEvent​​Transfer​​NewOwner​​NewResolver​​NewTTL​​Account​​Registration​​RegistrationEvent​​NameRegistered​​NameRenewed​​NameTransferred​​Resolver​​ResolverEvent​​AddrChanged​​MulticoinAddrChanged​​NameChanged​​AbiChanged​​PubKeyChanged​​TextChanged​​ContentHashChanged​​InterfaceChanged​​AuthorisationChanged​DomainDescription:FieldTypeDescriptionidID!The namehash of the namenameStringThe human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)labelNameStringThe human readable label name (imported from CSV), if knownlabelhashByteskeccak256(labelName)parentDomainThe namehash (id) of the parent namesubdomains​Domain!​Can count domains from length of arraysubdomainCountInt!The number of subdomainsresolvedAddressaccountAddress logged from current resolver, if anyownerAccount!​resolverResolver​ttlBigInt​isMigratedBoolean!​createdAtBigInt!​events​DomainEvent!​​TransferDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​NewOwnerDescription:FieldTypeDescriptionidID!​parentDomainDomain!​domainDomain!​TransactionIDBytes!​ownerAccount!​NewResolverDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​resolverResolver!​NewTTLDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​transactionIDBytes!​ttlBigInt!​AccountDescription:FieldTypeDescriptionidID!​domain​Domain!​​registration​Registration!​​RegistrationDescription:FieldTypeDescriptionidID!​domainDomain​registrationDateBigInt!​expiryDateBigInt!​costBigInt!​registrantAccount!​labelNameString​events​RegistrationEven!​​RegistrationEventDescription:FieldTypeDescriptionidID!​registrationRegistrationEvent​blockNumberInt!​transactionIDBytes!​NameRegisteredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​registrantAccount!​expiryDateBigInt!​NameRenewedDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​expiryDateBigInt!​NameTransferredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​newOwnerAccount!​ResolverDescription:FieldTypeDescriptionidID!Concatenation of resolver address and namehashdomainDomain​addressBytes!Address of resolver contractaddrAccountCurrent value of addr record (per events)contenHashBytesContent hash, in binary formattexts[String!]Set of observed text record keyscointTypes[BigInt!]Set of observed SLIP-44 coin typesevents​ResolverEvent!​​ResolverEventDescription:FieldTypeDescriptionidID!Concatenation of block number and log IDresolverResolver!Used to derive relationships to ResolversblockNumberInt!​transactionIDBytes!​AddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​addrAccount!​MulticoinAddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​coinTypeBigInt!​addrBytes!​NameChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​nameString!​AbiChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​contentTypeBigInt!​PubkeyChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​xBytes!​yBytes!​TextChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​keyString!​valueString​ContenthashChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​hashBytes!​InterfaceChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​interfacedIDBytes!​implementerBytes!​AuthorisationChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​ownerBytes!​targetBytes!​isAuthorizedBoolean!​Contract API Reference - PreviousSubgraphNextQuery ExamplesLast modified 6mo agoCopy linkEdit on GitHubOn this pageEntitiesDomainTransferNewOwnerNewResolverNewTTLAccountRegistrationRegistrationEventNameRegisteredNameRenewedNameTransferredResolverResolverEventAddrChangedMulticoinAddrChangedNameChangedAbiChangedPubkeyChangedTextChangedContenthashChangedInterfaceChangedAuthorisationChanged "
110,mains contract api reference ens#set subdomain owner,"mains contract api reference ens#set subdomain owner.   Registry - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookRegistryThe ENS registry.​Source​The ENS registry is the core contract that lies at the heart of ENS resolution. All ENS lookups start by querying the registry. The registry maintains a list of domains, recording the owner, resolver, and TTL for each, and allows the owner of a domain to make changes to that data.The ENS registry is specified in EIP 137.Get Ownerfunction owner(bytes32 node) external view returns (address);Returns the owner of the name specified by node.Get Resolverfunction resolver(bytes32 node) external view returns (address);Returns the address of the resolver responsible for the name specified by node.Get TTLfunction ttl(bytes32 node) external view returns (uint64);Returns the caching time-to-live of the name specified by node. Systems that wish to cache information about a name, including ownership, resolver address, and records, should respect this value. If TTL is zero, new data should be fetched on each query.Set Ownerfunction setOwner(bytes32 node, address owner) external;Reassigns ownership of the name identified by node to owner. Only callable by the current owner of the name.Emits the following event:event Transfer(bytes32 indexed node, address owner);Set Resolverfunction setResolver(bytes32 node, address resolver) external;Updates the resolver associated with the name identified by node to resolver. Only callable by the current owner of the name. resolver must specify the address of a contract that implements the Resolver interface.Emits the following event:event NewResolver(bytes32 indexed node, address resolver);Set TTLfunction setTTL(bytes32 node, uint64 ttl) external;Updates the caching time-to-live of the name identified by node. Only callable by the current owner of the name.Emits the following event:event NewTTL(bytes32 indexed node, uint64 ttl);Set Subdomain Ownerfunction setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;Creates a new subdomain of node, assigning ownership of it to the specified owner. If the domain already exists, ownership is reassigned but the resolver and TTL are left unmodified.label is the keccak256 hash of the subdomain label to create. For example, if you own alice.eth and want to create the subdomain iam.alice.eth, supply namehash('alice.eth') as the node, and keccak256('iam') as the label.Emits the following event:event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);Set Recordfunction setRecord(bytes32 node, address owner, address resolver, uint64 ttl);Sets the owner, resolver, and TTL for an ENS record in a single operation. This function is offered for convenience, and is exactly equivalent to calling setResolver, setTTL and setOwner in that order.Set Subdomain Recordfunction setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl);Sets the owner, resolver and TTL for a subdomain, creating it if necessary. This function is offered for convenience, and permits setting all three fields without first transferring ownership of the subdomain to the caller.Set Approvalfunction setApprovalForAll(address operator, bool approved);Sets or clears an approval. Approved accounts can execute all ENS registry operations on behalf of the caller.Check Approvalfunction isApprovedForAll(address owner, address operator) external view returns (bool);Returns true if operator is approved to make ENS registry operations on behalf of owner.Check Record Existencefunction recordExists(bytes32 node) public view returns (bool);Returns true if node exists in this ENS registry. This will return false for records that are in the legacy ENS registry but have not yet been migrated to the new one.Contract API Reference - PreviousName ProcessingNext - Contract API ReferenceReverseRegistrarLast modified 1yr agoCopy linkEdit on GitHubOn this pageGet OwnerGet ResolverGet TTLSet OwnerSet ResolverSet TTLSet Subdomain OwnerSet RecordSet Subdomain RecordSet ApprovalCheck ApprovalCheck Record Existence "
111,mains contract developer guide writing a registrar,"mains contract developer guide writing a registrar.   Writing a Registrar - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookWriting a RegistrarA registrar in ENS is simply any contract that owns a name, and allocates subdomains of it according to some set of rules defined in the contract code. A trivial first in first served contract is demonstrated below:contract FIFSRegistrar { ENS ens; bytes32 rootNode;​ function FIFSRegistrar(address ensAddr, bytes32 node) {  ens = ENS(ensAddr);  rootNode = node; }​ function register(bytes32 subnode, address owner) {  var node = sha3(rootNode, subnode);  var currentOwner = ens.owner(node);​  if (currentOwner != 0 && currentOwner != msg.sender) throw;​  ens.setSubnodeOwner(rootNode, subnode, owner); }}You may wish to set custom rules for the allocation of new names to your users; the rules you set are entirely up to you.You should also bear in mind that as long as you retain ownership of the parent name - either directly or through another contract - your users have no guarantee that you will not take back ownership of their names and change what they resolve to. You may wish to consider committing ownership of the name to a contract that restricts your ability to control it. For an example of this, see ENSNow.Contract Developer Guide - PreviousWriting a ResolverNext - ENS Migration (February 2020)Guide for DApp DevelopersLast modified 1yr agoCopy linkEdit on GitHub "
112,mains ens deployments,"mains ens deployments.   ENS Deployments - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookENS DeploymentsIf you are working with an ENS library, your library will automatically find the ENS deployment you need. If for whatever reason, you need to interact with ENS directly, details for the currently supported deployments are detailed here.The ENS registry is deployed at 0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e. This same address is used across Mainnet and Goerli.On mainnet, the following registrars are deployed:.eth, using the .eth Permanent registrar..xyz, via DNS integration.luxe, via a custom integration that allows any owner of a .luxe DNS name to use ENS..kred, via a custom integration that synchs and changes to a .kred ENS token to DNS automatically..art, via a custom integrationTo find out the contract address of each tld, check the ""controller"" address of the tld (eg: https://app.ens.domains/name/xyz for .xyzRopsten test network has the .test registrar deployed. This registrar permits anyone to instantly register a domain for testing purposes; these domains persist for 28 days.In addition, the test networks also have a deployment of the .eth registrar for testing purposes.For other contract addresses such as root, multisig, controller, public resolver, and so on, you can see their address under https://app.ens.domains/name/ens.eth/subdomains​Back in February 2020, the ENS registry was migrated to the new contract address to patch security vulnerabilities (Read more detail here). The prior registry addresses were:Mainnet, at 0x314159265dd8dbb310642f98f50c066173c1259b.Goerli, at 0x112234455c3a32fd11230c42e7bccd4a84e02010.PreviousFrequently Asked QuestionsNextRegistrar Frequently Asked QuestionsLast modified 4mo agoCopy linkEdit on GitHub "
113,mains cdn cgi l email protection,"mains cdn cgi l email protection.   Email Protection | Cloudflare    Please enable cookies. Email Protection You are unable to access this email address docs.ens.domains  The website from which you got to this page is protected by Cloudflare. Email addresses on that page have been hidden in order to keep them from being accessed by malicious bots. You must enable Javascript in your browser in order to decode the e-mail address. If you have a website and are interested in protecting it in a similar way, you can sign up for Cloudflare.  How does Cloudflare protect email addresses on website from spammers? Can I sign up for Cloudflare?   Cloudflare Ray ID: 7a4541e2cefa7e77 •  Your IP:  Click to reveal 72.197.148.96 • Performance & security by Cloudflare   "
114,mains v governance governance proposals term 0 ep1 social proposal transfer ens treasury and contract ownership,"mains v governance governance proposals term 0 ep1 social proposal transfer ens treasury and contract ownership.   [EP0.1] [Social] Proposal: Transfer ENS Treasury and Contract Ownership - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0[EP0.1] [Social] Proposal: Transfer ENS Treasury and Contract Ownership[EP0.2] [Executable] Retrospective airdrop for accounts that owned another account’s primary ENS 1[EP0.3] [Social] Amend airdrop proposal to include accidentally returned funds[EP0.4] [Social] Proposal: Creation of Foundational Working Groups and Working Group RulesTerm 1Term 2Term 3Powered By GitBook[EP0.1] [Social] Proposal: Transfer ENS Treasury and Contract OwnershipTransfer ENS treasury and contract ownership from the ENS Multisig to ENS DAO.StatusPassedDiscussion Thread​Discuss​Votes​Snapshot passed on 2021-11-29Note: This was previously numbered EP1.AbstractWith the recent launch of the ENS DAO and $ENS token, it is now time for key governance powers of ENS to be transferred from the ENS root multisig to the ENS DAO.🔥_ 🔥(Fire Eyes DAO) has taken a central role in the planning and execution of ENS’s decentralization journey and is excited to present this first proposal to the community.This proposal will take a different form than normal as it proposes making a request to the ENS multisig root keyholders, rather than executing an action on the DAO.This proposal looks to execute a transfer of ownership of several aspects of the protocol which are currently controlled by the ENS root multisig:1.We propose that control over the existing ENS treasury is transferred to the DAO.2.We propose that ownership of the ENS Registrar Controller and the pricing oracle is transferred to the DAO. Ownership of the price oracle gives the DAO the ability to:1.Set the contract used to get the USD-ETH price.*2.Change the price per year of each length of domain name.Ownership of the registrar controller gives the DAO the ability to:1.Replace the price oracle contract.2.Withdraw accumulated funds to the DAO treasury.3.Set the minimum and maximum period between the first and second transactions of the registration process.3.We propose that ownership of the ENS Registrar is transferred to the DAO. Ownership of the .eth registrar gives the DAO the ability to:1.Add and remove controller contracts.2.Set the resolver contract for .eth4.We propose that ownership of the ‘.reverse’ namespace, which governs assignment of primary ENS records, be transferred to the DAO. Ownership of the .reverse TLD gives the DAO the ability to:1.Replace the reverse registrar for Ethereum addresses.2.Create new types of reverse resolution (For example, bitcoin addresses) and update them.Importantly, control over the ENS root will remain with the ENS root multisig for now. Control over the root allows for the creation and replacement of ENS top-level domains (TLDs) other than .eth (.eth is locked and cannot be changed by the root). This proposal also does not transfer ownership of the DNSSEC registrar contract, necessary for administering the DNSSEC integration used to allow owners of DNS domains to claim them on ENS.Powers over the ENS root are not being requested immediately, as they are both powers that can be abused to revoke or reassign non-.eth ENS names, and as such the risk to name owners is significantly higher than the other powers the DAO will exercise. Once the DAO has demonstrated its ability to successfully govern ENS, a future proposal will transfer these powers to the DAO.Snapshot voting on the above proposals will be conducted individually via approval voting; any proposal above that gets at least 50% approval and a quorum of 1% becomes the official policy of the DAO.SpecificationThe ENS DAO formally petitions the ENS root keyholders (being the owners of the multisig located at multisig.ens.eth) to execute a transaction or transactions taking the following actions:1.If proposal 1 passes, transfer all ETH and USDC held by multisig.ens.eth to the DAO’s timelock contract at wallet.ensdao.eth.2.If proposal 2 passes, call transferOwnership on the contracts at controller.ens.eth and 0xb9d374d0fe3d8341155663fae31b7beae0ae233a (the price oracle), passing in the address of wallet.ensdao.eth.3.If proposal 3 passes, call transferOwnership on the contract at registrar.ens.eth, passing in the address of wallet.ensdao.eth.4.If proposal 4 passes, call setSubnodeOwner on the root, passing in keccak256(‘reverse’) and the address of wallet.ensdao.eth.The ENS DAO agrees to use these funds and powers in accordance with the ENS Constitution.Conclusion & Next StepsThis proposal looks to set precedent as the first action taken by ENS delegates & token holders. Upon successful execution, the ENS DAO will hold control over two significant aspects of the protocol, and will be able to dispense funds effectively towards community initiatives.Discuss this proposal on the ENS forum and discord.Implement a vote on this proposal on Snapshot.If passed:Transfer existing assets from the ENS Community multisig to the ENS DAO.Transfer control over the Registrar Controller to the ENS DAO.Proposal Live: https://snapshot.org/#/ens.eth/proposal/0xfe73d1b06675d6bc1cc074f440c347274d13c55b513ea02ec950efe639adbbb0https://snapshot.org/#/ens.eth/proposal/0xfe73d1b06675d6bc1cc074f440c347274d13c55b513ea02ec950efe639adbbb0PreviousTerm 0Next[EP0.2] [Executable] Retrospective airdrop for accounts that owned another account’s primary ENS 1Last modified 6mo agoCopy linkEdit on GitHubOn this pageAbstractSpecificationConclusion & Next Steps "
115,mains v governance governance proposals term 0 ep2 executable retrospective airdrop for accounts that owned another accounts primary ens 1,"mains v governance governance proposals term 0 ep2 executable retrospective airdrop for accounts that owned another accounts primary ens 1.   [EP0.2] [Executable] Retrospective airdrop for accounts that owned another account’s primary ENS 1 - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0[EP0.1] [Social] Proposal: Transfer ENS Treasury and Contract Ownership[EP0.2] [Executable] Retrospective airdrop for accounts that owned another account’s primary ENS 1[EP0.3] [Social] Amend airdrop proposal to include accidentally returned funds[EP0.4] [Social] Proposal: Creation of Foundational Working Groups and Working Group RulesTerm 1Term 2Term 3Powered By GitBook[EP0.2] [Executable] Retrospective airdrop for accounts that owned another account’s primary ENS 1Send 213,049 ENS tokens to a new airdrop contract for users who did not receive the 2x multiplier despite owning a name that was used as a primary ENS name. As amended by EP3.StatusExecutedDiscussion Thread​Discuss​Votes​Snapshot passed on 2021-12-06 Onchain passed on 2022-01-12Note: This was previously numbered EP2.AbstractOne of the criteria used for the ENS airdrop was whether the account had a primary ENS name set. Those accounts that did got a 2x multiplier on their airdrop amount. The intention was to use this as a measure of involvement in the ENS ecosystem; those accounts that set primary ENS names are typically using their names in supported applications, while those that don't are less likely to be doing so.The way this was implemented was to award the multiplier to all accounts that had interacted with the reverse registrar. This had the unintended side effect that if a user owned an ENS name on account A, and configured it to resolve to account B, which used it as its primary name, account A would get tokens, and account B would get the multiplier. As B doesn't own any names, the multiplier has no effect and the end result is that some users got fewer tokens than they would have if they had used the same account for everything.This proposal aims to correct this, by introducing a new criteria for determining who to award the multiplier to, and creating a new airdrop contract for all accounts that qualify for the new criteria but not the old one.In plain english terms, the new criteria is that the account must have at some point in time owned a name that was used as the primary ENS name for an account.More formally, for each account a, the account is assigned the multiplier if there exists a name n and a time before 2021-11-01 00:00:00 UTC, where all of the following are true:1.a is the registrant of n.2.n has a resolver, r, set on the ENS registry.3.r has an addr record, a', set for n, and has emitted an AddrChanged event to record this fact.4.The reverse record for a' has a resolver, r', set on the ENS registry.5.r' has a name record, n', set for the reverse record of a. r' is either the default reverse resolver, or has emitted a NameChanged event for n' and a'.6.n == n'.This logic is implemented by this series of BigQuery queries, and shows that 1,969 accounts meet these criteria but did not qualify for the multiplier under the original criteria. The sum of the tokens these accounts would be entitled to comes to ~213,049 ENS tokens. A list of affected accounts and balances is here.Further, a number of users have accidentally transferred their ENS tokens to the token contract, totalling 6,246 contracts across 49 transfers. These tokens should be returned to their previous owners. This proposal, if executed, will transfer 219,295 ENS tokens to a new merkle airdrop contract allowing affected users to claim them.Specification1.Request that True Names Limited write and deploy a contract that allows claiming of tokens via Merkle Proofs using the same methodology as was used for the airdrop.2.Request that True Names Limited make changes to the claim.ens.domains site to support claiming this additional airdrop for qualifying accounts.3.Authorise the contract deployed in (1) to spend 219295650978169915391391 base ENS tokens from the ENS DAO account.Code​Previous[EP0.1] [Social] Proposal: Transfer ENS Treasury and Contract OwnershipNext[EP0.3] [Social] Amend airdrop proposal to include accidentally returned fundsLast modified 6mo agoCopy linkEdit on GitHubOn this pageAbstractSpecificationCode "
116,mains contract api reference subgraphdata queries,"mains contract api reference subgraphdata queries.   Query Examples - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookQuery Examplessidebar_position: 3 title: Sample Queries​QueryingBelow are some sample queries you can use to gather information from the ENS contracts.You can build your own queries using a GraphQL Explorer and enter your endpoint to limit the data to exactly what you need.Get the top domain for an account based on the longest registry.query getDomainForAccount { account(id: ""0xfee51ebbf276c1c3d91910a0b9a029e3ce731619"") { registrations(first: 1, orderBy: expiryDate, orderDirection: desc) { domain { name } } id }}Search for subdomainquery getSubDomains($Account: String = ""vitalik.eth"") { domains(where: { name: ""vitalik.eth"" }) { name id subdomains(first: 10) { name } subdomainCount }}Get an expiration for an ENS domain{ query getDomainExp($Account: String = ""vitalik.eth"") { registrations( where: {domain_: {name: $Account}} first: 1 orderBy: expiryDate orderDirection: desc ) { expiryDate }}PreviousEntitiesNext - Contract Developer GuideResolving Names On-chainLast modified 6mo agoCopy linkEdit on GitHubOn this pageQueryingGet the top domain for an account based on the longest registry.Search for subdomainGet an expiration for an ENS domain "
117,mains cdn cgi l email protection#2b4a5d584a6b4e5f434e594e5e460544594c,"mains cdn cgi l email protection#2b4a5d584a6b4e5f434e594e5e460544594c.   Email Protection | Cloudflare    Please enable cookies. Email Protection You are unable to access this email address docs.ens.domains  The website from which you got to this page is protected by Cloudflare. Email addresses on that page have been hidden in order to keep them from being accessed by malicious bots. You must enable Javascript in your browser in order to decode the e-mail address. If you have a website and are interested in protecting it in a similar way, you can sign up for Cloudflare.  How does Cloudflare protect email addresses on website from spammers? Can I sign up for Cloudflare?   Cloudflare Ray ID: 7a4541fe29712abf •  Your IP:  Click to reveal 72.197.148.96 • Performance & security by Cloudflare   "
118,mains permanent registrar faq,"mains permanent registrar faq.   Registrar Frequently Asked Questions - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookRegistrar Frequently Asked QuestionsAbout the ENS RegistrarHow many transactions are required to register a .eth name?The registrar uses two transactions (commit and reveal) to register a name.How long does it take to register a name using the .eth registrar?It takes less than 5 minutes to register a name, including a 1-minute delay between the first and second transactions to prevent frontrunning.Do we need to do anything to ensure the continued use of existing ENS names?Make sure you renew your ENS names before they expire! You add registration years to any name at any time, and for any duration you'd like.What happens if I have several ENS names with different renewal dates?You can add registration years to many names at a time on your My Account page in the ENS Manager App.How do renewals work?Anyone can add registration years to any existing name by paying the required fee, at any time.There is no maximum limitation of the renewal duration but there is a minimum renewal period of 28 days.Can someone grab my domains at the end of my subscription period?You can renew your name at any time during the period you own it. Making sure you renew before the name expires will prevent someone else from registering the name.There is also a 'grace period' of 90 days after your name expires. You can renew the name to retain ownership of it during the grace period.How much will the yearly renewals cost?Yearly renewals cost $5/year for names that are 5 characters or longer. 4 character names cost $160/year, and 3 character names cost $640/year. Fees are paid in ETH. The ETH/USD exchange rate is set by the Chainlink ETH/USD oracle.What happens to the renewal fees? Do I get them back?Rather than being locked and held, as in the original interim registrar, renewal fees in the permanent registrar are spent. You will not get them back.How will ENS team manage and spend the funds? Will there be a foundation or transparent oversight?Funds are sent to the ENS root multisig, for the keyholders to determine how funds get allocated. We're considering multiple options for the long-term use of the funds, such as funding the core ENS team, as well as other teams building on ENS. There are also tax considerations to address.How are funds from .eth registration income used?It's ultimately up to the keyholders to allocate the funds. We hope they will fund ENS ecosystems projects. If available funds exceed the reasonable needs of the ENS ecosystem, we hope other Ethereum projects will receive them.Where can I manage all my ENS names?Simply go to app.ens.domains and click on ""My Account"".Can I trade ENS domains on NFT exchanges?Yes, .eth names are tradeable as NFTs.How can I transfer domains registered in the .eth registry to someone else?You can do this using our Manager interface here, or using any tool with NFT support.What prohibits large scale domain grabbing besides registration fees?The cost of doing this is the only limitation in place.What is the ""registrant"" and ""controller"" of a name?The registrant is the account that owns the .eth name. They can transfer ownership to another account, and they can replace the controller address. The registrant is the owner of the NFT token that represents the name.The controller is the account that controls day-to-day operations with the name: creating subdomains, setting the resolver and records, and so forth.PreviousENS DeploymentsNextDeploying ENS on a Private ChainLast modified 1yr agoCopy linkEdit on GitHubOn this pageAbout the ENS RegistrarHow many transactions are required to register a .eth name?How long does it take to register a name using the .eth registrar?Do we need to do anything to ensure the continued use of existing ENS names?What happens if I have several ENS names with different renewal dates?How do renewals work?Can someone grab my domains at the end of my subscription period?How much will the yearly renewals cost?What happens to the renewal fees? Do I get them back?How will ENS team manage and spend the funds? Will there be a foundation or transparent oversight?How are funds from .eth registration income used?Where can I manage all my ENS names?Can I trade ENS domains on NFT exchanges?How can I transfer domains registered in the .eth registry to someone else?What prohibits large scale domain grabbing besides registration fees?What is the ""registrant"" and ""controller"" of a name? "
119,mains contract api reference .eth permanent registrar controller#calculate commitment hash,"mains contract api reference .eth permanent registrar controller#calculate commitment hash.   Controller - ENS Documentation    ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarRegistrarControllerDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookController​Source​This section documents the parts of the ETHRegistrarController relevant to implementers of tools that interact with it. Functionality exclusive to the registrar owner is omitted for brevity.The controller works exclusively with plaintext labels (eg, 'alice' for 'alice.eth').To prevent frontrunning, the ETHRegistrarController requires a commit/reveal process for new name registrations (but not for renewals). To register a name, the user must:1.Generate a commitment hash from the name they want to register and a secret value.2.Submit the commitment hash from #1 to the controller.3.Wait for at least 1 minute, but no longer than 24 hours.4.Submit a registration request for the name, along with the secret value from #1.This process ensures that registrations cannot be frontrun unless the attacker is able to censor the user's transactions for at least 1 minute.ExamplesName RegistrationThe below example demonstrates the steps required to register a name.web3.jsconst controller = web3.eth.contract(controller_abi).at(controller_address);async function register(name, owner, duration) { // Generate a random value to mask our commitment const random = new Uint8Array(32); crypto.getRandomValues(random); const salt = ""0x"" + Array.from(random).map(b => b.toString(16).padStart(2, ""0"")).join(""""); // Submit our commitment to the smart contract const commitment = await controller.makeCommitment(name, owner, salt); const tx = await controller.commit(commitment); // Add 10% to account for price fluctuation; the difference is refunded. const price = (await controller.rentPrice(name, duration)) * 1.1; // Wait 60 seconds before registering setTimeout(async () => { // Submit our registration request await controller.register(name, owner, duration, salt, {value: price}); }, 60000);}For clarity, this example is written using async rather than callbacks. As a result, this example works in web3 1.0.x; note that it will not work in the web3 injected by MetaMask, as this presently is an older version lacking async support.Read OperationsGet Minimum Commitment Ageuint constant public MIN_COMMITMENT_AGE;This public constant provides the minimum commitment age, in seconds. A commitment can only be revealed after at least this many seconds have passed since it was mined.DApps should fetch this constant rather than hardcoding the current value, as it's possible it will change with future releases.Get Maximum Commitment Ageuint constant public MAX_COMMITMENT_AGE;This public constant provides the maximum commitment age, in seconds. A commitment that was mined more than this number of seconds ago is no longer valid, and cannot be used to register a name.DApps should fetch this constant rather than hardcoding the current value, as it's possible it will change with future releases.Get Minimum Registration Durationuint constant public MIN_REGISTRATION_DURATION;This public constant provides the minimum registration duration, in seconds. Registrations for less than this duration will be rejected.DApps should fetch this constant rather than hardcoding the current value, as it's possible it will change with future releases.Get Commitment Timestampmapping(bytes32=>uint) public commitments;commitments stores a mapping from each submitted to commitment to the timestamp at which it was made. Callers wishing to validate that a commitment is valid before submitting a registration transaction should check this map first.Get Rent Pricefunction rentPrice(string name, uint duration) view public returns(uint);rentPrice returns the cost, in wei, to register or renew the provided name for the provided duration, in seconds. Callers should note that this price may vary over time, particularly if the pricing oracle is relying on a fiat price conversion.Callers should use this function to obtain registration costs to display to the user rather than calculating them internally, as future changes to the pricing oracle may result in different pricing schemes, with registration cost-per-year depending on name length, registration duration, or other variables.Check Name Validityfunction valid(string name) public view returns(bool);valid returns true iff name is valid for registration with this controller (eg, it meets length requirements).Check Name Availabilityfunction available(string name) public view returns(bool);available returns true iff the name is both valid and available for registration by this controller. Under the hood, this call uses the valid function (above) and the available function on the registrar contract, which checks for availability in both the legacy ENS registrar and current ENS registrar.Callers should use this function to check if a name is available for registration, rather than the available function on the registrar contract, which does not check name length.Calculate Commitment Hashfunction makeCommitment(string name, address owner, bytes32 secret) pure public returns(bytes32);makeCommitment generates and returns a commitment hash from a name label (eg, 'myname', not 'myname.eth') owner, and secret value.Write OperationsSubmit Commitmentfunction commit(bytes32 commitment) public;commit submits a precommitment generated by calling makeCommitment.Register Namefunction register(string name, address owner, uint duration, bytes32 secret) public payable;register registers a name. A valid registration request must meet the following criteria:1.available(name) == true.2.duration >= MIN_REGISTRATION_DURATION.3.secret identifies a valid commitment (eg, commitments[makeCommitment(name, secret)] exists and is between 1 minute and 24 hours old.4.msg.value >= rentPrice(name, duration).Because the rent price may vary over time, callers are recommended to send slightly more than the value returned by rentPrice - a premium of 5-10% will likely be sufficient. Any excess funds are returned to the caller.Emits the following event on a successful call:event NameRegistered(string name, bytes32 indexed label, address indexed owner, uint cost, uint expires);A successful call also results in the Registrar emitting a Name Registered Event, and the ENS registry emitting a New Owner Event.Extend Name Registrationfunction renew(string name, uint duration) external payable;renew renews a name, extending the name's expiration by duration seconds. This function can be called by anyone, as long as sufficient funds are provided. Because the rent price may vary over time, callers are recommended to send slightly more than the value returned by rentPrice - a premium of 5-10% will likely be sufficient. Any excess funds are returned to the caller.Emits the following event on a successful call:event NameRenewed(string name, bytes32 indexed label, uint cost, uint expires);A successful call also results in the Registrar emitting a Name Renewed Event.PreviousRegistrarNext - Contract API ReferenceDNS RegistrarLast modified 1yr agoCopy linkEdit on GitHubOn this pageExamplesName RegistrationRead OperationsGet Minimum Commitment AgeGet Maximum Commitment AgeGet Minimum Registration DurationGet Commitment TimestampGet Rent PriceCheck Name ValidityCheck Name AvailabilityCalculate Commitment HashWrite OperationsSubmit CommitmentRegister NameExtend Name Registration "
120,mains contract api reference publicresolver#set ethereum address,"mains contract api reference publicresolver#set ethereum address.   PublicResolver - ENS Documentation    ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookPublicResolverThe default public resolver.​Source​PublicResolver implements a general-purpose ENS resolver that is suitable for most standard ENS use-cases. The public resolver permits updates to ENS records by the owner of the corresponding name.The public resolver implements the following EIPs:​EIP 137 - Contract address interface (addr()).​EIP 165 - Interface Detection (supportsInterface()).​EIP 181 - Reverse resolution (name()).​EIP 205 - ABI support (ABI()).​EIP 619 - SECP256k1 public keys (pubkey()).​EIP 634 - Text records (text()).​EIP 1577 - Content hash support (contenthash()).​EIP 2304 - Multicoin support (addr()).While the PublicResolverprovides a convenient default implementation, many resolver implementations and versions exist. Callers must not assume that a domain uses the current version of the public resolver, or that all of the methods described here are present. To check if a resolver supports a feature, see Check Interface Support.Check Interface Supportfunction supportsInterface(bytes4 interfaceID) external pure returns (bool)ENS uses ERC 165 for interface detection. ERC 165 requires that supporting contracts implement a function, supportsInterface, which takes an interface ID and returns a boolean value indicating if this interface is supported or not.Interface IDs are calculated as the exclusive-or of the four-byte function identifiers of each function included in the interface. For example, addr(bytes32) has the function ID 0x3b3b57de. Because it is the only function in the Ethereum Address interface, its interface ID is also 0x3b3b57de, and so calling supportsInterface(0x3b3b57de) will return true for any resolver that supports addr().ERC 165 has an interface ID of 0x01ffc9a7, so supportsInterface(0x01ffc9a7) will always return true for any ERC 165 supporting contract (and hence for any resolver).Note that the public resolver does not expose explicit interfaces for setter functions, so there are no automated means to check for support for a given setter function.Get Ethereum Addressfunction addr(bytes32 node) external view returns (address)Returns the Ethereum address associated with the provided node, or 0 if none.This function has interface ID 0x3b3b57de.This function is specified in EIP 137.Set Ethereum Addressfunction setAddr(bytes32 node, address addr) external;Sets the Ethereum address associated with the provided node to addr.Only callable by the owner of node.Emits the following event:event AddrChanged(bytes32 indexed node, address a);Get Blockchain Addressfunction addr(bytes32 node, uint coinType) external view returns(bytes memory);Returns the Blockchain address associated with the provided node and coinType, or 0 if none.This function has interface ID 0xf1cb7e06.This function is specified in EIP 2304.The return value is the cryptocurrency address in its native binary format and each blockchain address has a different encoding and decoding method.For example, the Bitcoin address 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa base58check decodes to the 21 bytes 0062e907b15cbf27d5425399ebf6f0fb50ebb88f18 then scriptPubkey encodes to 25 bytes 76a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1888ac whereas the BNB address bnb1grpf0955h0ykzq3ar5nmum7y6gdfl6lxfn46h2 Bech32 decodes to the binary representation 40c2979694bbc961023d1d27be6fc4d21a9febe6.To convert the binary representation into the address, use formatsByCoinType[SYMBOL].encoder(binary) of address-encoder.A zero-length string will be returned if the specified coin ID does not exist on the specified node.Set Blockchain Addressfunction setAddr(bytes32 node, uint coinType, bytes calldata a) external;Sets the blockchain address associated with the provided node and coinType to addr.coinType is the cryptocurrency coin type index from SLIP44.To convert the address into the binary representation, use formatsByName[SYMBOL].decoder(text) of address-encoder​Only callable by the owner of node.Emits the following event:event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);Get Canonical Namefunction name(bytes32 node) external view returns (string memory);Returns the canonical ENS name associated with the provided node. Used exclusively for reverse resolution.This function has interface ID 0x691f3431.This function is specified in EIP 181.Set Canonical Namefunction setName(bytes32 node, string calldata name) external;Sets the canonical ENS name for the provided node to name.Only callable by the owner of node.Emits the following event:event NameChanged(bytes32 indexed node, string name);Get Content Hashfunction contenthash(bytes32 node) external view returns (bytes memory);Returns the content hash for node, if one exists. Values are formatted as machine-readable multicodecs, as specified in EIP 1577.contenthash is used to store IPFS and Swarm content hashes, which permit resolving ENS addresses to distributed content (eg, websites) hosted on these distributed networks.This function has interface ID 0xbc1c58d1.This function is specified in EIP 1577.Set Content Hashfunction setContenthash(bytes32 node, bytes calldata hash) external;Sets the content hash for the provided node to hash.Only callable by the owner of node.Values are formatted as machine-readable multicodecs, as specified in EIP 1577.Emits the following event:event ContenthashChanged(bytes32 indexed node, bytes hash);Get Contract ABIABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory);Returns a matching ABI definition for the provided node, if one exists. contentTypes is the bitwise-OR of the encodings that the caller can accept. If multiple content types are specified, the resolver will select one to return. Currently supported content types are:Content Type IDDescription1JSON2zlib-compressed JSON4​CBOR​8URIABI returns a two-tuple of the content type ID and the ABI data. If no data of the appropriate content type ID was found, 0 is returned for the content type ID, and the ABI data will be the empty string.This function has interface ID 0x2203ab56.This function is specified in EIP 205.Set Contract ABIfunction setABI(bytes32 node, uint256 contentType, bytes calldata data) externalSets or updates ABI data for node. contentType specifies the content type ID (see Get Contract ABI for valid values); exactly one type ID must be specified. data contains the encoded ABI data. To clear ABI data for a name, specify the empty string for data.Only callable by the owner of node.Emits the following event:event ABIChanged(bytes32 indexed node, uint256 indexed contentType);Get Public Keyfunction pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y)Returns the ECDSA SECP256k1 public key for node, as a 2-tuple (x, y). If no public key is set, (0, 0) is returned.This function has interface ID 0xc8690233.This function is specified in EIP 619.Set Public Keyfunction setPubkey(bytes32 node, bytes32 x, bytes32 y) externalSets the ECDSA SECP256k1 public key for node to (x, y).Only callable by the owner of node.Emits the following event:event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);Get Text Datafunction text(bytes32 node, string calldata key) external view returns (string memory)Retrieves text metadata for node. Each name may have multiple pieces of metadata, identified by a unique string key. If no text data exists for node with the key key, the empty string is returned.Standard values for key are:keyMeaningemailAn email addressurlA URLavatarA URL to an image used as an avatar or logodescriptionA description of the namenoticeA notice regarding this namekeywordsA list of comma-separated keywords, ordered by most significant first; clients that interpresent this field may choose a threshold beyond which to ignoreIn addition, anyone may specify vendor-specific keys, which must be prefixed with vnd.. The following vendor-specific keys are currently known:keyMeaningcom.twitterTwitter handlecom.githubGithub usernameThis function has interface ID 0x59d1d43c.This function is specified in EIP 634.Set Text Datafunction setText(bytes32 node, string calldata key, string calldata value) externalSets text metadata for node with the unique key key to value, overwriting anything previously stored for node and key. To clear a text field, set it to the empty string.Only callable by the owner of node.Emits the following event:event TextChanged(bytes32 indexed node, string indexedKey, string key);Multicallfunction multicall(bytes[] calldata data) external returns(bytes[] memory results)Permits users to set multiple records in a single operation.Use encodeABI function to encode your contract calls and pass it to data.The frontend usage will be as follows:var addrSet = resolver.contract.methods['setAddr(bytes32,address)'](node, accounts[1]).encodeABI();var textSet = resolver.contract.methods.setText(node, ""url"", ""https://ethereum.org/"").encodeABI();var tx = await resolver.multicall([addrSet, textSet], {from: accounts[0]});Contract API Reference - PreviousTestRegistrarNext - Contract API Reference.eth Permanent RegistrarLast modified 1yr agoCopy linkEdit on GitHubOn this pageCheck Interface SupportGet Ethereum AddressSet Ethereum AddressGet Blockchain AddressSet Blockchain AddressGet Canonical NameSet Canonical NameGet Content HashSet Content HashGet Contract ABISet Contract ABIGet Public KeySet Public KeyGet Text DataSet Text DataMulticall "
121,mains dapp developer guide managing names,"mains dapp developer guide managing names.   Managing Names - ENS Documentation    ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookManaging NamesTransferring a NameEach name in ENS has an owner. This account or contract is the only one that may make changes to the name in the ENS registry. The owner of a name can transfer ownership to any other account.ensjsgo-ensweb3.pyawait ens.name('alice.eth').setOwner('0x1234...');// opts are go-ethereum's bind.TransactOptserr := registry.SetOwner(opts, ""alice.eth"", common.HexToAddress(""0x1234...""))ns.setup_owner('alice.eth', '0x1234...')Creating SubdomainsThe owner of any domain can configure subdomains as desired. This is achieved by creating a subdomain and setting its owner to the desired address - this can be the same as the owner of the parent domain, or any other address.ensjsgo-ensweb3.pyawait ens.name('alice.eth').createSubdomain('iam');// opts are go-ethereum's bind.TransactOptserr := registry.SetSubdomainOwner(opts, ""alice.eth"", ""iam"", common.HexToAddress(""0x1234...""))ns.setup_owner('iam.alice.eth', '0x1234...')Additionally, web3.py provides a convenience method to create a subdomain, set a resolver, and configure an address record all at once:ns.setup_address('iam.alice.eth', '0x1234...')In the common case that the name should be pointed to the owner's address, the second argument is optional.Setting a ResolverBefore a newly created domain or subdomain can be used, a resolver address must be set. You may also want to do this if an updated resolver implementation is available that supports features that you want to make use of.Most commonly, names are set to use a 'standard' resolver called the public resolver, which provides commonly-used functionality, but anyone may write and deploy their own special-purpose resolver; see the resolver interface definition for details.ensjsgo-ensweb3.pyawait ens.name('iam.alice.eth').setResolver('0x1234');On mainnet and the Kovan test network, 'resolver.eth' is configured to point to the latest deployed version of the public resolver, making it possible to easily configure a name to use the public resolver:const resolver = await ens.resolver('resolver.eth').addr();await ens.setResolver('iam.alice.eth', resolver, {from: ...});// opts are go-ethereum's bind.TransactOptserr := registry.SetResolver(opts, ""iam.alice.eth"", common.HexToAddress(""0x1234...""))Not supported. web3.py automatically uses the public resolver when setup_address is called, and does not support setting custom resolvers.Note that changing the resolver for a name will not automatically migrate records from the old resolver over; to do this you will need to follow the process outlined below for updating records.Updating RecordsTo change the resources an address resolves to, it's necessary to update that name's records in its resolver.Each resolver may specify its own mechanism for updating records, but a standard method is implemented by the public resolver and many others. Some libraries provide functionality for updating a resolver's records using this interface.Updating the Address Recordensjsgo-ensweb3.jsweb3.pyawait ens.name('iam.alice.eth').setAddr('ETH', '0x1234...');resolver, err := ens.NewResolver(client, ""iam.alice.eth"")// opts are go-ethereum's bind.TransactOptserr := resolver.SetAddress(opts, common.HexToAddress(""0x1234...""))ens.setAddress('iam.alice.eth', '0x1234...', {from: ...});ns.setup_address('iam.alice.eth', '0x1234...')Updating Other RecordsSome libraries - presently only ensjs, go-ens and web3.js - support updating other record types, such as content hashes and text records, using the same pattern. For example, to set or update a text record:ensjsgo-ensweb3.jsens.name('iam.alice.eth').setText('test', 'Test record');// opts are go-ethereum's bind.TransactOptserr := resolver.SetContenthash(opts, []byte{0x12, 0x34...})err := resolver.SetAbi(opts, ""Sample"", `[{""constant"":true,""inputs"":...}]`, big.NewInt(1))err := resolver.SetText(opts, ""Sample"", `Hello, world`)ens.setText('iam.alice.eth', 'Test', 'Test record', {from: ...});Updating multiple records in one transactionPublic Resolver has multicall that permits users to set multiple records in a single operation. Read PublicResolver section for more detail.Configuring Reverse ResolutionWhile 'regular' resolution involves mapping from a name to an address, reverse resolution maps from an address back to a name - or other metadata. ENS supports reverse resolution to allow applications to display ENS names in place of hexadecimal addresses.Before this can be done, the owner of the address has to configure reverse resolution for their address. This is done by calling the claim() method on the reverse resolver, found at the special name 'addr.reverse'.Most commonly this is accomplished via a user-interface such as the ENS Manager DApp. go-ens and web3.py also provide functionality for this:go-ensweb3.pyreverseRegistrar, err := ens.NewReverseRegistrar(client)// opts are go-ethereum's bind.TransactOptserr := reverseRegistrar.SetName(opts, ""iam.alice.eth"")ns.setup_name('iam.alice.eth', '0x1234...')Dapp Developer Guide - PreviousResolving NamesNext - Dapp Developer GuideRegistering & Renewing NamesLast modified 6mo agoCopy linkEdit on GitHubOn this pageTransferring a NameCreating SubdomainsSetting a ResolverUpdating RecordsUpdating the Address RecordUpdating Other RecordsUpdating multiple records in one transactionConfiguring Reverse Resolution "
122,mains v governance governance proposals term 3 ep3.2 executable q1 q2 2023 working group funding,"mains v governance governance proposals term 3 ep3.2 executable q1 q2 2023 working group funding.   [EP3.2] [Executable] Q1/Q2 2023 Working Group Funding - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1Term 2Term 3[EP3.1.1] [Social] Q1/Q2 2023 Funding Request: ENS Ecosystem Working Group[EP3.1.2] [Social] Q1/Q2 2023 Funding Request: Meta-Governance Working Group[EP3.1.3] [Social] Q1/Q2 2023 Funding Request: Public Goods Working Group[EP3.2] [Executable] Q1/Q2 2023 Working Group Funding[EP3.3] [Executable] Sell ETH to USDC[EP3.4] [Executable] Fund the Endowment (first tranche)Powered By GitBook[EP3.2] [Executable] Q1/Q2 2023 Working Group FundingThis proposal executes funding for Working Groups for Q1/Q2 2023.StatusExecutedDiscussion Thread​Discuss​Votes​Tally​Authors​Slobo.eth, Katherine Wu, Coltron.eth​AbstractThis proposal executes all three Working Group funding requests for Q1/Q2 2023 as passed in EP 3.1.1, EP 3.1.2, and EP 3.1.3. For more detail, view the ENS Governance docs or view the links below.Motivation​EP 3.1.1 — ENS Ecosystem Working Group​The ENS Ecosystem Working Group requests funding of 935,000 USDC and 254 ETH from the ENS DAO for Q1/Q2 2023.The ENS Ecosystem Working Group is responsible for growing and improving the ENS Ecosystem by funding people and projects that are ENS-specific or ENS-centric. In line with Article III of the ENS DAO Constitution, the requested funds will be used to support projects and builders contributing to the development and improvement of the ENS protocol and the ENS ecosystem.​EP 3.1.2 — MetaGovernance Working Group​The Meta-Governance Working Group requests funding of 364,000 USDC, 125 ETH, and 3,500 $ENS from the ENS DAO for Q1/Q2 2023.This MetaGovernance Working Group will use this funding to support the governance processes of the ENS DAO as well as manage and build infrastructure to support the ENS DAO and Working Groups.​EP 3.1.3 — Public Goods Working Group​The Public Goods Working Group requests funding of 250,000 USDC and 50 ETH from the ENS DAO for Q1/Q2 2023.The Public Goods Working Group will be use this funding to support projects and builders as provisioned by Article III of the ENS DAO Constitution, which provides for the funding of public goods in web3.Specification1.Transfer 935,000 USDC and 254 ETH to ens-ecosystem.pod.xyz2.Transfer 364,000 USDC, 125 ETH, and 3,500 $ENS to ens-metagov.pod.xyz3.Transfer 250,000 USDC and 50 ETH to ens-publicgoods.pod.xyzAddresses:0x2686A8919Df194aA7673244549E68D42C1685d03 - ens-ecosystem.pod.xyz0x91c32893216dE3eA0a55ABb9851f581d4503d39b - ens-metagov.pod.xyz0xcD42b4c4D102cc22864e3A1341Bb0529c17fD87d - ens-publicgoods.pod.xyzTransactionsAddressValueFunctionArgumentValueens-ecosystem.pod.xyz254 ETH​​​ens-metagov.pod.xyz125 ETH​​​ens-publicgoods.pod.xyz50 ETH​​​0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48​transfertoens-ecosystem.pod.xyz​​​value9350000000000xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48​transfertoens-metagov.pod.xyz​​​value3640000000000xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48​transfertoens-publicgoods.pod.xyz​​​value2500000000000xc18360217d8f7ab5e7c516566761ea12ce7f9d72​transfertoens-metagov.pod.xyz​​​value3500000000000000000000Previous[EP3.1.3] [Social] Q1/Q2 2023 Funding Request: Public Goods Working GroupNext[EP3.3] [Executable] Sell ETH to USDCLast modified 26d agoCopy linkEdit on GitHubOn this pageAbstractMotivationSpecificationTransactions "
123,mains cdn cgi l email protection#cfabaaaea18faaa1bce1aba0a2aea6a1bc,"mains cdn cgi l email protection#cfabaaaea18faaa1bce1aba0a2aea6a1bc.   Email Protection | Cloudflare    Please enable cookies. Email Protection You are unable to access this email address docs.ens.domains  The website from which you got to this page is protected by Cloudflare. Email addresses on that page have been hidden in order to keep them from being accessed by malicious bots. You must enable Javascript in your browser in order to decode the e-mail address. If you have a website and are interested in protecting it in a similar way, you can sign up for Cloudflare.  How does Cloudflare protect email addresses on website from spammers? Can I sign up for Cloudflare?   Cloudflare Ray ID: 7a4542123c472ae7 •  Your IP:  Click to reveal 72.197.148.96 • Performance & security by Cloudflare   "
124,mains v governance governance proposals term 2 ep16.1 executable q3 and q4 2022 meta governance wg budget,mains v governance governance proposals term 2 ep16.1 executable q3 and q4 2022 meta governance wg budget.   [EP2.2.1] [Executable] Q3 & Q4 2022 Meta-Governance WG Budget - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1Term 2[EP2.1] [Executable] Funding True Names Ltd[EP2.2.1] [Executable] Q3 & Q4 2022 Meta-Governance WG Budget[EP2.2.2] [Executable] Q3 & Q4 2022 Ecosystem WG Budget[EP2.2.3] [Executable] Q3 & Q4 2022 Public Goods WG Budget[EP2.2.4] [Social] ENS Endaoment RFP[EP2.2.5] [Social] Selection of an ENS endowment fund managerTerm 3Powered By GitBook[EP2.2.1] [Executable] Q3 & Q4 2022 Meta-Governance WG BudgetStatusExecutedDiscussion Thread​Discourse​Votes​Snapshot - Passed​Onchain - ExecutedNote: This was previously numbered EP16.1.SummaryThe Meta-Governance Working Group is requesting funding of 632k USD equivalent for the Q3/Q4 of 2022. The budget has three categories. All figures are presented in USD equivalent.Multisigs / Subgroups: $371k USD ValueFunding in this category is related to the two Meta-Governance subgroup multi-sigs. These have been reviewed and approved by the Meta-Gov Stewards.BudgetDescriptionCompensation: $190k USD ValueFunding in this category relates to compensation for DAO stewards and secretary.BudgetDescriptionThe Working Group Rules passed in EP12 state compensation is permitted for stewards and secretary as set out in Rules 11.1 and 9.4 respectively.Unallocated: $71k USD ValueThe funds in this category are reserved for unforeseen grants and unexpected expenses for the term. Stewards will distribute unallocated funds on a discretionary basis.Previous[EP2.1] [Executable] Funding True Names LtdNext[EP2.2.2] [Executable] Q3 & Q4 2022 Ecosystem WG BudgetLast modified 6mo agoCopy linkEdit on GitHubOn this pageSummaryMultisigs / Subgroups: $371k USD ValueCompensation: $190k USD ValueUnallocated: $71k USD Value 
125,mains contract api reference subgraphdata entities#namechanged,"mains contract api reference subgraphdata entities#namechanged.   Entities - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookEntitiesEntities​Domain​​DomainEvent​​Transfer​​NewOwner​​NewResolver​​NewTTL​​Account​​Registration​​RegistrationEvent​​NameRegistered​​NameRenewed​​NameTransferred​​Resolver​​ResolverEvent​​AddrChanged​​MulticoinAddrChanged​​NameChanged​​AbiChanged​​PubKeyChanged​​TextChanged​​ContentHashChanged​​InterfaceChanged​​AuthorisationChanged​DomainDescription:FieldTypeDescriptionidID!The namehash of the namenameStringThe human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)labelNameStringThe human readable label name (imported from CSV), if knownlabelhashByteskeccak256(labelName)parentDomainThe namehash (id) of the parent namesubdomains​Domain!​Can count domains from length of arraysubdomainCountInt!The number of subdomainsresolvedAddressaccountAddress logged from current resolver, if anyownerAccount!​resolverResolver​ttlBigInt​isMigratedBoolean!​createdAtBigInt!​events​DomainEvent!​​TransferDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​NewOwnerDescription:FieldTypeDescriptionidID!​parentDomainDomain!​domainDomain!​TransactionIDBytes!​ownerAccount!​NewResolverDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​resolverResolver!​NewTTLDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​transactionIDBytes!​ttlBigInt!​AccountDescription:FieldTypeDescriptionidID!​domain​Domain!​​registration​Registration!​​RegistrationDescription:FieldTypeDescriptionidID!​domainDomain​registrationDateBigInt!​expiryDateBigInt!​costBigInt!​registrantAccount!​labelNameString​events​RegistrationEven!​​RegistrationEventDescription:FieldTypeDescriptionidID!​registrationRegistrationEvent​blockNumberInt!​transactionIDBytes!​NameRegisteredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​registrantAccount!​expiryDateBigInt!​NameRenewedDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​expiryDateBigInt!​NameTransferredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​newOwnerAccount!​ResolverDescription:FieldTypeDescriptionidID!Concatenation of resolver address and namehashdomainDomain​addressBytes!Address of resolver contractaddrAccountCurrent value of addr record (per events)contenHashBytesContent hash, in binary formattexts[String!]Set of observed text record keyscointTypes[BigInt!]Set of observed SLIP-44 coin typesevents​ResolverEvent!​​ResolverEventDescription:FieldTypeDescriptionidID!Concatenation of block number and log IDresolverResolver!Used to derive relationships to ResolversblockNumberInt!​transactionIDBytes!​AddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​addrAccount!​MulticoinAddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​coinTypeBigInt!​addrBytes!​NameChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​nameString!​AbiChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​contentTypeBigInt!​PubkeyChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​xBytes!​yBytes!​TextChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​keyString!​valueString​ContenthashChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​hashBytes!​InterfaceChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​interfacedIDBytes!​implementerBytes!​AuthorisationChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​ownerBytes!​targetBytes!​isAuthorizedBoolean!​Contract API Reference - PreviousSubgraphNextQuery ExamplesLast modified 6mo agoCopy linkEdit on GitHubOn this pageEntitiesDomainTransferNewOwnerNewResolverNewTTLAccountRegistrationRegistrationEventNameRegisteredNameRenewedNameTransferredResolverResolverEventAddrChangedMulticoinAddrChangedNameChangedAbiChangedPubkeyChangedTextChangedContenthashChangedInterfaceChangedAuthorisationChanged "
126,mains ens improvement proposals ensip 8 interface discovery,"mains ens improvement proposals ensip 8 interface discovery.   ENSIP-8: Interface Discovery - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsENSIP-1: ENSENSIP-2: Initial Hash RegistrarENSIP-3: Reverse ResolutionENSIP-4: Support for contract ABIsENSIP-5: Text RecordsENSIP-6: DNS-in-ENSENSIP-7: Contenthash fieldENSIP-8: Interface DiscoveryENSIP-9: Multichain Address ResolutionENSIP-10: Wildcard ResolutionENSIP-11: EVM compatible Chain Address ResolutionENSIP-12: Avatar Text RecordsENSIP-13: SAFE Authentication for ENSENSIP-14: On-chain Source ParameterDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookENSIP-8: Interface DiscoveryDefines a method of associating contract interfaces with ENS names and addresses, and of discovering those interfaces (formerly EIP-1844).AuthorNick Johnson <[email protected]>StatusFinalSubmitted2019-03-05AbstractThis ENSIP specifies a method for exposing interfaces associated with an ENS name or an address (typically a contract address) and allowing applications to discover those interfaces and interact with them. Interfaces can be implemented either by the target contract (if any) or by any other contract.MotivationEIP 165 supports interface discovery - determining if the contract at a given address supports a requested interface. However, in many cases it's useful to be able to discover functionality associated with a name or an address that is implemented by other contracts.For example, a token contract may not itself provide any kind of 'atomic swap' functionality, but there may be associated contracts that do. With ENS interface discovery, the token contract can expose this metadata, informing applications where they can find that functionality.SpecificationA new profile for ENS resolvers is defined, consisting of the following method:function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address);The EIP-165 interface ID of this interface is 0xb8f2bbb4.Given an ENS name hash node and an EIP-165 interfaceID, this function returns the address of an appropriate implementer of that interface. If there is no interface matching that interface ID for that node, 0 is returned.The address returned by interfaceImplementer MUST refer to a smart contract.The smart contract at the returned address SHOULD implement EIP-165.Resolvers implementing this interface MAY utilise a fallback strategy: If no matching interface was explicitly provided by the user, query the contract returned by addr(), returning its address if the requested interface is supported by that contract, and 0 otherwise. If they do this, they MUST ensure they return 0, rather than reverting, if the target contract reverts.This field may be used with both forward resolution and reverse resolution.RationaleA naive approach to this problem would involve adding this method directly to the target contract. However, doing this has several shortcomings:1.Each contract must maintain its own list of interface implementations.2.Modifying this list requires access controls, which the contract may not have previously required.3.Support for this must be designed in when the contract is written, and cannot be retrofitted afterwards.4.Only one canonical list of interfaces can be supported.Using ENS resolvers instead mitigates these shortcomings, making it possible for anyone to associate interfaces with a name, even for contracts not previously built with this in mind.Backwards CompatibilityThere are no backwards compatibility issues.ImplementationThe PublicResolver in the ensdomains/resolvers repository implements this interface.CopyrightCopyright and related rights waived via CC0.PreviousENSIP-7: Contenthash fieldNextENSIP-9: Multichain Address ResolutionLast modified 1yr agoCopy linkEdit on GitHubOn this pageAbstractMotivationSpecificationRationaleBackwards CompatibilityImplementationCopyright "
127,mains dapp developer guide ens data guide,"mains dapp developer guide ens data guide.   ENS Data guide - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookENS Data guideOverviewEven though adding basic functionalities such as a single name lookup is just adding a few lines of code, analysing overall stats or integrating with historical info can be challenging due to the following reasons.The data is stored in storage efficient way to save gas costs, which requires decodingSome of the contracts can be extensible by end users leading to inconsistent interfaceSome names (.eth, wrapped names) expire without emitting eventsSmart contract structures have changed over timeSome names are not available on the chain (eg: CCIP-read integrated names such as cb.id) In this section, I will go through the overall structure of ENS contracts and events to help you guide through the ENS data space. Target audienceThe target audience of this article is developers and data analysts who are interested in labelling ENS names into the Ethereum transaction data such as NFT owners, Defi users, and ENS name trading history. It assumes that you have a basic understanding of how Ethereum smart contracts work (such as function calls and events). Some tools also require query language knowledge such as GraphQL and SQL. How to access ENS data​Just like many other Ethereum-based projects, ENS consists of a set of smart contracts. You can use tools of your choice to interact directly with ENS smart contracts (which we will explain in depth). If you want extra data about a single name, please refer to the ENS library section which explains how to interact with ENS via popular libraries such as ethers.js.Extracting multiple entities tends to be slow and time-consuming because you have to make a function call to extract each record. Ens-js v3 has a batch call function to save some call time. If you are interested in extracting more than dozens of name records or want to access event-related information. There are currently two popular services, The Graph, Dune Analytics and Google Big Query.The Graph​Mainnet ​Goerli ​RInkeby The Graph is a decentralized indexing service that allows developers to turn smart contract events (and function calls) into GraphQL schema called subgraph. The ENS team maintains the subgraph that encapsulates multiple events data into a single entity such as Domain, Account, Registration and Resolver. The following sample query lists all namesaccount{ domains { labelName labelhash name }}It is suitable to extract information such as the list of subdomains a name created, a list of names the address registered, and text keys (eg: Twitter, email, avatar). You can also use it to extract analytics information such as registered names though you need to traverse the data multiple times. You can see the list of subgraphs used in the app.ens.domains (all query names ending with _SUBGRAPH)Dune Analytics​ENS Dashboard ​Dune is a popular social network to analyse and share blockchain data. Users (called Data wizards) can write SQL to analyse on-chain data. Others can fork (copy) SQL code, make modifications, and share the insight with visual charts. Unlike TheGraph, Dune has decoded many popular smart contract events and function calls including ENS and therefore no need to create its schema. The downside is that the available tables are less structured than the GraphQL subgraph and you will need more domain knowledge about the underlying smart contract events and function call structures.Dune currently has v1 running on PostgreSQL and v2 running on Databrick which is a column-oriented database. Though v2 often runs faster, it lacks user-defined functions such as namehash functions. The following example counts monthly .eth name registrations.SELECT date_trunc('month', evt_block_time), COUNT(*)FROM (SELECT * FROM ethereumnameservice.""ETHRegistrarController_1_evt_NameRegistered""WHERE evt_block_time > (current_date - interval '1' year)UNION SELECT * FROM ethereumnameservice.""ETHRegistrarController_2_evt_NameRegistered""WHERE evt_block_time > (current_date - interval '1' year)UNION SELECT * FROM ethereumnameservice.""ETHRegistrarController_3_evt_NameRegistered""WHERE evt_block_time > (current_date - interval '1' year)) AS r GROUP BY 1Dune is good for data analytics purposes. CSV download is a paid option and their support for API isn’t public yet so not suitable to call from dapps and web services. There are some abstractions in their spell book. To access abstractions, you must query via V2 (example). You need to replace “ens_”. with “ens.” For example, If you want to access ens_node_names.sql , then you query as “select * from ens.node_names”.Google BigQueryBigQuery is a data analytics platform similar to Dune Analytics without any “social” features. The query tends to run quicker than dune but it charges per query hence it could cost a lot. Google BigQuery allows you to export the query result into csv/google spreadsheet as well as to their “Data Studio” visualization platform.​ENS Revenue data sudio view The biggest advantage of BigQuery is to allow you to import javascript libraries as a user-defined function. This is particularly helpful if you want to make use of popular javascript libraries such as ethers.js​An example query: comparing normalised labelsCREATE TEMP FUNCTION ens_normalize(arg1 STRING)RETURNS STRINGLANGUAGE js OPTIONS ( library=['gs://jsassets/ens-normalize.js'])AS r"""""" try{ return ens_normalize(arg1) }catch(e){ return null; }"""""";WITH Example AS (SELECT '50' as label UNION ALL SELECT '⁕⁕⁕⁕⁕' UNION ALL --* legacy error, new ok *-- SELECT '🚀‍‍‍‍‍‍‍‍‍‍🚀‍‍‍‍‍‍‍‍‍‍🚀‍‍‍‍‍‍‍‍‍‍') --* legacy ok , new error *--SELECT label, ens_normalize(label) FROM ExampleContract structuresThe full detail of each smart contract is covered in the contract api reference section. This section lists function names and events which are often used to access the data. To find out the deployed addresses, please refer to “ENS Deployments” section.ENSRegistry/ENSRegistryWithFallback""Transfer(node, owner)""""NewOwner(node, label, owner)""""NewResolver(node,resolver)""The contract contains the name owner (aka “controller”) and resolver contract addresses that hold the actual record (such as ETH address, IPFS content hash) . The name is stored in namehash format so that it can store an infinite length of the name. The name owner has the privilege to change the resolver contract and can create subdomains under the name you own.NewOwner event is logged when the owner of a node assigns a new owner to a sub node. Transfer event is logged when the owner of a node transfers ownership to a new account. NewResolver event is logged when the resolver for a node changes. NOTE: The current ENS registry contract is ENSRegistryWithFallback that was deployed in 2020 Feb to resolve the bug found in the original Registry. Even though the majority of names have transferred to the new contract, there are some names (mostly names owned by smart contract) that couldn’t be migrated. If you want to extract all names existing, you have to query both registries and remove the duplicates.ResolverAddressChanged(node,coinType,address)ContenthashChanged(node, name)NameChanged(node, value)TextChanged(node, key, key, value)The majority of the contracts use a default resolver which is set at the time of registration. However, the default resolver has changed a few times to add new functionalities (eg: coin type). To find out all the resolver addresses, you have to get the resolver address through ENSRegistry. NewResolver event (note: Users in the past have put their own ETH address by mistake hence there are 100s of addresses that are set as new resolver which don’t contain any record). BaseRegistrarNameRegistered(id, owner, expires)NameRenewed(id, expires)Transfer(from,to,tokenId) BaseRegistrar is the owner of .eth and is a ERC721 NFT contract. id is the hash of the label (eg: for “matoken.eth”, the keccak256 of “matoken” becomes the id. For more information, read “ENS as NFT section”). EthRegistrarControllerNameRegistered(name, label, owner, baseCost, premium, expires)NameRenewed(name, label, cost, expires)The EthRegistrarController contract contains the actual registration logic. The contract is upgradable via DAO vote and has been changed a few times in the past. The Registered/Renewed events contain the registration logic as well as domain names in plain text. The Graph uses this information to decode .eth id and lablehash into human readable names.NameWrapperNameWrapped(node, name, owner, fuses, expiry)NameUnwrapped(node, owner)FusesSet(node, fuses)TransferSingle(operator, from, to, ids, value)TransferBatch(operator, from, to, ids, value)NameWrapper is the new feature that turns any subdomains into NFT (with extra access control to prevent parent domain owners from reverting the NFT ownership). TransferSingle and TransferBatch are ERC1155 defined events.FAQListing all primary namesSmartContract = reverse-records smart contract allows you to resolve primary names for multiple addresses. TheGraph = subgraph currently does not index primary name info (github issue). Dune = If you simply want to count the number, you can count the number of names registered under addr.reverse node (example query). To query all names, use “ens.node_names” abstraction.Listing all registered namesJS & SmartContract = There is no function to list all registered names. TheGraph = Querying Domains object will give you the list of names. Dune = Query ENSRegistry_evt_NewOwner and ENSRegistryWithFallback_evt_NewOwner tables If you want to exclude released names, you need to join the registration table and exclude where the expiration date is less than the current date - 90 days (90 days is the grace period where the name is expired but no one can register).Listing all records (ETH address/contenthash/text record)JS & SmartContract = There is no function to list all registered names. Dune = Query PublicResolver_call_* Example query or use “ens.resolver_records” abstraction.TheGraph = Querying `Domains.resolver` object will give you all the records.Example{ domains { name resolver{ contentHash texts addr { id } coinTypes } }​NOTE: texts and coinTypes only return the keys so you still have to call smart contracts to get the value.Listing Offchain namesThe offchain names cannot be tracked because they do not exist on the chain.Why are some subdomain names not decoded?ENS names are stored as a hash on-chain so we have to decode the name using a list of possible names, and it shows in the hashed format if we don't have it on our list. You can still access and manage the name if you search for the name directly in the search bar.How do I find sub categories such as 10k club, 100k club, emoji, etc?ENS Protocol itself does not have any mechanism to categorise names. You can either search with certain categories using regular expressions (Dune example) or may refer to third-party sites such as ​​https://ens.visionDapp Developer Guide - PreviousENS Layer2 and offchain data supportNext - Contract API ReferenceName ProcessingLast modified 1mo agoCopy linkEdit on GitHubOn this pageOverviewTarget audienceHow to access ENS dataThe GraphDune AnalyticsGoogle BigQueryContract structuresENSRegistry/ENSRegistryWithFallbackResolverBaseRegistrarEthRegistrarControllerNameWrapperFAQListing all primary namesListing all registered namesListing all records (ETH address/contenthash/text record)Listing Offchain namesWhy are some subdomain names not decoded?How do I find sub categories such as 10k club, 100k club, emoji, etc? "
128,mains ,"mains .   Introduction - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookIntroductionThe Ethereum Name Service (ENS) is a distributed, open, and extensible naming system based on the Ethereum blockchain.ENS’s job is to map human-readable names like ‘alice.eth’ to machine-readable identifiers such as Ethereum addresses, other cryptocurrency addresses, content hashes, and metadata. ENS also supports ‘reverse resolution’, making it possible to associate metadata such as canonical names or interface descriptions with Ethereum addresses.ENS has similar goals to DNS, the Internet’s Domain Name Service, but has significantly different architecture due to the capabilities and constraints provided by the Ethereum blockchain. Like DNS, ENS operates on a system of dot-separated hierarchical names called domains, with the owner of a domain having full control over subdomains.Top-level domains, like ‘.eth’ and ‘.test’, are owned by smart contracts called registrars, which specify rules governing the allocation of their subdomains. Anyone may, by following the rules imposed by these registrar contracts, obtain ownership of a domain for their own use. ENS also supports importing in DNS names already owned by the user for use on ENS.Because of the hierarchal nature of ENS, anyone who owns a domain at any level may configure subdomains - for themselves or others - as desired. For instance, if Alice owns 'alice.eth', she can create 'pay.alice.eth' and configure it as she wishes.ENS is deployed on the Ethereum main network and on several test networks. If you use a library such as the ensjs Javascript library, or an end-user application, it will automatically detect the network you are interacting with and use the ENS deployment on that network.You can try ENS out for yourself now by using the ENS Manager App, or by using any of the many ENS enabled applications on our homepage.ENS ArchitectureENS has two principal components: the registry, and resolvers.The ENS registry consists of a single smart contract that maintains a list of all domains and subdomains, and stores three critical pieces of information about each:The owner of the domainThe resolver for the domainThe caching time-to-live for all records under the domainThe owner of a domain may be either an external account (a user) or a smart contract. A registrar is simply a smart contract that owns a domain and issues subdomains of that domain to users that follow some set of rules defined in the contract.Owners of domains in the ENS registry may:Set the resolver and TTL for the domainTransfer ownership of the domain to another addressChange the ownership of subdomainsThe ENS registry is deliberately straightforward and exists only to map from a name to the resolver responsible for it.Resolvers are responsible for the actual process of translating names into addresses. Any contract that implements the relevant standards may act as a resolver in ENS. General-purpose resolver implementations are offered for users whose requirements are straightforward, such as serving an infrequently changed address for a name.Each record type - cryptocurrency address, IPFS content hash, and so forth - defines a method or methods that a resolver must implement in order to provide records of that kind. New record types may be defined at any time via the EIP standardization process, with no need to make changes to the ENS registry or to existing resolvers in order to support them.Resolving a name in ENS is a two-step process: First, ask the registry what resolver is responsible for the name, and second, ask that resolver for the answer to your query.In the above example, we're trying to find the Ethereum address pointed to by 'foo.eth'. First, we ask the registry which resolver is responsible for 'foo.eth'. Then, we query that resolver for the address of 'foo.eth'.NamehashResource constraints in smart contracts make interacting directly with human-readable names inefficient, so ENS works purely with fixed length 256-bit cryptographic hashes. In order to derive the hash from a name while still preserving its hierarchal properties, a process called Namehash is used. For example, the namehash of 'alice.eth' is 0x787192fc5378cc32aa956ddfdedbf26b24e8d78e40109add0eea2c1a012c3dec; this is the representation of names that is used exclusively inside ENS.Namehash is a recursive process that can generate a unique hash for any valid domain name. Starting with the namehash of any domain - for example, 'alice.eth' - it's possible to derive the namehash of any subdomain - for example 'iam.alice.eth' - without having to know or handle the original human-readable name. It is this property that makes it possible for ENS to provide a hierarchal system, without having to deal with human-readable text strings internally.Before being hashed with namehash, names are first normalized, using a process called UTS-46 normalization. This ensures that upper- and lower-case names are treated equivalently, and that invalid characters are prohibited. Anything that hashes and resolves a name must first normalize it, to ensure that all users get a consistent view of ENS.For details on how namehash and normalization works, see the developer documentation on name processing.Getting StartedENS has documentation for a variety of audiences, including dapp developers and contract developers, as well as reference documentation.I'm a dapp developer and want to add ENS support to my dappCheck out the dapp developer guide, starting with ENS Enabling your Dapp. You'll want to choose one of the many available ENS Libraries to get started working with ENS.I'm a contract developer and want to interact with ENS from my contract codeCheck out the Contract Developer Guide, starting with Resolving Names On-chain. You can also write your own resolver (to customise the process of looking up names), or your own registrar (to customise the process of registering new names).I want reference documentation for the ENS smart contractsCheck out the Contract API Reference. We have reference documentation for ENS's core contract, the registry, for resolvers, and for commonly-used registrars such as the Test registrar, reverse registrar, and the .eth registrar.NextTerminologyLast modified 1yr agoCopy linkEdit on GitHubOn this pageENS ArchitectureNamehashGetting Started "
129,mains contract api reference ens,"mains contract api reference ens.   Registry - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookRegistryThe ENS registry.​Source​The ENS registry is the core contract that lies at the heart of ENS resolution. All ENS lookups start by querying the registry. The registry maintains a list of domains, recording the owner, resolver, and TTL for each, and allows the owner of a domain to make changes to that data.The ENS registry is specified in EIP 137.Get Ownerfunction owner(bytes32 node) external view returns (address);Returns the owner of the name specified by node.Get Resolverfunction resolver(bytes32 node) external view returns (address);Returns the address of the resolver responsible for the name specified by node.Get TTLfunction ttl(bytes32 node) external view returns (uint64);Returns the caching time-to-live of the name specified by node. Systems that wish to cache information about a name, including ownership, resolver address, and records, should respect this value. If TTL is zero, new data should be fetched on each query.Set Ownerfunction setOwner(bytes32 node, address owner) external;Reassigns ownership of the name identified by node to owner. Only callable by the current owner of the name.Emits the following event:event Transfer(bytes32 indexed node, address owner);Set Resolverfunction setResolver(bytes32 node, address resolver) external;Updates the resolver associated with the name identified by node to resolver. Only callable by the current owner of the name. resolver must specify the address of a contract that implements the Resolver interface.Emits the following event:event NewResolver(bytes32 indexed node, address resolver);Set TTLfunction setTTL(bytes32 node, uint64 ttl) external;Updates the caching time-to-live of the name identified by node. Only callable by the current owner of the name.Emits the following event:event NewTTL(bytes32 indexed node, uint64 ttl);Set Subdomain Ownerfunction setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;Creates a new subdomain of node, assigning ownership of it to the specified owner. If the domain already exists, ownership is reassigned but the resolver and TTL are left unmodified.label is the keccak256 hash of the subdomain label to create. For example, if you own alice.eth and want to create the subdomain iam.alice.eth, supply namehash('alice.eth') as the node, and keccak256('iam') as the label.Emits the following event:event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);Set Recordfunction setRecord(bytes32 node, address owner, address resolver, uint64 ttl);Sets the owner, resolver, and TTL for an ENS record in a single operation. This function is offered for convenience, and is exactly equivalent to calling setResolver, setTTL and setOwner in that order.Set Subdomain Recordfunction setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl);Sets the owner, resolver and TTL for a subdomain, creating it if necessary. This function is offered for convenience, and permits setting all three fields without first transferring ownership of the subdomain to the caller.Set Approvalfunction setApprovalForAll(address operator, bool approved);Sets or clears an approval. Approved accounts can execute all ENS registry operations on behalf of the caller.Check Approvalfunction isApprovedForAll(address owner, address operator) external view returns (bool);Returns true if operator is approved to make ENS registry operations on behalf of owner.Check Record Existencefunction recordExists(bytes32 node) public view returns (bool);Returns true if node exists in this ENS registry. This will return false for records that are in the legacy ENS registry but have not yet been migrated to the new one.Contract API Reference - PreviousName ProcessingNext - Contract API ReferenceReverseRegistrarLast modified 1yr agoCopy linkEdit on GitHubOn this pageGet OwnerGet ResolverGet TTLSet OwnerSet ResolverSet TTLSet Subdomain OwnerSet RecordSet Subdomain RecordSet ApprovalCheck ApprovalCheck Record Existence "
130,mains contract api reference .eth permanent registrar registrar#check name availability,"mains contract api reference .eth permanent registrar registrar#check name availability.   Registrar - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarRegistrarControllerDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookRegistrar​Source​This contract implements the core functionality of the permanent registrar, with the following features:The owner of the registrar may add and remove 'controllers'.Controllers may register new domains and extend the expiry of (renew) existing domains. They can not change the ownership or reduce the expiration time of existing domains.Name owners may transfer ownership to another address.Name owners may reclaim ownership in the ENS registry if they have lost it.Owners of names in the legacy registrar may transfer them to the new registrar, during the 1 year transition period. When they do so, their deposit is returned to them in its entirety.This section documents the parts of the registrar interface relevant to implementers of tools that interact with it. Functionality exclusive to the registrar owner or to controllers is omitted for brevity.The registrar works exclusively with label hashes - the keccak256 of the first component of the label (eg, keccak256('ens') for ens.eth). For compatibility with ERC721, these are expressed as uint256 values rather than bytes32, but can be cast backwards and forwards transparently. The namehash of a name can be derived by computing keccak256(baseNode, labelHash), where basenode is the namehash of the TLD the registrar manages - eg, namehash('eth').Registrations and renewals are handled via the controller.Names and RegistrationsAll names inside ENS have an owner. The owner of a name can transfer the name to a new owner, set a resolver, and create and reassign subdomains. This functionality is all contained in the ENS registry.Allocation of names directly under .eth (eg, second-level domains ending with .eth, such as alice.eth) is governed by the .eth Permanent Registrar, described here. While buying a name from the registrar grants ownership of it in ENS, the registrar itself keeps independent track of who owns the registration. The concept of a registrant - the owner of a registration - is unique to the .eth permanent registrar.The registrant of a name can transfer the registration to another account, and they can recover ownership of the name by calling reclaim, which resets ownership of the ENS name to the registrant's account.Separating the concept of owning a name from owning a registration makes it possible to more easily build systems that make automated updates to ENS. The registrant can transfer ownership of the name to another account or to a smart contract that manages records, subdomains, etc, while still retaining the ability to recover ownership for upgrades, or in the case of a compromise.When thinking about ownership, it's important to be clear whether you're considering ownership of the name or the registration.Read OperationsGet Name Expiryfunction nameExpires(uint256 label) external view returns(uint);Returns the unix timestamp at which a registration currently expires. Names that do not exist or are not yet migrated from the legacy registrar will return 0.Check Name Availabilityfunction available(uint256 label) public view returns(bool);Returns true if a name is available for registration. Takes into account not-yet-migrated registrations from the legacy registrar. Registrar controllers may impose more restrictions on registrations than this contract (for example, a minimum name length), so this function should not be used to check if a name can be registered by a user. To check if a name can be registered by a user, check name availability via the controller.Get Transfer Period Enduint public transferPeriodEnds;transferPeriodEnds documents the unix timestamp at which it is no longer possible to migrate over registrations from the legacy registrar, and any non-migrated registrations become available for registration by anyone.Get Controller Statusmapping(address=>bool) public controllers;controllers allows callers to check if the supplied address is authorized as a registrar controller.Check Token Approvalfunction getApproved(uint256 tokenId) public view returns (address operator);Returns the address of the approved operator for this name.This function is part of ERC721.Check All Tokens Approvalfunction isApprovedForAll(address owner, address operator) public view returns (bool);Returns true if operator is authorized to transfer all tokens for owner.This function is part of ERC721.Get Name Ownerfunction ownerOf(uint256 label) external view returns(address);ownerOf returns the address that owns the registration identified by the label hash, or reverts if the registration does not exist. Registrations that have not yet been migrated from the legacy registrar are treated the same as registrations that do not exist.This function is part of ERC721.Write OperationsTransfer a Namefunction transferFrom(address from, address to, uint256 tokenId) public;function safeTransferFrom(address from, address to, uint256 tokenId) public;function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;These functions transfer the registration.They behave as specified in ERC721.Emits the following event on a successful transfer:event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);Approve Operatorfunction approve(address to, uint256 tokenId) public;function setApprovalForAll(address operator, bool _approved) public;These functions manage approvals as documented in ERC721.Reclaim ENS Recordfunction reclaim(uint256 label) external;Sets the owner record of the name in the ENS registry to match the owner of the registration in this registry. May only be called by the owner of the registration.EventsName Migratedevent NameMigrated(uint256 indexed hash, address indexed owner, uint expires);This event is emitted when a name is migrated from the legacy registrar.Name Registeredevent NameRegistered(uint256 indexed hash, address indexed owner, uint expires);This event is emitted when a controller registers a new name.Name Renewedevent NameRenewed(uint256 indexed hash, uint expires);This event is emitted when a controller renews (extends the registration of) a name.Transferevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);This event is emitted when registration is transferred to a new owner. This is distinct from the ENS Registry's Transfer event, which records transfers of ownership of the ENS record.Contract API Reference - Previous.eth Permanent RegistrarNextControllerLast modified 1yr agoCopy linkEdit on GitHubOn this pageNames and RegistrationsRead OperationsGet Name ExpiryCheck Name AvailabilityGet Transfer Period EndGet Controller StatusCheck Token ApprovalCheck All Tokens ApprovalGet Name OwnerWrite OperationsTransfer a NameApprove OperatorReclaim ENS RecordEventsName MigratedName RegisteredName RenewedTransfer "
131,mains contract api reference subgraphdata entities,"mains contract api reference subgraphdata entities.   Entities - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookEntitiesEntities​Domain​​DomainEvent​​Transfer​​NewOwner​​NewResolver​​NewTTL​​Account​​Registration​​RegistrationEvent​​NameRegistered​​NameRenewed​​NameTransferred​​Resolver​​ResolverEvent​​AddrChanged​​MulticoinAddrChanged​​NameChanged​​AbiChanged​​PubKeyChanged​​TextChanged​​ContentHashChanged​​InterfaceChanged​​AuthorisationChanged​DomainDescription:FieldTypeDescriptionidID!The namehash of the namenameStringThe human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)labelNameStringThe human readable label name (imported from CSV), if knownlabelhashByteskeccak256(labelName)parentDomainThe namehash (id) of the parent namesubdomains​Domain!​Can count domains from length of arraysubdomainCountInt!The number of subdomainsresolvedAddressaccountAddress logged from current resolver, if anyownerAccount!​resolverResolver​ttlBigInt​isMigratedBoolean!​createdAtBigInt!​events​DomainEvent!​​TransferDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​NewOwnerDescription:FieldTypeDescriptionidID!​parentDomainDomain!​domainDomain!​TransactionIDBytes!​ownerAccount!​NewResolverDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​resolverResolver!​NewTTLDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​transactionIDBytes!​ttlBigInt!​AccountDescription:FieldTypeDescriptionidID!​domain​Domain!​​registration​Registration!​​RegistrationDescription:FieldTypeDescriptionidID!​domainDomain​registrationDateBigInt!​expiryDateBigInt!​costBigInt!​registrantAccount!​labelNameString​events​RegistrationEven!​​RegistrationEventDescription:FieldTypeDescriptionidID!​registrationRegistrationEvent​blockNumberInt!​transactionIDBytes!​NameRegisteredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​registrantAccount!​expiryDateBigInt!​NameRenewedDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​expiryDateBigInt!​NameTransferredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​newOwnerAccount!​ResolverDescription:FieldTypeDescriptionidID!Concatenation of resolver address and namehashdomainDomain​addressBytes!Address of resolver contractaddrAccountCurrent value of addr record (per events)contenHashBytesContent hash, in binary formattexts[String!]Set of observed text record keyscointTypes[BigInt!]Set of observed SLIP-44 coin typesevents​ResolverEvent!​​ResolverEventDescription:FieldTypeDescriptionidID!Concatenation of block number and log IDresolverResolver!Used to derive relationships to ResolversblockNumberInt!​transactionIDBytes!​AddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​addrAccount!​MulticoinAddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​coinTypeBigInt!​addrBytes!​NameChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​nameString!​AbiChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​contentTypeBigInt!​PubkeyChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​xBytes!​yBytes!​TextChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​keyString!​valueString​ContenthashChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​hashBytes!​InterfaceChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​interfacedIDBytes!​implementerBytes!​AuthorisationChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​ownerBytes!​targetBytes!​isAuthorizedBoolean!​Contract API Reference - PreviousSubgraphNextQuery ExamplesLast modified 6mo agoCopy linkEdit on GitHubOn this pageEntitiesDomainTransferNewOwnerNewResolverNewTTLAccountRegistrationRegistrationEventNameRegisteredNameRenewedNameTransferredResolverResolverEventAddrChangedMulticoinAddrChangedNameChangedAbiChangedPubkeyChangedTextChangedContenthashChangedInterfaceChangedAuthorisationChanged "
132,mains contract api reference publicresolver#check interface support,"mains contract api reference publicresolver#check interface support.   PublicResolver - ENS Documentation    ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookPublicResolverThe default public resolver.​Source​PublicResolver implements a general-purpose ENS resolver that is suitable for most standard ENS use-cases. The public resolver permits updates to ENS records by the owner of the corresponding name.The public resolver implements the following EIPs:​EIP 137 - Contract address interface (addr()).​EIP 165 - Interface Detection (supportsInterface()).​EIP 181 - Reverse resolution (name()).​EIP 205 - ABI support (ABI()).​EIP 619 - SECP256k1 public keys (pubkey()).​EIP 634 - Text records (text()).​EIP 1577 - Content hash support (contenthash()).​EIP 2304 - Multicoin support (addr()).While the PublicResolverprovides a convenient default implementation, many resolver implementations and versions exist. Callers must not assume that a domain uses the current version of the public resolver, or that all of the methods described here are present. To check if a resolver supports a feature, see Check Interface Support.Check Interface Supportfunction supportsInterface(bytes4 interfaceID) external pure returns (bool)ENS uses ERC 165 for interface detection. ERC 165 requires that supporting contracts implement a function, supportsInterface, which takes an interface ID and returns a boolean value indicating if this interface is supported or not.Interface IDs are calculated as the exclusive-or of the four-byte function identifiers of each function included in the interface. For example, addr(bytes32) has the function ID 0x3b3b57de. Because it is the only function in the Ethereum Address interface, its interface ID is also 0x3b3b57de, and so calling supportsInterface(0x3b3b57de) will return true for any resolver that supports addr().ERC 165 has an interface ID of 0x01ffc9a7, so supportsInterface(0x01ffc9a7) will always return true for any ERC 165 supporting contract (and hence for any resolver).Note that the public resolver does not expose explicit interfaces for setter functions, so there are no automated means to check for support for a given setter function.Get Ethereum Addressfunction addr(bytes32 node) external view returns (address)Returns the Ethereum address associated with the provided node, or 0 if none.This function has interface ID 0x3b3b57de.This function is specified in EIP 137.Set Ethereum Addressfunction setAddr(bytes32 node, address addr) external;Sets the Ethereum address associated with the provided node to addr.Only callable by the owner of node.Emits the following event:event AddrChanged(bytes32 indexed node, address a);Get Blockchain Addressfunction addr(bytes32 node, uint coinType) external view returns(bytes memory);Returns the Blockchain address associated with the provided node and coinType, or 0 if none.This function has interface ID 0xf1cb7e06.This function is specified in EIP 2304.The return value is the cryptocurrency address in its native binary format and each blockchain address has a different encoding and decoding method.For example, the Bitcoin address 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa base58check decodes to the 21 bytes 0062e907b15cbf27d5425399ebf6f0fb50ebb88f18 then scriptPubkey encodes to 25 bytes 76a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1888ac whereas the BNB address bnb1grpf0955h0ykzq3ar5nmum7y6gdfl6lxfn46h2 Bech32 decodes to the binary representation 40c2979694bbc961023d1d27be6fc4d21a9febe6.To convert the binary representation into the address, use formatsByCoinType[SYMBOL].encoder(binary) of address-encoder.A zero-length string will be returned if the specified coin ID does not exist on the specified node.Set Blockchain Addressfunction setAddr(bytes32 node, uint coinType, bytes calldata a) external;Sets the blockchain address associated with the provided node and coinType to addr.coinType is the cryptocurrency coin type index from SLIP44.To convert the address into the binary representation, use formatsByName[SYMBOL].decoder(text) of address-encoder​Only callable by the owner of node.Emits the following event:event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);Get Canonical Namefunction name(bytes32 node) external view returns (string memory);Returns the canonical ENS name associated with the provided node. Used exclusively for reverse resolution.This function has interface ID 0x691f3431.This function is specified in EIP 181.Set Canonical Namefunction setName(bytes32 node, string calldata name) external;Sets the canonical ENS name for the provided node to name.Only callable by the owner of node.Emits the following event:event NameChanged(bytes32 indexed node, string name);Get Content Hashfunction contenthash(bytes32 node) external view returns (bytes memory);Returns the content hash for node, if one exists. Values are formatted as machine-readable multicodecs, as specified in EIP 1577.contenthash is used to store IPFS and Swarm content hashes, which permit resolving ENS addresses to distributed content (eg, websites) hosted on these distributed networks.This function has interface ID 0xbc1c58d1.This function is specified in EIP 1577.Set Content Hashfunction setContenthash(bytes32 node, bytes calldata hash) external;Sets the content hash for the provided node to hash.Only callable by the owner of node.Values are formatted as machine-readable multicodecs, as specified in EIP 1577.Emits the following event:event ContenthashChanged(bytes32 indexed node, bytes hash);Get Contract ABIABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory);Returns a matching ABI definition for the provided node, if one exists. contentTypes is the bitwise-OR of the encodings that the caller can accept. If multiple content types are specified, the resolver will select one to return. Currently supported content types are:Content Type IDDescription1JSON2zlib-compressed JSON4​CBOR​8URIABI returns a two-tuple of the content type ID and the ABI data. If no data of the appropriate content type ID was found, 0 is returned for the content type ID, and the ABI data will be the empty string.This function has interface ID 0x2203ab56.This function is specified in EIP 205.Set Contract ABIfunction setABI(bytes32 node, uint256 contentType, bytes calldata data) externalSets or updates ABI data for node. contentType specifies the content type ID (see Get Contract ABI for valid values); exactly one type ID must be specified. data contains the encoded ABI data. To clear ABI data for a name, specify the empty string for data.Only callable by the owner of node.Emits the following event:event ABIChanged(bytes32 indexed node, uint256 indexed contentType);Get Public Keyfunction pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y)Returns the ECDSA SECP256k1 public key for node, as a 2-tuple (x, y). If no public key is set, (0, 0) is returned.This function has interface ID 0xc8690233.This function is specified in EIP 619.Set Public Keyfunction setPubkey(bytes32 node, bytes32 x, bytes32 y) externalSets the ECDSA SECP256k1 public key for node to (x, y).Only callable by the owner of node.Emits the following event:event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);Get Text Datafunction text(bytes32 node, string calldata key) external view returns (string memory)Retrieves text metadata for node. Each name may have multiple pieces of metadata, identified by a unique string key. If no text data exists for node with the key key, the empty string is returned.Standard values for key are:keyMeaningemailAn email addressurlA URLavatarA URL to an image used as an avatar or logodescriptionA description of the namenoticeA notice regarding this namekeywordsA list of comma-separated keywords, ordered by most significant first; clients that interpresent this field may choose a threshold beyond which to ignoreIn addition, anyone may specify vendor-specific keys, which must be prefixed with vnd.. The following vendor-specific keys are currently known:keyMeaningcom.twitterTwitter handlecom.githubGithub usernameThis function has interface ID 0x59d1d43c.This function is specified in EIP 634.Set Text Datafunction setText(bytes32 node, string calldata key, string calldata value) externalSets text metadata for node with the unique key key to value, overwriting anything previously stored for node and key. To clear a text field, set it to the empty string.Only callable by the owner of node.Emits the following event:event TextChanged(bytes32 indexed node, string indexedKey, string key);Multicallfunction multicall(bytes[] calldata data) external returns(bytes[] memory results)Permits users to set multiple records in a single operation.Use encodeABI function to encode your contract calls and pass it to data.The frontend usage will be as follows:var addrSet = resolver.contract.methods['setAddr(bytes32,address)'](node, accounts[1]).encodeABI();var textSet = resolver.contract.methods.setText(node, ""url"", ""https://ethereum.org/"").encodeABI();var tx = await resolver.multicall([addrSet, textSet], {from: accounts[0]});Contract API Reference - PreviousTestRegistrarNext - Contract API Reference.eth Permanent RegistrarLast modified 1yr agoCopy linkEdit on GitHubOn this pageCheck Interface SupportGet Ethereum AddressSet Ethereum AddressGet Blockchain AddressSet Blockchain AddressGet Canonical NameSet Canonical NameGet Content HashSet Content HashGet Contract ABISet Contract ABIGet Public KeySet Public KeyGet Text DataSet Text DataMulticall "
133,mains cdn cgi l email protection#751b1c161e35101b065b111a18141c1b06,"mains cdn cgi l email protection#751b1c161e35101b065b111a18141c1b06.   Email Protection | Cloudflare    Please enable cookies. Email Protection You are unable to access this email address docs.ens.domains  The website from which you got to this page is protected by Cloudflare. Email addresses on that page have been hidden in order to keep them from being accessed by malicious bots. You must enable Javascript in your browser in order to decode the e-mail address. If you have a website and are interested in protecting it in a similar way, you can sign up for Cloudflare.  How does Cloudflare protect email addresses on website from spammers? Can I sign up for Cloudflare?   Cloudflare Ray ID: 7a4542108951dbd9 •  Your IP:  Click to reveal 72.197.148.96 • Performance & security by Cloudflare   "
134,mains contract api reference subgraphdata entities#namerenewed,"mains contract api reference subgraphdata entities#namerenewed.   Entities - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookEntitiesEntities​Domain​​DomainEvent​​Transfer​​NewOwner​​NewResolver​​NewTTL​​Account​​Registration​​RegistrationEvent​​NameRegistered​​NameRenewed​​NameTransferred​​Resolver​​ResolverEvent​​AddrChanged​​MulticoinAddrChanged​​NameChanged​​AbiChanged​​PubKeyChanged​​TextChanged​​ContentHashChanged​​InterfaceChanged​​AuthorisationChanged​DomainDescription:FieldTypeDescriptionidID!The namehash of the namenameStringThe human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)labelNameStringThe human readable label name (imported from CSV), if knownlabelhashByteskeccak256(labelName)parentDomainThe namehash (id) of the parent namesubdomains​Domain!​Can count domains from length of arraysubdomainCountInt!The number of subdomainsresolvedAddressaccountAddress logged from current resolver, if anyownerAccount!​resolverResolver​ttlBigInt​isMigratedBoolean!​createdAtBigInt!​events​DomainEvent!​​TransferDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​NewOwnerDescription:FieldTypeDescriptionidID!​parentDomainDomain!​domainDomain!​TransactionIDBytes!​ownerAccount!​NewResolverDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​resolverResolver!​NewTTLDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​transactionIDBytes!​ttlBigInt!​AccountDescription:FieldTypeDescriptionidID!​domain​Domain!​​registration​Registration!​​RegistrationDescription:FieldTypeDescriptionidID!​domainDomain​registrationDateBigInt!​expiryDateBigInt!​costBigInt!​registrantAccount!​labelNameString​events​RegistrationEven!​​RegistrationEventDescription:FieldTypeDescriptionidID!​registrationRegistrationEvent​blockNumberInt!​transactionIDBytes!​NameRegisteredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​registrantAccount!​expiryDateBigInt!​NameRenewedDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​expiryDateBigInt!​NameTransferredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​newOwnerAccount!​ResolverDescription:FieldTypeDescriptionidID!Concatenation of resolver address and namehashdomainDomain​addressBytes!Address of resolver contractaddrAccountCurrent value of addr record (per events)contenHashBytesContent hash, in binary formattexts[String!]Set of observed text record keyscointTypes[BigInt!]Set of observed SLIP-44 coin typesevents​ResolverEvent!​​ResolverEventDescription:FieldTypeDescriptionidID!Concatenation of block number and log IDresolverResolver!Used to derive relationships to ResolversblockNumberInt!​transactionIDBytes!​AddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​addrAccount!​MulticoinAddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​coinTypeBigInt!​addrBytes!​NameChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​nameString!​AbiChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​contentTypeBigInt!​PubkeyChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​xBytes!​yBytes!​TextChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​keyString!​valueString​ContenthashChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​hashBytes!​InterfaceChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​interfacedIDBytes!​implementerBytes!​AuthorisationChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​ownerBytes!​targetBytes!​isAuthorizedBoolean!​Contract API Reference - PreviousSubgraphNextQuery ExamplesLast modified 6mo agoCopy linkEdit on GitHubOn this pageEntitiesDomainTransferNewOwnerNewResolverNewTTLAccountRegistrationRegistrationEventNameRegisteredNameRenewedNameTransferredResolverResolverEventAddrChangedMulticoinAddrChangedNameChangedAbiChangedPubkeyChangedTextChangedContenthashChangedInterfaceChangedAuthorisationChanged "
135,mains v governance governance proposals term 2 ep2.2.4 social ens endaoment rfp,"mains v governance governance proposals term 2 ep2.2.4 social ens endaoment rfp.   [EP2.2.4] [Social] ENS Endaoment RFP - ENS Documentation   ENS DocumentationDAO Governance DocsHomeTechnical DocsGovernance DocsSearch…⌃KLinksDAO Governance DocsWelcome to ENS DAOGovernance ProcessENS DAO ConstitutionThe ENS FoundationGovernance ProposalsTerm 0Term 1Term 2[EP2.1] [Executable] Funding True Names Ltd[EP2.2.1] [Executable] Q3 & Q4 2022 Meta-Governance WG Budget[EP2.2.2] [Executable] Q3 & Q4 2022 Ecosystem WG Budget[EP2.2.3] [Executable] Q3 & Q4 2022 Public Goods WG Budget[EP2.2.4] [Social] ENS Endaoment RFP[EP2.2.5] [Social] Selection of an ENS endowment fund managerTerm 3Powered By GitBook[EP2.2.4] [Social] ENS Endaoment RFPRFP for an endowment fund managerStatusPassedVotesPendingOverviewThe DAO is seeking a fund manager to manage an endowment fund. This fund will be established from some combination of current treasury and ongoing revenue, and will exist to insulate the DAO from economic fluctuations, ensuring it can continue its core operations regardless of the wider economic outlook.Funds will be drawn from the DAO's general funds, currently held in ETH and USDC, as well as from ongoing DAO revenue until the fund reaches its target size. Proposals should outline how much of the DAO's current funds the intend to appropriate, as well as what proportion of ongoing revenue will be required, and for how long.The DAO's accounting basis divides assets into earned and unearned income. Unearned income corresponds to funds paid for registrations and renewals that are future-dated; for example, if a user spends $100 to register a name for 20 years, after a year $5 of that will be counted as earned income and the remainder as unearned income.Unearned income may be incorporated into the fund, but must be risk-neutral with regard to ETH. Earned income should be risk-netural with regard to USDC.The DAO's current balances can be viewed here; as of this writing they are:13,069 ETH (~$20M) in earned income$3,817,067 USDC18,184 ETH (~$20M) in unearned incomeScope of Work1.Expand the endowment structure specified in the accepted proposal into an executable form.2.Work with the ENS Meta-Governance stewards to refine the proposal.3.Implement the proposal onchain.4.Administer and adjust the endowment as necessary on an ongoing basis.Selection CriteriaThe endowment will need to be able to sustain annual withdrawals of at least $4M USDC without a long-term reduction in principal.Proposals should include, at a minimum:1.Intended high-level fund allocation of the endowment.2.Initial and target size for the endowment fund, including the proportion of funds sourced from earned and unearned income.3.How incoming revenues and income will be assigned to the fund.4.Specific information on how the fund will be managed, and what steps will be taken to minimise custodial risk.5.A fee schedule for the fund manager.6.A detailed description of the reporting structures that will be put in place.Priority will be given to proposals that:Minimise custodial risk by using onchain mechanisms that allow administration of the funds without the fund administrator having custody of the funds.Lay out a coherent strategy for how investment returns can be maintained in the short/medium/long term.Minimise capital risks relative to the expected returns.Define clear mechanisms for assessment and adjustment to changing external and internal conditions in order to continue to meet the endowment's objectives.Offer a high rate of return proportional to risk.Define a clear reporting structure for frequent and comprehensive reporting of the fund's status to the DAO.TimelineSubmission PeriodSeptember 15 - October 10 2022Approval PeriodOctober 10 - November 7 2022​RFP ManagerThe Meta-Governance WG stewards are the RFP managers for this RFP.Proposals can be submitted via forum DM to the stewards. They will be held in confidence until the end of the submission period, at which point all applicants will be invited to post their proposals publicly for feedback on the forum.Once a winning proposal is selected by the RFP managers, it will be announced and posted publicly.BudgetThe endowment is expected to be funded out of a combination of capital and performance fees as proposed by the fund manager.Previous[EP2.2.3] [Executable] Q3 & Q4 2022 Public Goods WG BudgetNext[EP2.2.5] [Social] Selection of an ENS endowment fund managerLast modified 3mo agoCopy linkEdit on GitHubOn this pageOverviewScope of WorkSelection CriteriaTimelineRFP ManagerBudget "
136,mains contract api reference reverseregistrar,"mains contract api reference reverseregistrar.   ReverseRegistrar - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookReverseRegistrarThe registrar responsible for managing reverse resolution via the .addr.reverse special-purpose TLD.​Source​Reverse resolution in ENS - the process of mapping from an Ethereum address (eg, 0x1234...) to an ENS name - is handled using a special namespace, .addr.reverse. A special-purpose registrar controls this namespace and allocates subdomains to any caller based on their address.For example, the account 0x314159265dd8dbb310642f98f50c066173c1259b can claim 314159265dd8dbb310642f98f50c066173c1259b.addr.reverse. After doing so, it can configure a resolver and expose metadata, such as a canonical ENS name for this address.The reverse registrar provides functions to claim a reverse record, as well as a convenience function to configure the record as it's most commonly used, as a way of specifying a canonical name for an address.The reverse registrar is specified in EIP 181.Claim Addressfunction claim(address owner) public returns (bytes32);Claims the caller's address in the reverse registrar, assigning ownership of the reverse record to owner. Equivalent to calling claimWithResolver(owner, 0).Claim Address with Resolverfunction claimWithResolver(address owner, address resolver) public returns (bytes32)Claims the caller's address in the reverse registrar, assigning ownership of the reverse record to owner. If resolver is nonzero, also updates the record's resolver.After calling this function:The reverse record for the caller (1234....addr.reverse) is owned by owner.If resolver is nonzero, the reverse record for the caller has its resolver set to resolver; otherwise it is left unchanged.Set Namefunction setName(string memory name) public returns (bytes32)Configures the caller's reverse ENS record to point to the provided name.This convenience function streamlines the process of setting up a reverse record for the common case where a user only wants to configure a reverse name and nothing else. It performs the following steps:1.Sets the reverse record for the caller to be owned by the ReverseRegistrar.2.Sets the reverse record for the caller to have defaultResolver as its resolver.3.Sets the name() field in the defaultResolver for the caller's reverse record to name.In short, after calling this, a user has a fully configured reverse record claiming the provided name as that account's canonical name.Users wanting more flexibility will need to use claim or claimWithResolver and configure records manually on their chosen resolver contract.Get Reverse Record Nodefunction node(address addr) public pure returns (bytes32)Accepts an address, and returns the node (namehash output) for the address's reverse record. This function is provided as a convenience for contracts wishing to look up metadata for an address, and avoids the need for those contracts to handle the hex encoding and hashing necessary to derive the required value.Get Default ResolverResolver public defaultResolver;Returns the address of the resolver contract that the ReverseRegistrar uses for setName.Contract API Reference - PreviousRegistryNext - Contract API ReferenceTestRegistrarLast modified 1yr agoCopy linkEdit on GitHubOn this pageClaim AddressClaim Address with ResolverSet NameGet Reverse Record NodeGet Default Resolver "
137,mains contract api reference subgraphdata entities#pubkeychanged,"mains contract api reference subgraphdata entities#pubkeychanged.   Entities - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookEntitiesEntities​Domain​​DomainEvent​​Transfer​​NewOwner​​NewResolver​​NewTTL​​Account​​Registration​​RegistrationEvent​​NameRegistered​​NameRenewed​​NameTransferred​​Resolver​​ResolverEvent​​AddrChanged​​MulticoinAddrChanged​​NameChanged​​AbiChanged​​PubKeyChanged​​TextChanged​​ContentHashChanged​​InterfaceChanged​​AuthorisationChanged​DomainDescription:FieldTypeDescriptionidID!The namehash of the namenameStringThe human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)labelNameStringThe human readable label name (imported from CSV), if knownlabelhashByteskeccak256(labelName)parentDomainThe namehash (id) of the parent namesubdomains​Domain!​Can count domains from length of arraysubdomainCountInt!The number of subdomainsresolvedAddressaccountAddress logged from current resolver, if anyownerAccount!​resolverResolver​ttlBigInt​isMigratedBoolean!​createdAtBigInt!​events​DomainEvent!​​TransferDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​NewOwnerDescription:FieldTypeDescriptionidID!​parentDomainDomain!​domainDomain!​TransactionIDBytes!​ownerAccount!​NewResolverDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​resolverResolver!​NewTTLDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​transactionIDBytes!​ttlBigInt!​AccountDescription:FieldTypeDescriptionidID!​domain​Domain!​​registration​Registration!​​RegistrationDescription:FieldTypeDescriptionidID!​domainDomain​registrationDateBigInt!​expiryDateBigInt!​costBigInt!​registrantAccount!​labelNameString​events​RegistrationEven!​​RegistrationEventDescription:FieldTypeDescriptionidID!​registrationRegistrationEvent​blockNumberInt!​transactionIDBytes!​NameRegisteredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​registrantAccount!​expiryDateBigInt!​NameRenewedDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​expiryDateBigInt!​NameTransferredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​newOwnerAccount!​ResolverDescription:FieldTypeDescriptionidID!Concatenation of resolver address and namehashdomainDomain​addressBytes!Address of resolver contractaddrAccountCurrent value of addr record (per events)contenHashBytesContent hash, in binary formattexts[String!]Set of observed text record keyscointTypes[BigInt!]Set of observed SLIP-44 coin typesevents​ResolverEvent!​​ResolverEventDescription:FieldTypeDescriptionidID!Concatenation of block number and log IDresolverResolver!Used to derive relationships to ResolversblockNumberInt!​transactionIDBytes!​AddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​addrAccount!​MulticoinAddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​coinTypeBigInt!​addrBytes!​NameChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​nameString!​AbiChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​contentTypeBigInt!​PubkeyChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​xBytes!​yBytes!​TextChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​keyString!​valueString​ContenthashChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​hashBytes!​InterfaceChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​interfacedIDBytes!​implementerBytes!​AuthorisationChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​ownerBytes!​targetBytes!​isAuthorizedBoolean!​Contract API Reference - PreviousSubgraphNextQuery ExamplesLast modified 6mo agoCopy linkEdit on GitHubOn this pageEntitiesDomainTransferNewOwnerNewResolverNewTTLAccountRegistrationRegistrationEventNameRegisteredNameRenewedNameTransferredResolverResolverEventAddrChangedMulticoinAddrChangedNameChangedAbiChangedPubkeyChangedTextChangedContenthashChangedInterfaceChangedAuthorisationChanged "
138,mains contract api reference subgraphdata entities#nametransferred,"mains contract api reference subgraphdata entities#nametransferred.   Entities - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphEntitiesQuery ExamplesContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookEntitiesEntities​Domain​​DomainEvent​​Transfer​​NewOwner​​NewResolver​​NewTTL​​Account​​Registration​​RegistrationEvent​​NameRegistered​​NameRenewed​​NameTransferred​​Resolver​​ResolverEvent​​AddrChanged​​MulticoinAddrChanged​​NameChanged​​AbiChanged​​PubKeyChanged​​TextChanged​​ContentHashChanged​​InterfaceChanged​​AuthorisationChanged​DomainDescription:FieldTypeDescriptionidID!The namehash of the namenameStringThe human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)labelNameStringThe human readable label name (imported from CSV), if knownlabelhashByteskeccak256(labelName)parentDomainThe namehash (id) of the parent namesubdomains​Domain!​Can count domains from length of arraysubdomainCountInt!The number of subdomainsresolvedAddressaccountAddress logged from current resolver, if anyownerAccount!​resolverResolver​ttlBigInt​isMigratedBoolean!​createdAtBigInt!​events​DomainEvent!​​TransferDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​NewOwnerDescription:FieldTypeDescriptionidID!​parentDomainDomain!​domainDomain!​TransactionIDBytes!​ownerAccount!​NewResolverDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​TransactionIDBytes!​resolverResolver!​NewTTLDescription:FieldTypeDescriptionidID!​domainDomain!​blockNumberInt!​transactionIDBytes!​ttlBigInt!​AccountDescription:FieldTypeDescriptionidID!​domain​Domain!​​registration​Registration!​​RegistrationDescription:FieldTypeDescriptionidID!​domainDomain​registrationDateBigInt!​expiryDateBigInt!​costBigInt!​registrantAccount!​labelNameString​events​RegistrationEven!​​RegistrationEventDescription:FieldTypeDescriptionidID!​registrationRegistrationEvent​blockNumberInt!​transactionIDBytes!​NameRegisteredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​registrantAccount!​expiryDateBigInt!​NameRenewedDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​expiryDateBigInt!​NameTransferredDescription:FieldTypeDescriptionidID!​registrationRegistration!​blockNumberInt!​transactionIDBytes!​newOwnerAccount!​ResolverDescription:FieldTypeDescriptionidID!Concatenation of resolver address and namehashdomainDomain​addressBytes!Address of resolver contractaddrAccountCurrent value of addr record (per events)contenHashBytesContent hash, in binary formattexts[String!]Set of observed text record keyscointTypes[BigInt!]Set of observed SLIP-44 coin typesevents​ResolverEvent!​​ResolverEventDescription:FieldTypeDescriptionidID!Concatenation of block number and log IDresolverResolver!Used to derive relationships to ResolversblockNumberInt!​transactionIDBytes!​AddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​addrAccount!​MulticoinAddrChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​coinTypeBigInt!​addrBytes!​NameChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​nameString!​AbiChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​contentTypeBigInt!​PubkeyChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​xBytes!​yBytes!​TextChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​keyString!​valueString​ContenthashChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​hashBytes!​InterfaceChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​interfacedIDBytes!​implementerBytes!​AuthorisationChangedDescription:FieldTypeDescriptionidID!​resolverResolver!​blockNumberInt!​transactionIDBytes!​ownerBytes!​targetBytes!​isAuthorizedBoolean!​Contract API Reference - PreviousSubgraphNextQuery ExamplesLast modified 6mo agoCopy linkEdit on GitHubOn this pageEntitiesDomainTransferNewOwnerNewResolverNewTTLAccountRegistrationRegistrationEventNameRegisteredNameRenewedNameTransferredResolverResolverEventAddrChangedMulticoinAddrChangedNameChangedAbiChangedPubkeyChangedTextChangedContenthashChangedInterfaceChangedAuthorisationChanged "
139,mains contract api reference publicresolver#get contract abi,"mains contract api reference publicresolver#get contract abi.   PublicResolver - ENS Documentation    ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBookPublicResolverThe default public resolver.​Source​PublicResolver implements a general-purpose ENS resolver that is suitable for most standard ENS use-cases. The public resolver permits updates to ENS records by the owner of the corresponding name.The public resolver implements the following EIPs:​EIP 137 - Contract address interface (addr()).​EIP 165 - Interface Detection (supportsInterface()).​EIP 181 - Reverse resolution (name()).​EIP 205 - ABI support (ABI()).​EIP 619 - SECP256k1 public keys (pubkey()).​EIP 634 - Text records (text()).​EIP 1577 - Content hash support (contenthash()).​EIP 2304 - Multicoin support (addr()).While the PublicResolverprovides a convenient default implementation, many resolver implementations and versions exist. Callers must not assume that a domain uses the current version of the public resolver, or that all of the methods described here are present. To check if a resolver supports a feature, see Check Interface Support.Check Interface Supportfunction supportsInterface(bytes4 interfaceID) external pure returns (bool)ENS uses ERC 165 for interface detection. ERC 165 requires that supporting contracts implement a function, supportsInterface, which takes an interface ID and returns a boolean value indicating if this interface is supported or not.Interface IDs are calculated as the exclusive-or of the four-byte function identifiers of each function included in the interface. For example, addr(bytes32) has the function ID 0x3b3b57de. Because it is the only function in the Ethereum Address interface, its interface ID is also 0x3b3b57de, and so calling supportsInterface(0x3b3b57de) will return true for any resolver that supports addr().ERC 165 has an interface ID of 0x01ffc9a7, so supportsInterface(0x01ffc9a7) will always return true for any ERC 165 supporting contract (and hence for any resolver).Note that the public resolver does not expose explicit interfaces for setter functions, so there are no automated means to check for support for a given setter function.Get Ethereum Addressfunction addr(bytes32 node) external view returns (address)Returns the Ethereum address associated with the provided node, or 0 if none.This function has interface ID 0x3b3b57de.This function is specified in EIP 137.Set Ethereum Addressfunction setAddr(bytes32 node, address addr) external;Sets the Ethereum address associated with the provided node to addr.Only callable by the owner of node.Emits the following event:event AddrChanged(bytes32 indexed node, address a);Get Blockchain Addressfunction addr(bytes32 node, uint coinType) external view returns(bytes memory);Returns the Blockchain address associated with the provided node and coinType, or 0 if none.This function has interface ID 0xf1cb7e06.This function is specified in EIP 2304.The return value is the cryptocurrency address in its native binary format and each blockchain address has a different encoding and decoding method.For example, the Bitcoin address 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa base58check decodes to the 21 bytes 0062e907b15cbf27d5425399ebf6f0fb50ebb88f18 then scriptPubkey encodes to 25 bytes 76a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1888ac whereas the BNB address bnb1grpf0955h0ykzq3ar5nmum7y6gdfl6lxfn46h2 Bech32 decodes to the binary representation 40c2979694bbc961023d1d27be6fc4d21a9febe6.To convert the binary representation into the address, use formatsByCoinType[SYMBOL].encoder(binary) of address-encoder.A zero-length string will be returned if the specified coin ID does not exist on the specified node.Set Blockchain Addressfunction setAddr(bytes32 node, uint coinType, bytes calldata a) external;Sets the blockchain address associated with the provided node and coinType to addr.coinType is the cryptocurrency coin type index from SLIP44.To convert the address into the binary representation, use formatsByName[SYMBOL].decoder(text) of address-encoder​Only callable by the owner of node.Emits the following event:event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);Get Canonical Namefunction name(bytes32 node) external view returns (string memory);Returns the canonical ENS name associated with the provided node. Used exclusively for reverse resolution.This function has interface ID 0x691f3431.This function is specified in EIP 181.Set Canonical Namefunction setName(bytes32 node, string calldata name) external;Sets the canonical ENS name for the provided node to name.Only callable by the owner of node.Emits the following event:event NameChanged(bytes32 indexed node, string name);Get Content Hashfunction contenthash(bytes32 node) external view returns (bytes memory);Returns the content hash for node, if one exists. Values are formatted as machine-readable multicodecs, as specified in EIP 1577.contenthash is used to store IPFS and Swarm content hashes, which permit resolving ENS addresses to distributed content (eg, websites) hosted on these distributed networks.This function has interface ID 0xbc1c58d1.This function is specified in EIP 1577.Set Content Hashfunction setContenthash(bytes32 node, bytes calldata hash) external;Sets the content hash for the provided node to hash.Only callable by the owner of node.Values are formatted as machine-readable multicodecs, as specified in EIP 1577.Emits the following event:event ContenthashChanged(bytes32 indexed node, bytes hash);Get Contract ABIABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory);Returns a matching ABI definition for the provided node, if one exists. contentTypes is the bitwise-OR of the encodings that the caller can accept. If multiple content types are specified, the resolver will select one to return. Currently supported content types are:Content Type IDDescription1JSON2zlib-compressed JSON4​CBOR​8URIABI returns a two-tuple of the content type ID and the ABI data. If no data of the appropriate content type ID was found, 0 is returned for the content type ID, and the ABI data will be the empty string.This function has interface ID 0x2203ab56.This function is specified in EIP 205.Set Contract ABIfunction setABI(bytes32 node, uint256 contentType, bytes calldata data) externalSets or updates ABI data for node. contentType specifies the content type ID (see Get Contract ABI for valid values); exactly one type ID must be specified. data contains the encoded ABI data. To clear ABI data for a name, specify the empty string for data.Only callable by the owner of node.Emits the following event:event ABIChanged(bytes32 indexed node, uint256 indexed contentType);Get Public Keyfunction pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y)Returns the ECDSA SECP256k1 public key for node, as a 2-tuple (x, y). If no public key is set, (0, 0) is returned.This function has interface ID 0xc8690233.This function is specified in EIP 619.Set Public Keyfunction setPubkey(bytes32 node, bytes32 x, bytes32 y) externalSets the ECDSA SECP256k1 public key for node to (x, y).Only callable by the owner of node.Emits the following event:event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);Get Text Datafunction text(bytes32 node, string calldata key) external view returns (string memory)Retrieves text metadata for node. Each name may have multiple pieces of metadata, identified by a unique string key. If no text data exists for node with the key key, the empty string is returned.Standard values for key are:keyMeaningemailAn email addressurlA URLavatarA URL to an image used as an avatar or logodescriptionA description of the namenoticeA notice regarding this namekeywordsA list of comma-separated keywords, ordered by most significant first; clients that interpresent this field may choose a threshold beyond which to ignoreIn addition, anyone may specify vendor-specific keys, which must be prefixed with vnd.. The following vendor-specific keys are currently known:keyMeaningcom.twitterTwitter handlecom.githubGithub usernameThis function has interface ID 0x59d1d43c.This function is specified in EIP 634.Set Text Datafunction setText(bytes32 node, string calldata key, string calldata value) externalSets text metadata for node with the unique key key to value, overwriting anything previously stored for node and key. To clear a text field, set it to the empty string.Only callable by the owner of node.Emits the following event:event TextChanged(bytes32 indexed node, string indexedKey, string key);Multicallfunction multicall(bytes[] calldata data) external returns(bytes[] memory results)Permits users to set multiple records in a single operation.Use encodeABI function to encode your contract calls and pass it to data.The frontend usage will be as follows:var addrSet = resolver.contract.methods['setAddr(bytes32,address)'](node, accounts[1]).encodeABI();var textSet = resolver.contract.methods.setText(node, ""url"", ""https://ethereum.org/"").encodeABI();var tx = await resolver.multicall([addrSet, textSet], {from: accounts[0]});Contract API Reference - PreviousTestRegistrarNext - Contract API Reference.eth Permanent RegistrarLast modified 1yr agoCopy linkEdit on GitHubOn this pageCheck Interface SupportGet Ethereum AddressSet Ethereum AddressGet Blockchain AddressSet Blockchain AddressGet Canonical NameSet Canonical NameGet Content HashSet Content HashGet Contract ABISet Contract ABIGet Public KeySet Public KeyGet Text DataSet Text DataMulticall "
140,mains contract api reference .eth permanent registrar,"mains contract api reference .eth permanent registrar.   .eth Permanent Registrar - ENS Documentation   ENS DocumentationTechnical DocumentationHomeTechnical DocsGovernance DocsSearch…⌃KLinksTechnical DocumentationIntroductionTerminologyFrequently Asked QuestionsENS DeploymentsRegistrar Frequently Asked QuestionsDeploying ENS on a Private ChainDNS Registrar guideBug Bounty ProgramENS Improvement ProposalsDapp Developer GuideENS Enabling your DAppENS LibrariesWorking with ENSResolving NamesManaging NamesRegistering & Renewing NamesENS Front-End Design GuidelinesENS as NFTENS Layer2 and offchain data supportENS Data guideContract API ReferenceName ProcessingRegistryReverseRegistrarTestRegistrarPublicResolver.eth Permanent RegistrarRegistrarControllerDNS RegistrarSubgraphContract Developer GuideResolving Names On-chainWriting a ResolverWriting a RegistrarENS Discussion ForumENS Support ChatENS Migration (February 2020)Guide for DApp DevelopersTechnical DescriptionPowered By GitBook.eth Permanent RegistrarThe Permanent Registrar is the code that will govern allocation and renewal of names in the .eth TLD.System architectureCode for the permanent registrar can be found in the ethregistrar repository.The registrar itself is called BaseRegistrar. This contract implements several key functions:The owner of the registrar may add and remove 'controllers'.Controllers may register new domains and extend the expiry of (renew) existing domains. They can not change the ownership or reduce the expiration time of existing domains.Name owners may transfer ownership to another address.Name owners may reclaim ownership in the ENS registry if they have lost it.Owners of names in the legacy registrar may transfer them to the new registrar, during the 1 year transition period. When they do so, their deposit is returned to them in its entirety.In addition, the registrar is an ERC721 compliant nonfungable token contract, meaning that .eth registrations can be transferred in the same fashion as other NFTs.Users will interact directly with this contract when transferring ownership of names, or recovering ownership in the ENS registry of a name (for example, one whose ownership was previously transferred to a contract). Users can also query names to see their registration status and expiry date. For initial registration and for renewals, users will need to interact with a controller contract.This separation of concerns reduces the attack surface for the registrar, and provides users with guarantees of continued ownership of a name so long as the registrar is in place. Simultaneously, it provides for improvement and innovation over registration and renewal mechanisms. A future update may transfer ownership of the root and the .eth TLD to a contract with restricted permissions, thus preventing even the root keyholders from modifying a .eth registraion, while still providing for future updates to the set of controllers.Initially, one controller is implemented, the ETHRegistrarController. This controller provides a straightforward registration and renewal mechanism for domains that are 7 or more characters long, implementing the following functionality:The owner of the controller may set a price oracle contract, which determines the cost of registrations and renewals based on the name and the desired registration or renewal duration.The owner of the controller may withdraw any collected funds to their account.Users can register new names using a commit/reveal process and by paying the appropriate registration fee.Users can renew a name by paying the appropriate fee. Any user may renew a domain, not just the name's owner. There is no limit on renewal duration.By allowing anyone to renew a domain, users concerned with the longevity of a name they interact with can ensure it remains registered by paying for the registration themselves, if necessary.By allowing renewal for arbitrarily long periods of time, users can 'lock in' a desirable registration fee. Names can be made effectively 'immortal' by renewing for a long period, ensuring that stability of the name can be guaranteed by smart contract.Initially, a single pricing oracle was deployed, the StablePriceOracle. This contract permits its owner to set prices in USD for each permitted name length, and uses a USD:ETH price oracle to convert those prices into Ether at the current rate. Users will not have to interact with this oracle directly, as the controller provides functionality to determine pricing for a candidate name registration or renewal.DiscoveryFinding the address of the new registrar is straightforward: look up the owner of the domain 'eth' in ENS, by calling owner(namehash('eth')) on the ENS registry.In order to support discovering the address of the controller, ENS supports interface discovery via EIP 1844. This mechanism permits looking up the address of the contract that implements a required interface via the following process:1.Set node = namehash('eth').2.Look up the ENS resolver by calling resolver(node) on the ENS registry.3.Call the interfaceImplementer(node, interfaceId) method on that resolver, where interfaceId is the EIP 165 interface ID of the interface you need.The following interface IDs are presently defined for the .eth permanent registrar:0x6ccb2df4, the interface ID for ERC721 (NFTs). This returns the address of the registrar itself (which can also be fetched by doing an address lookup, or by looking up the owner of '.eth'.0x018fac06, the interface ID for the controller. Returns the controller's address.0x7ba18ba1, the interface ID for the legacy registrar's migration function. Returns the legacy registrar's address.Contract API Reference - PreviousPublicResolverNextRegistrarLast modified 1yr agoCopy linkEdit on GitHubOn this pageSystem architectureDiscovery "
