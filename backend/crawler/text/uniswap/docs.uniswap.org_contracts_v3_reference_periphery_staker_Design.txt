








Uniswap V3 Staker Design | Uniswap





Skip to main contentUniswap DocsConceptsContractsSDKsAPIsGive FeedbackWhitepaperGitHubGrantsSearchV3 ProtocolOverviewGuidesSet Up Your Local EnvironmentImplement A SwapProviding LiquidityLiquidity MiningImplement Flash SwapsGovernance ProposalsTechnical ReferenceOverviewCoreGovernancePeripheryBaseInterfacesLensLibrariesStakerUniswap V3 Staker DesignUniswap V3 Staker ContractInterfacesLibrariesTestNonfungiblePositionManagerNonfungibleTokenPositionDescriptorSwapRouterV3MigratorDeployment AddressesError CodesUniversal RouterPermit2V2 ProtocolV1 ProtocolðŸ V3 ProtocolTechnical ReferencePeripheryStakerUniswap V3 Staker DesignHelpful?On this pageUniswap V3 Staker DesignThe liquidity mining staker design is comprised of one canonical position staking contract, Staker. The technical reference for this contract is here and the source code is here.Data Structuresâ€‹struct Incentive {  uint128 totalRewardUnclaimed;  uint128 numberOfStakes;  uint160 totalSecondsClaimedX128;}struct Deposit {  address owner;  uint96 numberOfStakes;}struct Stake {  uint160 secondsPerLiquidityInsideInitialX128;  uint128 liquidity;}struct IncentiveKey {        IERC20Minimal rewardToken;        IUniswapV3Pool pool;        uint256 startTime;        uint256 endTime;        address refundee;}CopyState:IUniswapV3Factory public immutable factory;INonfungiblePositionManager public immutable nonfungiblePositionManager;/// @dev bytes32 refers to the return value of IncentiveId.computemapping(bytes32 => Incentive) public incentives;/// @dev deposits[tokenId] => Depositmapping(uint256 => Deposit) public deposits;/// @dev stakes[tokenId][incentiveHash] => Stakemapping(uint256 => mapping(bytes32 => Stake)) public stakes;/// @dev rewards[rewardToken][msg.sender] => uint256mapping(address => mapping(address => uint256)) public rewards;CopyParams:struct CreateIncentiveParams {  address rewardToken;  address pool;  uint256 startTime;  uint256 endTime;  uint128 totalReward;}struct EndIncentiveParams {  address creator;  address rewardToken;  address pool;  uint256 startTime;  uint256 endTime;}CopyIncentivesâ€‹createIncentive(CreateIncentiveParams memory params)â€‹createIncentive creates a liquidity mining incentive program. The key used to look up an Incentive is the hash of its immutable properties.Check:Incentive with these params does not already existTimestamps: params.endTime >= params.startTime, params.startTime >= block.timestampIncentive with this ID does not already exist.Effects:Sets incentives[key] = Incentive(totalRewardUnclaimed=totalReward, totalSecondsClaimedX128=0, rewardToken=rewardToken)Interaction:Transfers params.totalReward from msg.sender to self.Make sure there is a check here and it fails if the transfer failsEmits IncentiveCreatedendIncentive(EndIncentiveParams memory params)â€‹endIncentive can be called by anyone to end an Incentive after the endTime has passed, transferring totalRewardUnclaimed of rewardToken back to refundee.Check:block.timestamp > params.endTimeIncentive exists (incentive.totalRewardUnclaimed != 0)Effects:deletes incentives[key] (This is a new change)Interactions:safeTransfers totalRewardUnclaimed of rewardToken to the incentive creator msg.senderemits IncentiveEndedDeposit/Withdraw Tokenâ€‹InteractionsnonfungiblePositionManager.safeTransferFrom(sender, this, tokenId)This transfer triggers the onERC721Received hookonERC721Received(address, address from, uint256 tokenId, bytes calldata data)â€‹Check:Make sure sender is univ3 nftEffects:Creates a deposit for the token setting deposit owner to from.Setting owner to from ensures that the owner of the token also owns the deposit. Approved addresses and operators may first transfer the token to themselves before depositing for deposit ownership.If data.length>0, stakes the token in one or more incentiveswithdrawToken(uint256 tokenId, address to, bytes memory data)â€‹ChecksCheck that a Deposit exists for the token and that msg.sender is the owner on that Deposit.Check that numberOfStakes on that Deposit is 0.EffectsDelete the Deposit delete deposits[tokenId].InteractionssafeTransferFrom the token to to with data.emit DepositTransferred(token, deposit.owner, address(0))Stake/Unstake/Rewardsâ€‹stakeTokenâ€‹Check:deposits[params.tokenId].owner == msg.senderMake sure incentive actually exists and has reward that could be claimed (incentive.rewardToken != address(0))Check if this check can check totalRewardUnclaimed insteadMake sure token not already stakedclaimRewardâ€‹Interactionsmsg.sender to withdraw all of their reward balance in a specific token to a specified to address.emit RewardClaimed(to, reward)unstakeTokenâ€‹To unstake an NFT, you call unstakeToken, which takes all the same arguments as stake.ChecksIt checks that you are the owner of the DepositIt checks that there exists a Stake for the provided key (with exists=true).EffectsDeletes the Stake.Decrements numberOfStakes for the Deposit by 1.totalRewardsUnclaimed is decremented by reward.totalSecondsClaimed is incremented by seconds.Increments rewards[rewardToken][msg.sender] by the amount given by getRewardInfo.getRewardInfoâ€‹It computes secondsInsideX128 (the total liquidity seconds for which rewards are owed) for a given Stake, by:usingsnapshotCumulativesInside from the Uniswap v3 core contract to get secondsPerLiquidityInRangeX128, and subtracting secondsPerLiquidityInRangeInitialX128.Multiplying that by stake.liquidity to get the total seconds accrued by the liquidity in that periodNote that X128 means it's a UQ32X128.It computes totalSecondsUnclaimed by taking max(endTime, block.timestamp) - startTime, casting it as a Q128, and subtracting totalSecondsClaimedX128.It computes rewardRate for the Incentive casting incentive.totalRewardUnclaimed as a Q128, then dividing it by totalSecondsUnclaimedX128.reward is then calculated as secondsInsideX128 times the rewardRate, scaled down to a regular uint128.Edit this pageHelpful?PreviousWeightedOracleLibraryNextUniswap V3 Staker ContractData StructuresIncentivescreateIncentive(CreateIncentiveParams memory params)endIncentive(EndIncentiveParams memory params)Deposit/Withdraw TokenonERC721Received(address, address from, uint256 tokenId, bytes calldata data)withdrawToken(uint256 tokenId, address to, bytes memory data)Stake/Unstake/RewardsstakeTokenclaimRewardunstakeTokengetRewardInfoDevelopersFeedbackBug Bounty#dev-chatWhitepaperGithubuniswap-v3-coreuniswap-v3-sdkuniswap-v3-peripheryDeployment addressesEcosystemHomeAppAnalyticsToken ListsBrand AssetsCommunityGovernanceDiscordTwitterBlog



