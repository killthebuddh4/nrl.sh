








AllowanceTransfer | Uniswap





Skip to main contentUniswap DocsConceptsContractsSDKsAPIsGive FeedbackWhitepaperGitHubGrantsSearchV3 ProtocolOverviewGuidesSet Up Your Local EnvironmentImplement A SwapProviding LiquidityLiquidity MiningImplement Flash SwapsGovernance ProposalsTechnical ReferenceUniversal RouterPermit2OverviewTechnical ReferenceSignatureTransferAllowanceTransferV2 ProtocolV1 Protocol🏠Permit2Technical ReferenceAllowanceTransferHelpful?On this pageAllowanceTransferSource CodeOverview​The main entry points on this contract are:approveUse approve when you do not want to set token permissions through signature validation.permitUse permit when you do want to set token permissions through signature validation.transferFromUse transferFrom when you want to transfer a token and have the necessary permissions to do so.Functions​approve​Function Signaturefunction approve(address token, address spender, uint160 amount, uint48 expiration) externalCopyParameterstoken - the token address to approvespender - the spender address to approveamount - the approved amount of the token, type(uint160).max is treated as an unlimited allowanceexpiration - the timestamp at which the approval is no longer valid, passing in 0 will expire the permissions at block.timestampSingle permit​Function Signaturefunction permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;CopyParametersowner - the address of the token’s ownerpermitSingle - constructed with the following:struct PermitSingle {        // the permit data for a single token allowance        PermitDetails details;        // address permissioned on the allowed tokens        address spender;        // deadline on the permit signature        uint256 sigDeadline;    }struct PermitDetails {        // ERC20 token address        address token;        // the maximum amount allowed to spend        uint160 amount;        // timestamp at which a spender's token allowances become invalid        uint48 expiration;        // an incrementing value indexed per owner,token,and spender for each signature        uint48 nonce;    }Copysignature - the signature over the permit data. Supports EOA signatures, compact signatures defined by EIP-2098, and contract signatures defined by EIP-1271Batched permit​Function Signaturefunction permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;CopyParametersowner - the address of the token’s ownerpermitBatch - constructed with the following:struct PermitBatch {        // the permit data for multiple token allowances        PermitDetails[] details;        // address permissioned on the allowed tokens        address spender;        // deadline on the permit signature        uint256 sigDeadline;    }struct PermitDetails {        // ERC20 token address        address token;        // the maximum amount allowed to spend        uint160 amount;        // timestamp at which a spender's token allowances become invalid        uint48 expiration;        // an incrementing value indexed per owner,token,and spender for each signature        uint48 nonce;    }Copysignature - the signature over the permit data. Supports EOA signatures, compact signatures defined by EIP-2098, and contract signatures defined by EIP-1271Single transferFrom​Function Signaturefunction transferFrom(address from, address to, uint160 amount, address token) external;CopyParametersfrom - the address to transfer the token fromto -  the address of the recipientamount - the amount of the token to transfer, the maximum amount is type(uint160).maxtoken - the address of the token to be transferredBatched transferFrom​Function Signaturefunction transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;CopyParameterstransferDetails - constructed with the followingstruct AllowanceTransferDetails {        // the owner of the token        address from;        // the recipient of the token        address to;        // the amount of the token        uint160 amount;        // the token to be transferred        address token;    }CopyNonce Schema​The nonces used to protect against replay attacks of signatures are similar to standard incrementing nonces. However, we pack nonces with an allowed amount, and an allowed duration. This means that nonces are incremented per owner, per token, and per spender. Which further implies that you could sign two different permits at the same time with the same nonces and they won’t cancel each other out so long as the token or spender differ.The mapping nonces are packed in is defined as follows:mapping(address => mapping(address => mapping(address => PackedAllowance))) public allowance;Copyand indexed as follows:PackedAllowance allowanceInformation = allowance[ownerAddress][tokenAddress][spenderAddress];uint48 nonce = allowanceInformation.nonce;CopySecurity Considerations​Similar to the security considerations outlined in SignatureTransfer, integrating contracts need to perform valid safety checks on the caller and pass in correct addresses for the from argument in any transfer calls.All amounts on the AllowanceTransfer contract are of type uint160 so make sure integrating contracts safely downcast if they have to. See how Permit2Lib downcasts safely.Edit this pageHelpful?PreviousSignatureTransferNextOverviewOverviewFunctionsapproveSingle permitBatched permitSingle transferFromBatched transferFromNonce SchemaSecurity ConsiderationsDevelopersFeedbackBug Bounty#dev-chatWhitepaperGithubuniswap-v3-coreuniswap-v3-sdkuniswap-v3-peripheryDeployment addressesEcosystemHomeAppAnalyticsToken ListsBrand AssetsCommunityGovernanceDiscordTwitterBlog



